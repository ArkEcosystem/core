"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var lock_parser_1 = require("./lock-parser");
var dependencies_parser_1 = require("./dependencies-parser");
var path = require("path");
var fs = require("fs");
var errors_1 = require("./errors");
exports.InvalidUserInputError = errors_1.InvalidUserInputError;
exports.OutOfSyncError = errors_1.OutOfSyncError;
var DEV_GROUPS = ['build', 'test', 'tests'];
var SUPPORTED_SOURCES = ['nuget'];
var FREQUENCY_THRESHOLD = 100;
var DepType;
(function (DepType) {
    DepType["prod"] = "prod";
    DepType["dev"] = "dev";
})(DepType = exports.DepType || (exports.DepType = {}));
function buildDepTreeFromFiles(root, manifestFilePath, lockFilePath, includeDev, strict) {
    if (includeDev === void 0) { includeDev = false; }
    if (strict === void 0) { strict = true; }
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var manifestFileFullPath, lockFileFullPath, manifestFileContents, lockFileContents, _a;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    manifestFileFullPath = path.resolve(root, manifestFilePath);
                    lockFileFullPath = path.resolve(root, lockFilePath);
                    if (!fs.existsSync(manifestFileFullPath)) {
                        throw new errors_1.InvalidUserInputError('Target file paket.dependencies not found at ' +
                            ("location: " + manifestFileFullPath));
                    }
                    if (!fs.existsSync(lockFileFullPath)) {
                        throw new errors_1.InvalidUserInputError('Lockfile not found at location: ' +
                            lockFileFullPath);
                    }
                    manifestFileContents = fs.readFileSync(manifestFileFullPath, 'utf-8');
                    lockFileContents = fs.readFileSync(lockFileFullPath, 'utf-8');
                    _a = {};
                    return [4 /*yield*/, buildDepTree(manifestFileContents, lockFileContents, includeDev, strict)];
                case 1: return [2 /*return*/, (_a.dependencies = _b.sent(),
                        _a.name = path.basename(path.dirname(manifestFileFullPath)),
                        _a.version = '',
                        _a)];
            }
        });
    });
}
exports.buildDepTreeFromFiles = buildDepTreeFromFiles;
function buildDepTree(manifestFileContents, lockFileContents, includeDev, strict) {
    if (includeDev === void 0) { includeDev = false; }
    if (strict === void 0) { strict = true; }
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var e_1, _a, e_2, _b, manifestFile, lockFile, dependenciesMap, _c, _d, dep, dependencies, _e, _f, dep, frequentSubTree;
        return tslib_1.__generator(this, function (_g) {
            manifestFile = dependencies_parser_1.parseDependenciesFile(manifestFileContents);
            lockFile = lock_parser_1.parseLockFile(lockFileContents);
            dependenciesMap = new Map();
            collectRootDeps(manifestFile, dependenciesMap);
            collectResolvedDeps(lockFile, dependenciesMap);
            try {
                for (_c = tslib_1.__values(dependenciesMap.values()), _d = _c.next(); !_d.done; _d = _c.next()) {
                    dep = _d.value;
                    if (dep.root) {
                        calculateReferences(dep, dependenciesMap);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            dependencies = {};
            try {
                for (_e = tslib_1.__values(dependenciesMap.values()), _f = _e.next(); !_f.done; _f = _e.next()) {
                    dep = _f.value;
                    if (dep.root && (includeDev || dep.depType === DepType.prod)) {
                        if (strict && !dep.resolved) {
                            throw new errors_1.OutOfSyncError(dep.name);
                        }
                        dependencies[dep.name] = buildTreeFromList(dep, dependenciesMap);
                        if (!dep.resolved) {
                            dependencies[dep.name].missingLockFileEntry = true;
                        }
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_2) throw e_2.error; }
            }
            frequentSubTree = buildFrequentDepsSubtree(dependenciesMap);
            if (Object.keys(frequentSubTree.dependencies).length) {
                dependencies[frequentSubTree.name] = frequentSubTree;
            }
            return [2 /*return*/, dependencies];
        });
    });
}
function collectRootDeps(manifestFile, dependenciesMap) {
    var e_3, _a, e_4, _b;
    try {
        for (var manifestFile_1 = tslib_1.__values(manifestFile), manifestFile_1_1 = manifestFile_1.next(); !manifestFile_1_1.done; manifestFile_1_1 = manifestFile_1.next()) {
            var group = manifestFile_1_1.value;
            var isDev = DEV_GROUPS.indexOf((group.name || '').toLowerCase()) !== -1;
            try {
                for (var _c = tslib_1.__values(group.dependencies), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var dep = _d.value;
                    if (SUPPORTED_SOURCES.indexOf(dep.source.toLowerCase()) === -1) {
                        continue;
                    }
                    var nugetDep = dep;
                    if (!dependenciesMap.has(nugetDep.name.toLowerCase())) {
                        dependenciesMap.set(nugetDep.name.toLowerCase(), {
                            name: nugetDep.name,
                            // Will be overwritten in `collectResolvedDeps`.
                            version: nugetDep.versionRange,
                            // Will be overwritten in `collectResolvedDeps`.
                            dependencies: [],
                            depType: isDev ? DepType.dev : DepType.prod,
                            root: true,
                            refs: 1,
                            // Will be overwritten in `collectResolvedDeps`.
                            resolved: false,
                        });
                    }
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                }
                finally { if (e_4) throw e_4.error; }
            }
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (manifestFile_1_1 && !manifestFile_1_1.done && (_a = manifestFile_1.return)) _a.call(manifestFile_1);
        }
        finally { if (e_3) throw e_3.error; }
    }
}
function collectResolvedDeps(lockFile, dependenciesMap) {
    var e_5, _a, e_6, _b;
    try {
        for (var _c = tslib_1.__values(lockFile.groups), _d = _c.next(); !_d.done; _d = _c.next()) {
            var group = _d.value;
            var isDev = DEV_GROUPS.indexOf((group.name || '').toLowerCase()) !== -1;
            try {
                for (var _e = tslib_1.__values(group.dependencies), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var dep = _f.value;
                    if (SUPPORTED_SOURCES.indexOf(dep.repository.toLowerCase()) === -1) {
                        continue;
                    }
                    if (dependenciesMap.has(dep.name.toLowerCase())) {
                        var rootDep = dependenciesMap.get(dep.name.toLowerCase());
                        rootDep.version = dep.version;
                        rootDep.dependencies = dep.dependencies.map(function (d) { return d.name.toLowerCase(); });
                        rootDep.resolved = true;
                    }
                    else {
                        dependenciesMap.set(dep.name.toLowerCase(), {
                            name: dep.name,
                            version: dep.version,
                            dependencies: dep.dependencies.map(function (d) { return d.name.toLowerCase(); }),
                            depType: isDev ? DepType.dev : DepType.prod,
                            root: false,
                            refs: 0,
                            resolved: true,
                        });
                    }
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_6) throw e_6.error; }
            }
        }
    }
    catch (e_5_1) { e_5 = { error: e_5_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
        }
        finally { if (e_5) throw e_5.error; }
    }
}
function calculateReferences(node, dependenciesMap) {
    var e_7, _a;
    try {
        for (var _b = tslib_1.__values(node.dependencies), _c = _b.next(); !_c.done; _c = _b.next()) {
            var subName = _c.value;
            var sub = dependenciesMap.get(subName);
            sub.refs += node.refs;
            // Do not propagate calculations if we already reach threshold for the node.
            if (sub.refs < FREQUENCY_THRESHOLD) {
                calculateReferences(sub, dependenciesMap);
            }
        }
    }
    catch (e_7_1) { e_7 = { error: e_7_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_7) throw e_7.error; }
    }
}
function buildFrequentDepsSubtree(dependenciesMap) {
    var tree = {
        name: 'meta-common-packages',
        version: 'meta',
        dependencies: {},
    };
    getFrequentDependencies(dependenciesMap).forEach(function (listItem) {
        var treeNode = buildTreeFromList(listItem, dependenciesMap);
        tree.dependencies[treeNode.name] = treeNode;
    });
    return tree;
}
function getFrequentDependencies(dependenciesMap) {
    var e_8, _a;
    var frequentDeps = [];
    try {
        for (var _b = tslib_1.__values(dependenciesMap.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
            var dep = _c.value;
            if (!dep.root && dep.refs >= FREQUENCY_THRESHOLD) {
                frequentDeps.push(dep);
            }
        }
    }
    catch (e_8_1) { e_8 = { error: e_8_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_8) throw e_8.error; }
    }
    return frequentDeps;
}
function buildTreeFromList(listItem, dependenciesMap) {
    var e_9, _a;
    var tree = {
        name: listItem.name,
        version: listItem.version,
        dependencies: {},
        depType: listItem.depType,
    };
    try {
        for (var _b = tslib_1.__values(listItem.dependencies), _c = _b.next(); !_c.done; _c = _b.next()) {
            var name = _c.value;
            var subListItem = dependenciesMap.get(name);
            if (!(subListItem.refs >= FREQUENCY_THRESHOLD)) {
                var subtree = buildTreeFromList(subListItem, dependenciesMap);
                tree.dependencies[subtree.name] = subtree;
            }
        }
    }
    catch (e_9_1) { e_9 = { error: e_9_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_9) throw e_9.error; }
    }
    return tree;
}
//# sourceMappingURL=index.js.map