"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var line_parser_1 = require("./line-parser");
var COMMENTS = ['#', '//'];
var GROUP = 'group';
var SOURCE = 'source';
// https://fsprojects.github.io/Paket/dependencies-file.html#Sources
var GITHUB = 'github';
var NUGET = 'nuget';
var CLITOOL = 'clitool';
var GIT = 'git';
var GIST = 'gist';
var HTTP = 'http';
function parseNuget(line) {
    var commentRegex = new RegExp("(?:" + COMMENTS[0] + "|" + COMMENTS[1] + ").+");
    var nameVersionOptionsRegex = new RegExp(/(\S+)\s*([^:\n]*)(:.*)?/);
    var versionFirstOptionRegex = new RegExp(/\s(?=[^ ]*$)/);
    var _a = tslib_1.__read(line
        .replace(NUGET, '') // Remove 'nuget' string
        .replace(commentRegex, '') // Remove comments from line end
        .trim()
        .match(nameVersionOptionsRegex), 4), name = _a[1], versionRangeAndFirstOption = _a[2], restOptions = _a[3]; // Split into groups for further parsing
    // nuget dependency result object to be returned
    var result = {
        source: NUGET,
        name: name,
        versionRange: versionRangeAndFirstOption,
        options: {},
    };
    if (restOptions) {
        // tslint:disable-next-line:prefer-const
        var _b = tslib_1.__read(versionRangeAndFirstOption.split(versionFirstOptionRegex), 2), versionRange = _b[0], firstOptionName = _b[1];
        result.versionRange = versionRange;
        // If version is missing it will treat first option as version
        if (!firstOptionName) {
            result.versionRange = '';
            firstOptionName = versionRange;
        }
        result.options = ("" + firstOptionName + restOptions)
            .split(/\s*,\s*/) // Split by comma if there is couple possibilities for option (e.g. framework >= net40, net45)
            .reverse()
            .reduce(function (optionsMap, option, index, array) {
            if (option.includes(':')) {
                var _a = tslib_1.__read(option.split(/:\s*/), 2), optionKey = _a[0], value = _a[1];
                optionsMap[optionKey] = value;
            }
            else {
                array[index + 1] = array[index + 1] + ", " + option;
            }
            return optionsMap;
        }, {});
    }
    return result;
}
// https://fsprojects.github.io/Paket/github-dependencies.html
function parseGithub(line) {
    var re = /"[^"]*"|\S+/g;
    var parts = line.match(re).splice(1);
    var _a = tslib_1.__read(parts[0].split(':'), 2), repo = _a[0], version = _a[1];
    return {
        file: parts[1] || '',
        repo: repo,
        source: 'github',
        token: parts[2] || '',
        version: version || '',
    };
}
// https://fsprojects.github.io/Paket/nuget-dependencies.html#NuGet-feeds
function parseSource(line) {
    // Split URL and option string including possible comments.
    var urlRe = /^source ([^\s]+)(.*)$/i;
    var _a = tslib_1.__read(line.match(urlRe), 3), url = _a[1], optionsString = _a[2];
    // Options in this line is always double quoted.
    var options = {};
    var optionsRe = /(.*?)\W*:\W*"(.*?)"/g;
    var optionsStringTrimmed = optionsString.trim();
    var matches = optionsRe.exec(optionsStringTrimmed);
    while (matches) {
        options[matches[1].trim()] = matches[2].trim();
        matches = optionsRe.exec(optionsStringTrimmed);
    }
    return {
        options: options,
        url: url,
    };
}
function parseGroupOption(line) {
    // Line could be separated by space or by colon.
    // TODO: Think what to do with possible comment in the line.
    var result = line.match(/(\S+?)\s*(:|\s)\s*(.*)/);
    return [result[1] || '', result[3] || ''];
}
function parseDependenciesFile(input) {
    var e_1, _a;
    var lines = line_parser_1.parseLines(input);
    var result = [];
    var group = {
        dependencies: [],
        name: null,
        options: {},
        sources: [],
    };
    var _loop_1 = function (line) {
        var isComment = !!COMMENTS.find(function (comment) { return line.data.startsWith(comment); });
        // Ignore commented lines.
        if (isComment) {
            return "continue";
        }
        if (line.data.startsWith(GROUP + " ")) {
            result.push(group);
            group = {
                dependencies: [],
                name: line.data.replace(GROUP, '').trim(),
                options: {},
                sources: [],
            };
        }
        else if (line.data.startsWith(SOURCE + " ")) {
            group.sources.push(parseSource(line.data));
        }
        else if (line.data.startsWith(GITHUB + " ")) {
            group.dependencies.push(parseGithub(line.data));
        }
        else if (line.data.startsWith(NUGET + " ")) {
            group.dependencies.push(parseNuget(line.data));
        }
        else if (line.data.startsWith(CLITOOL + " ")) {
            // TODO
        }
        else if (line.data.startsWith(GIT + " ")) {
            // TODO
        }
        else if (line.data.startsWith(GIST + " ")) {
            // TODO
        }
        else if (line.data.startsWith(HTTP + " ")) {
            // TODO
        }
        else {
            var _a = tslib_1.__read(parseGroupOption(line.data), 2), name = _a[0], value = _a[1];
            group.options[name] = value;
        }
    };
    try {
        for (var lines_1 = tslib_1.__values(lines), lines_1_1 = lines_1.next(); !lines_1_1.done; lines_1_1 = lines_1.next()) {
            var line = lines_1_1.value;
            _loop_1(line);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (lines_1_1 && !lines_1_1.done && (_a = lines_1.return)) _a.call(lines_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    result.push(group);
    return result;
}
exports.parseDependenciesFile = parseDependenciesFile;
//# sourceMappingURL=dependencies-parser.js.map