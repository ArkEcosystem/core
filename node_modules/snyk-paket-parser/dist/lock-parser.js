"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var line_parser_1 = require("./line-parser");
var REPOSITORY_TYPES = ['HTTP', 'GIST', 'GIT', 'NUGET', 'GITHUB']; // naming convention in paket's standard parser
var GROUP = 'GROUP';
var REMOTE = 'REMOTE';
var SPECS = 'SPECS';
function parseOptions(optionsString) {
    var e_1, _a;
    var options = {};
    try {
        for (var _b = tslib_1.__values(optionsString.split(/, +/)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var option = _c.value;
            var optionParts = option.split(/: +/);
            if (optionParts[0] !== '') {
                options[optionParts[0]] = optionParts[1];
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return options;
}
function parseDependencyLine(line, isSubDependency) {
    var re = /^([^ ]+)\W+\(([^)]+)\)\W*(.*)$/;
    var match = line.data.match(re);
    var result = {
        name: '',
        version: '',
        options: {},
    };
    if (!match && !isSubDependency) {
        throw new Error("Malformed paket.lock file: Missing resolved version on " + line.data);
    }
    //    Octokit (0.10.0)
    //      Microsoft.Net.Http
    // For this case where there is no version in the transitive,
    // we are not yet sure it is valid but want to retain the data.
    if (!match) {
        result.name = line.data;
    }
    else {
        result.name = match[1];
        result.version = match[2];
        result.options = parseOptions(match[3]);
    }
    if (!isSubDependency) {
        result.dependencies = [];
    }
    return result;
}
function parseLockFile(input) {
    var e_2, _a;
    var result = {
        groups: [],
    };
    var lines = line_parser_1.parseLines(input);
    var group = {
        name: null,
        repositories: {},
        dependencies: [],
    };
    var depContext = {};
    var dependency = null;
    try {
        for (var lines_1 = tslib_1.__values(lines), lines_1_1 = lines_1.next(); !lines_1_1.done; lines_1_1 = lines_1.next()) {
            var line = lines_1_1.value;
            var upperCaseLine = line.data.toUpperCase();
            if (line.indentation === 0) { // group or group option
                if (upperCaseLine.startsWith(GROUP)) {
                    result.groups.push(group);
                    depContext = {};
                    group = {
                        name: line.data.substr(GROUP.length).trim(),
                        repositories: {},
                        dependencies: [],
                    };
                }
                else if (REPOSITORY_TYPES.indexOf(upperCaseLine) !== -1) {
                    depContext.repository = line.data;
                    group.repositories[line.data] = [];
                }
                else {
                    var _b = tslib_1.__read(line.data.split(':'), 2), optionName = _b[0], optionValue = _b[1];
                    group.options = group.options || {};
                    // TODO: keeping null option values to know the option names
                    // need to decide what to do with them
                    group.options[optionName.trim()] = optionValue ? optionValue.trim() : null;
                }
            }
            else if (line.indentation === 1) { // remote or specs
                if (upperCaseLine.startsWith(REMOTE)) {
                    var remote = line.data.substring(REMOTE.length + ':'.length).trim();
                    if (remote) {
                        depContext.remote = remote;
                        group.repositories[depContext.repository].push(remote);
                    }
                }
                else if (upperCaseLine.startsWith(SPECS)) {
                    // TODO: for now we add the specs as boolean in meta
                    group.specs = true;
                }
            }
            else {
                var dep = parseDependencyLine(line, line.indentation === 3);
                if (line.indentation === 2) { // Resolved Dependency
                    dep.remote = depContext.remote;
                    dep.repository = depContext.repository;
                    dependency = dep;
                }
                else { // Transitive Dependency
                    dependency.dependencies.push(dep);
                }
            }
            if (group && dependency && group.dependencies.indexOf(dependency) === -1) {
                group.dependencies.push(dependency);
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (lines_1_1 && !lines_1_1.done && (_a = lines_1.return)) _a.call(lines_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    result.groups.push(group);
    return result;
}
exports.parseLockFile = parseLockFile;
//# sourceMappingURL=lock-parser.js.map