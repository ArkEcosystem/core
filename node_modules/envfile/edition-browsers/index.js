/* eslint no-sync:0, no-unused-vars:0 */
'use strict'; // Requires

var ambi = require('ambi');

var eachr = require('eachr');

var typeChecker = require('typechecker');

var fs = require('fs');
/**
 * @callback ObjectErrback
 * @param {Error?} error An error if one occured.
 * @param {object} [result]
 * @returns {void}
 */

/**
 * @callback StringErrback
 * @param {Error?} error An error if one occured.
 * @param {string} [result]
 * @returns {void}
 */

/**
 * Parse an envfile string synchronously
 * @param {string} src
 * @returns {object}
 */


function parseSync(src) {
  // Try parse JSON
  try {
    return JSON.parse(src.toString());
  } catch (err) {
    // Try parse envfile string
    var result = {};
    var lines = src.toString().split('\n');
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = lines[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var line = _step.value;
        var match = line.match(/^([^=:#]+?)[=:](.*)/);

        if (match) {
          var key = match[1].trim();
          var value = match[2].trim();
          result[key] = value;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return result;
  }
}
/**
 * Parse an envfile string
 * @param {string} src
 * @param {ObjectErrback} next
 * @returns {void}
 */


function parse(src, next) {
  // Call the synchronous method asynchronously and avoid zalgo by wrapping in nextTick
  process.nextTick(function () {
    ambi(parseSync, src, next);
  });
}
/**
 * Parse an env file asynchronously
 * @param {string} filePath
 * @param {ObjectErrback} next
 * @returns {void}
 */


function parseFile(filePath, next) {
  // Read
  fs.readFile(filePath, function (err, data) {
    // Check
    if (err) return next(err); // exit
    // Parse

    parse(data.toString(), next);
  });
}
/**
 * Parse an env file synchronously
 * @param {string} filePath
 * @returns {object}
 */


function parseFileSync(filePath) {
  // Read
  var data = fs.readFileSync(filePath); // Check the result

  if (typeChecker.isError(data)) {
    // An error occured
    return data;
  } else {
    // Parse the result
    return parseSync(data.toString());
  }
}
/**
 * Turn an object into an envfile synchronously
 * @param {object} obj
 * @returns {string}
 */


function stringifySync(obj) {
  // Prepare
  var result = ''; // Stringify

  eachr(obj, function (value, key) {
    if (key) {
      var line = "".concat(key, "=").concat(String(value));
      result += line + '\n';
    }
  }); // Return

  return result;
}
/**
 * Turn an object into envfile string
 * @param {object} obj
 * @param {StringErrback} next
 * @returns {void}
 */


function stringify(obj, next) {
  // Call the synchronous method asynchronously and avoid zalgo by wrapping in nextTick
  process.nextTick(function () {
    ambi(stringifySync, obj, next);
  });
}

module.exports = {
  parseFile: parseFile,
  parseFileSync: parseFileSync,
  parse: parse,
  parseSync: parseSync,
  stringify: stringify,
  stringifySync: stringifySync
};