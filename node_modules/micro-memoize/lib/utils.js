"use strict";

exports.__esModule = true;
exports.createSetPromiseHandler = exports.orderByLru = exports.onCacheOperation = exports.isSameValueZero = exports.createGetKeyIndex = exports.createAreKeysEqual = exports.cloneArray = exports.assign = void 0;
// types
var hasOwnProperty = Object.prototype.hasOwnProperty;
/**
 * @function assign
 *
 * @description
 * merge the sources into the target, as you would with Object.assign()
 *
 * @param {Object} target object to merge into
 * @param  {...Array<Object>} sources the sources to merge into the target
 * @returns {Object} the merged object
 */

var assign = function assign(target) {
  var source;

  for (var index = 0; index < (arguments.length <= 1 ? 0 : arguments.length - 1); index++) {
    source = index + 1 < 1 || arguments.length <= index + 1 ? undefined : arguments[index + 1];

    if (source && typeof source === 'object') {
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
  }

  return target;
};
/**
 * @function cloneArray
 *
 * @description
 * clone the array-like object and return the new array
 *
 * @param {Array<any>|Arguments} arrayLike the array-like object to clone
 * @returns {Array<any>} the clone of the array
 */


exports.assign = assign;

var cloneArray = function cloneArray(arrayLike) {
  var length = arrayLike.length;

  if (!length) {
    return [];
  }

  if (length === 1) {
    return [arrayLike[0]];
  }

  if (length === 2) {
    return [arrayLike[0], arrayLike[1]];
  }

  if (length === 3) {
    return [arrayLike[0], arrayLike[1], arrayLike[2]];
  }

  var array = new Array(length);

  for (var index = 0; index < length; index++) {
    array[index] = arrayLike[index];
  }

  return array;
};

exports.cloneArray = cloneArray;

var createAreKeysEqual = function createAreKeysEqual(isEqual
/**
 * @function areKeysEqual
 *
 * @description
 * are the keys shallowly equal to one another
 *
 * @param {Array<any>} keys1 the keys array to test against
 * @param {Array<any>} keys2 the keys array to test
 * @returns {boolean} are the keys shallowly equal
 */
) {
  return function (keys1, keys2) {
    if (keys1.length !== keys2.length) {
      return false;
    }

    for (var index = 0, length = keys1.length; index < length; index++) {
      if (!isEqual(keys1[index], keys2[index])) {
        return false;
      }
    }

    return true;
  };
};

exports.createAreKeysEqual = createAreKeysEqual;

var createGetKeyIndex = function createGetKeyIndex(isEqual, isMatchingKey) {
  var areKeysEqual = typeof isMatchingKey === 'function' ? isMatchingKey : createAreKeysEqual(isEqual);
  /**
   * @function getKeyIndex
   *
   * @description
   * get the index of the matching key
   *
   * @param {Array<Array<any>>} allKeys the list of all available keys
   * @param {Array<any>} keysToMatch the key to try to match
   *
   * @returns {number} the index of the matching key value, or -1
   */

  return function (allKeys, keysToMatch) {
    for (var index = 0; index < allKeys.length; index++) {
      if (areKeysEqual(allKeys[index], keysToMatch)) {
        return index;
      }
    }

    return -1;
  };
};
/**
 * @function isSameValueZero
 *
 * @description
 * are the objects equal based on SameValueZero
 *
 * @param {any} object1 the first object to compare
 * @param {any} object2 the second object to compare
 * @returns {boolean} are the two objects equal
 */


exports.createGetKeyIndex = createGetKeyIndex;

var isSameValueZero = function isSameValueZero(object1, object2) {
  return object1 === object2 || object1 !== object1 && object2 !== object2;
};

exports.isSameValueZero = isSameValueZero;

var onCacheOperation = function onCacheOperation(cacheIgnored, optionsIgnored, memoizedIgnored) {};
/**
 * @function orderByLru
 *
 * @description
 * order the array based on a Least-Recently-Used basis
 *
 * @param {Array<any>} array the array to order
 * @param {any} value the value to assign at the beginning of the array
 * @param {number} startingIndex the index of the item to move to the front
 */


exports.onCacheOperation = onCacheOperation;

var orderByLru = function orderByLru(array, value, startingIndex) {
  var index = startingIndex;

  while (index--) {
    array[index + 1] = array[index];
  }

  array[0] = value;
};
/**
 * @function createSetPromiseHandler
 *
 * @description
 * update the promise method to auto-remove from cache if rejected, and if resolved then fire cache hit / changed
 *
 * @param {Options} options the options for the memoized function
 * @param {function(Cache, function): function} memoized the memoized function
 */


exports.orderByLru = orderByLru;

var createSetPromiseHandler = function createSetPromiseHandler(options) {
  var getKeyIndex = createGetKeyIndex(options.isEqual, options.isMatchingKey);
  return function (cache, memoized) {
    var key = cache.keys[0];
    cache.values[0] = cache.values[0].then(function (value) {
      options.onCacheHit(cache, options, memoized);
      options.onCacheChange(cache, options, memoized);
      return value;
    }).catch(function (error) {
      var keyIndex = getKeyIndex(cache.keys, key);

      if (~keyIndex) {
        cache.keys.splice(keyIndex, 1);
        cache.values.splice(keyIndex, 1);
      }

      throw error;
    });
  };
};

exports.createSetPromiseHandler = createSetPromiseHandler;