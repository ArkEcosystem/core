function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

// types
// utils
import { assign, cloneArray, createGetKeyIndex, createSetPromiseHandler, isSameValueZero, onCacheOperation, orderByLru } from './utils';
/**
 * @function memoize
 *
 * @description
 * get the memoized version of the method passed
 *
 * @param {function} fn the method to memoize
 * @param {Object} [options={}] the options to build the memoizer with
 * @param {boolean} [options.isEqual=isSameValueZero] the method to compare equality of keys with
 * @param {number} [options.maxSize=1] the number of items to store in cache
 * @returns {function} the memoized method
 */

export default function memoize(fn, options) {
  // if it is a memoized method, don't re-memoize it
  if (fn.isMemoized) {
    return fn;
  }

  var _ref = options || {},
      _ref$isEqual = _ref.isEqual,
      isEqual = _ref$isEqual === void 0 ? isSameValueZero : _ref$isEqual,
      isMatchingKey = _ref.isMatchingKey,
      _ref$isPromise = _ref.isPromise,
      isPromise = _ref$isPromise === void 0 ? false : _ref$isPromise,
      _ref$maxSize = _ref.maxSize,
      maxSize = _ref$maxSize === void 0 ? 1 : _ref$maxSize,
      _ref$onCacheAdd = _ref.onCacheAdd,
      onCacheAdd = _ref$onCacheAdd === void 0 ? onCacheOperation : _ref$onCacheAdd,
      _ref$onCacheChange = _ref.onCacheChange,
      onCacheChange = _ref$onCacheChange === void 0 ? onCacheOperation : _ref$onCacheChange,
      _ref$onCacheHit = _ref.onCacheHit,
      onCacheHit = _ref$onCacheHit === void 0 ? onCacheOperation : _ref$onCacheHit,
      transformKey = _ref.transformKey,
      extraOptions = _objectWithoutPropertiesLoose(_ref, ["isEqual", "isMatchingKey", "isPromise", "maxSize", "onCacheAdd", "onCacheChange", "onCacheHit", "transformKey"]);

  var normalizedOptions = assign({}, extraOptions, {
    isEqual: isEqual,
    isMatchingKey: isMatchingKey,
    isPromise: isPromise,
    maxSize: maxSize,
    onCacheAdd: onCacheAdd,
    onCacheChange: onCacheChange,
    onCacheHit: onCacheHit,
    transformKey: transformKey
  });
  var getKeyIndex = createGetKeyIndex(isEqual, isMatchingKey);
  var setPromiseHandler = createSetPromiseHandler(normalizedOptions);
  var shouldCloneArguments = !!(transformKey || isMatchingKey);
  var cache = {
    keys: [],

    get size() {
      return cache.keys.length;
    },

    values: []
  };
  var keys = cache.keys,
      values = cache.values;
  /**
   * @function memoized
   *
   * @description
   * the memoized version of the method passed
   *
   * @param {...Array<any>} key the arguments passed, which create a unique cache key
   * @returns {any} the value of the method called with the arguments
   */

  function memoized() {
    var args = arguments;
    var normalizedArgs = shouldCloneArguments ? cloneArray(args) : args;
    var key = transformKey ? transformKey(normalizedArgs) : normalizedArgs;
    var keyIndex = getKeyIndex(keys, key);

    if (~keyIndex) {
      onCacheHit(cache, normalizedOptions, memoized);

      if (keyIndex) {
        orderByLru(keys, keys[keyIndex], keyIndex);
        orderByLru(values, values[keyIndex], keyIndex);
        onCacheChange(cache, normalizedOptions, memoized);
      }
    } else {
      if (keys.length >= maxSize) {
        keys.pop();
        values.pop();
      }

      var newKey = shouldCloneArguments ? key : cloneArray(normalizedArgs);
      var newValue = fn.apply(this, args);
      orderByLru(keys, newKey, keys.length);
      orderByLru(values, newValue, values.length);

      if (isPromise) {
        setPromiseHandler(cache, memoized);
      }

      onCacheAdd(cache, normalizedOptions, memoized);
      onCacheChange(cache, normalizedOptions, memoized);
    }

    return values[0];
  }

  Object.defineProperties(memoized, {
    cache: {
      configurable: true,
      get: function get() {
        return cache;
      }
    },
    cacheSnapshot: {
      configurable: true,
      get: function get() {
        return {
          keys: cloneArray(cache.keys),
          size: cache.size,
          values: cloneArray(cache.values)
        };
      }
    },
    isMemoized: {
      configurable: true,
      get: function get() {
        return true;
      }
    },
    options: {
      configurable: true,
      get: function get() {
        return normalizedOptions;
      }
    }
  });
  return memoized;
}