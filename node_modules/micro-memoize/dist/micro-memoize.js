(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.memoize = {})));
}(this, (function (exports) { 'use strict';

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  // types
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  /**
   * @function assign
   *
   * @description
   * merge the sources into the target, as you would with Object.assign()
   *
   * @param {Object} target object to merge into
   * @param  {...Array<Object>} sources the sources to merge into the target
   * @returns {Object} the merged object
   */

  var assign = function assign(target) {
    var source;

    for (var index = 0; index < (arguments.length <= 1 ? 0 : arguments.length - 1); index++) {
      source = index + 1 < 1 || arguments.length <= index + 1 ? undefined : arguments[index + 1];

      if (source && typeof source === 'object') {
        for (var key in source) {
          if (hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
    }

    return target;
  };
  /**
   * @function cloneArray
   *
   * @description
   * clone the array-like object and return the new array
   *
   * @param {Array<any>|Arguments} arrayLike the array-like object to clone
   * @returns {Array<any>} the clone of the array
   */

  var cloneArray = function cloneArray(arrayLike) {
    var length = arrayLike.length;

    if (!length) {
      return [];
    }

    if (length === 1) {
      return [arrayLike[0]];
    }

    if (length === 2) {
      return [arrayLike[0], arrayLike[1]];
    }

    if (length === 3) {
      return [arrayLike[0], arrayLike[1], arrayLike[2]];
    }

    var array = new Array(length);

    for (var index = 0; index < length; index++) {
      array[index] = arrayLike[index];
    }

    return array;
  };
  var createAreKeysEqual = function createAreKeysEqual(isEqual
  /**
   * @function areKeysEqual
   *
   * @description
   * are the keys shallowly equal to one another
   *
   * @param {Array<any>} keys1 the keys array to test against
   * @param {Array<any>} keys2 the keys array to test
   * @returns {boolean} are the keys shallowly equal
   */
  ) {
    return function (keys1, keys2) {
      if (keys1.length !== keys2.length) {
        return false;
      }

      for (var index = 0, length = keys1.length; index < length; index++) {
        if (!isEqual(keys1[index], keys2[index])) {
          return false;
        }
      }

      return true;
    };
  };
  var createGetKeyIndex = function createGetKeyIndex(isEqual, isMatchingKey) {
    var areKeysEqual = typeof isMatchingKey === 'function' ? isMatchingKey : createAreKeysEqual(isEqual);
    /**
     * @function getKeyIndex
     *
     * @description
     * get the index of the matching key
     *
     * @param {Array<Array<any>>} allKeys the list of all available keys
     * @param {Array<any>} keysToMatch the key to try to match
     *
     * @returns {number} the index of the matching key value, or -1
     */

    return function (allKeys, keysToMatch) {
      for (var index = 0; index < allKeys.length; index++) {
        if (areKeysEqual(allKeys[index], keysToMatch)) {
          return index;
        }
      }

      return -1;
    };
  };
  /**
   * @function isSameValueZero
   *
   * @description
   * are the objects equal based on SameValueZero
   *
   * @param {any} object1 the first object to compare
   * @param {any} object2 the second object to compare
   * @returns {boolean} are the two objects equal
   */

  var isSameValueZero = function isSameValueZero(object1, object2) {
    return object1 === object2 || object1 !== object1 && object2 !== object2;
  };
  var onCacheOperation = function onCacheOperation(cacheIgnored, optionsIgnored, memoizedIgnored) {};
  /**
   * @function orderByLru
   *
   * @description
   * order the array based on a Least-Recently-Used basis
   *
   * @param {Array<any>} array the array to order
   * @param {any} value the value to assign at the beginning of the array
   * @param {number} startingIndex the index of the item to move to the front
   */

  var orderByLru = function orderByLru(array, value, startingIndex) {
    var index = startingIndex;

    while (index--) {
      array[index + 1] = array[index];
    }

    array[0] = value;
  };
  /**
   * @function createSetPromiseHandler
   *
   * @description
   * update the promise method to auto-remove from cache if rejected, and if resolved then fire cache hit / changed
   *
   * @param {Options} options the options for the memoized function
   * @param {function(Cache, function): function} memoized the memoized function
   */

  var createSetPromiseHandler = function createSetPromiseHandler(options) {
    var getKeyIndex = createGetKeyIndex(options.isEqual, options.isMatchingKey);
    return function (cache, memoized) {
      var key = cache.keys[0];
      cache.values[0] = cache.values[0].then(function (value) {
        options.onCacheHit(cache, options, memoized);
        options.onCacheChange(cache, options, memoized);
        return value;
      }).catch(function (error) {
        var keyIndex = getKeyIndex(cache.keys, key);

        if (~keyIndex) {
          cache.keys.splice(keyIndex, 1);
          cache.values.splice(keyIndex, 1);
        }

        throw error;
      });
    };
  };

  /**
   * @function memoize
   *
   * @description
   * get the memoized version of the method passed
   *
   * @param {function} fn the method to memoize
   * @param {Object} [options={}] the options to build the memoizer with
   * @param {boolean} [options.isEqual=isSameValueZero] the method to compare equality of keys with
   * @param {number} [options.maxSize=1] the number of items to store in cache
   * @returns {function} the memoized method
   */

  function memoize(fn, options) {
    // if it is a memoized method, don't re-memoize it
    if (fn.isMemoized) {
      return fn;
    }

    var _ref = options || {},
        _ref$isEqual = _ref.isEqual,
        isEqual = _ref$isEqual === void 0 ? isSameValueZero : _ref$isEqual,
        isMatchingKey = _ref.isMatchingKey,
        _ref$isPromise = _ref.isPromise,
        isPromise = _ref$isPromise === void 0 ? false : _ref$isPromise,
        _ref$maxSize = _ref.maxSize,
        maxSize = _ref$maxSize === void 0 ? 1 : _ref$maxSize,
        _ref$onCacheAdd = _ref.onCacheAdd,
        onCacheAdd = _ref$onCacheAdd === void 0 ? onCacheOperation : _ref$onCacheAdd,
        _ref$onCacheChange = _ref.onCacheChange,
        onCacheChange = _ref$onCacheChange === void 0 ? onCacheOperation : _ref$onCacheChange,
        _ref$onCacheHit = _ref.onCacheHit,
        onCacheHit = _ref$onCacheHit === void 0 ? onCacheOperation : _ref$onCacheHit,
        transformKey = _ref.transformKey,
        extraOptions = _objectWithoutPropertiesLoose(_ref, ["isEqual", "isMatchingKey", "isPromise", "maxSize", "onCacheAdd", "onCacheChange", "onCacheHit", "transformKey"]);

    var normalizedOptions = assign({}, extraOptions, {
      isEqual: isEqual,
      isMatchingKey: isMatchingKey,
      isPromise: isPromise,
      maxSize: maxSize,
      onCacheAdd: onCacheAdd,
      onCacheChange: onCacheChange,
      onCacheHit: onCacheHit,
      transformKey: transformKey
    });
    var getKeyIndex = createGetKeyIndex(isEqual, isMatchingKey);
    var setPromiseHandler = createSetPromiseHandler(normalizedOptions);
    var shouldCloneArguments = !!(transformKey || isMatchingKey);
    var cache = {
      keys: [],

      get size() {
        return cache.keys.length;
      },

      values: []
    };
    var keys = cache.keys,
        values = cache.values;
    /**
     * @function memoized
     *
     * @description
     * the memoized version of the method passed
     *
     * @param {...Array<any>} key the arguments passed, which create a unique cache key
     * @returns {any} the value of the method called with the arguments
     */

    function memoized() {
      var args = arguments;
      var normalizedArgs = shouldCloneArguments ? cloneArray(args) : args;
      var key = transformKey ? transformKey(normalizedArgs) : normalizedArgs;
      var keyIndex = getKeyIndex(keys, key);

      if (~keyIndex) {
        onCacheHit(cache, normalizedOptions, memoized);

        if (keyIndex) {
          orderByLru(keys, keys[keyIndex], keyIndex);
          orderByLru(values, values[keyIndex], keyIndex);
          onCacheChange(cache, normalizedOptions, memoized);
        }
      } else {
        if (keys.length >= maxSize) {
          keys.pop();
          values.pop();
        }

        var newKey = shouldCloneArguments ? key : cloneArray(normalizedArgs);
        var newValue = fn.apply(this, args);
        orderByLru(keys, newKey, keys.length);
        orderByLru(values, newValue, values.length);

        if (isPromise) {
          setPromiseHandler(cache, memoized);
        }

        onCacheAdd(cache, normalizedOptions, memoized);
        onCacheChange(cache, normalizedOptions, memoized);
      }

      return values[0];
    }

    Object.defineProperties(memoized, {
      cache: {
        configurable: true,
        get: function get() {
          return cache;
        }
      },
      cacheSnapshot: {
        configurable: true,
        get: function get() {
          return {
            keys: cloneArray(cache.keys),
            size: cache.size,
            values: cloneArray(cache.values)
          };
        }
      },
      isMemoized: {
        configurable: true,
        get: function get() {
          return true;
        }
      },
      options: {
        configurable: true,
        get: function get() {
          return normalizedOptions;
        }
      }
    });
    return memoized;
  }

  exports.default = memoize;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=micro-memoize.js.map
