"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require("lodash");
var ComposerParser = /** @class */ (function () {
    function ComposerParser() {
    }
    ComposerParser.getVersion = function (depObj) {
        // check for `version` property. may not exist
        var versionFound = _.get(depObj, 'version', '');
        // even if found, may be an alias, so check
        var availableAliases = _.get(depObj, "extra['branch-alias']", []);
        // if the version matches the alias (either as is, or without 'dev-'), use the aliases version.
        // otherwise, use the version as is, and if not, the first found alias
        return _.get(availableAliases, versionFound) ||
            _.get(_.invert(availableAliases), versionFound.replace('dev-', '')) &&
                versionFound.replace('dev-', '') ||
            versionFound ||
            _.findKey(_.invert(availableAliases), '0'); // first available alias
    };
    ComposerParser.buildDependencies = function (composerJsonObj, composerLockObjPackages, depObj, depRecursiveArray, systemVersions, packageReferencesCount) {
        if (packageReferencesCount === void 0) { packageReferencesCount = {}; }
        var requires = _.get(depObj, 'require', undefined);
        if (!requires) {
            return {};
        }
        var result = {};
        var _loop_1 = function (depName) {
            var depFoundVersion = void 0;
            // lets find if this dependency has an object in composer.lock
            var applicationData = composerLockObjPackages.find(function (composerPackage) {
                return composerPackage.name === depName;
            });
            if (applicationData) {
                depFoundVersion = this_1.getVersion(applicationData);
            }
            else {
                // here we use the version from the requires - not a locked version
                var composerJsonRequires = _.get(composerJsonObj, 'require');
                depFoundVersion = _.get(systemVersions, depName) ||
                    _.get(composerJsonRequires, depName) ||
                    _.get(requires, depName);
            }
            depFoundVersion = depFoundVersion.replace(/^v(\d)/, '$1');
            result[depName] = {
                name: depName,
                version: depFoundVersion,
                dependencies: {},
            };
            var refCount = packageReferencesCount[depName] || 0;
            packageReferencesCount[depName] = ++refCount;
            if (!this_1.alreadyAddedDep(depRecursiveArray, depName) && refCount < this_1.MAX_PACKAGE_REPEATS) {
                depRecursiveArray.push(depName);
                result[depName].dependencies =
                    ComposerParser.buildDependencies(composerJsonObj, composerLockObjPackages, _.find(composerLockObjPackages, { name: depName }), depRecursiveArray, systemVersions, packageReferencesCount);
                depRecursiveArray.pop();
            }
        };
        var this_1 = this;
        for (var _i = 0, _a = Object.keys(requires); _i < _a.length; _i++) {
            var depName = _a[_i];
            _loop_1(depName);
        }
        return result;
    };
    ComposerParser.alreadyAddedDep = function (arrayOfFroms, packageName) {
        return arrayOfFroms.indexOf(packageName) > -1;
    };
    // After this threshold, a package node in the dep tree won't have expanded dependencies.
    // This is a cheap protection against combinatorial explosion when there's N packages
    // that depend on each other (producing N! branches of the dep tree).
    // The value of 150 was chosen as a lowest one that doesn't break existing tests.
    // Switching to dependency graph would render this trick obsolete.
    ComposerParser.MAX_PACKAGE_REPEATS = 150;
    return ComposerParser;
}());
exports.ComposerParser = ComposerParser;
//# sourceMappingURL=composer-parser.js.map