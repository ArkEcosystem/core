"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var fs = require("fs");
var path = require("path");
var yaml = require("js-yaml");
var dep_graph_1 = require("@snyk/dep-graph");
var utils_1 = require("./utils");
require("core-js/features/object/entries");
var LockfileParser = /** @class */ (function () {
    function LockfileParser(hash, rootPkgInfo) {
        this.rootPkgInfo = undefined;
        this.rootPkgInfo = rootPkgInfo;
        this.internalData = hash;
    }
    LockfileParser.readFile = function (lockfilePath) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var rootName;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                rootName = path.basename(path.dirname(path.resolve(lockfilePath)));
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        fs.readFile(lockfilePath, { encoding: 'utf8' }, function (err, fileContents) {
                            if (err) {
                                reject(err);
                            }
                            try {
                                var parser = _this.readContents(fileContents, {
                                    name: rootName,
                                    version: '0.0.0',
                                });
                                resolve(parser);
                            }
                            catch (err) {
                                reject(err);
                            }
                        });
                    })];
            });
        });
    };
    LockfileParser.readFileSync = function (lockfilePath) {
        var fileContents = fs.readFileSync(lockfilePath, 'utf8');
        var rootName = path.basename(path.dirname(path.resolve(lockfilePath)));
        return this.readContents(fileContents, {
            name: rootName,
            version: '0.0.0',
        });
    };
    LockfileParser.readContents = function (contents, rootPkgInfo) {
        return new LockfileParser(yaml.safeLoad(contents), rootPkgInfo);
    };
    LockfileParser.prototype.toDepGraph = function () {
        var _this = this;
        var builder = new dep_graph_1.DepGraphBuilder(this.pkgManager, this.rootPkgInfo);
        var allDeps = {};
        // Add all package nodes first, but collect dependencies
        this.internalData.PODS.forEach(function (elem) {
            var pkgInfo;
            var pkgDeps;
            if (typeof elem === 'string') {
                // When there are NO dependencies. This equals in yaml e.g.
                //    - Expecta (1.0.5)
                pkgInfo = utils_1.pkgInfoFromSpecificationString(elem);
                pkgDeps = [];
            }
            else {
                // When there are dependencies. This equals in yaml e.g.
                //    - React/Core (0.59.2):
                //      - yoga (= 0.59.2.React)
                var objKey = Object.keys(elem)[0];
                pkgInfo = utils_1.pkgInfoFromSpecificationString(objKey);
                pkgDeps = elem[objKey].map(utils_1.pkgInfoFromDependencyString);
            }
            var nodeId = _this.nodeIdForPkgInfo(pkgInfo);
            builder.addPkgNode(pkgInfo, nodeId, {
                labels: _this.nodeInfoLabelsForPod(pkgInfo.name),
            });
            allDeps[nodeId] = pkgDeps;
        });
        // Connect explicitly in the manifest (`Podfile`)
        // declared dependencies to the root node.
        this.internalData.DEPENDENCIES.map(utils_1.pkgInfoFromDependencyString).forEach(function (pkgInfo) {
            builder.connectDep(builder.rootNodeId, _this.nodeIdForPkgInfo(pkgInfo));
        });
        // Now we can start to connect dependencies
        Object.entries(allDeps).forEach(function (_a) {
            var nodeId = _a[0], pkgDeps = _a[1];
            return pkgDeps.forEach(function (pkgInfo) {
                var depNodeId = _this.nodeIdForPkgInfo(pkgInfo);
                if (!allDeps[depNodeId]) {
                    // The pod is not a direct dependency of any targets of the integration,
                    // which can happen for platform-specific transitives, when their platform
                    // is not used in any target. (e.g. PromiseKit/UIKit is iOS-specific and is
                    // a transitive of PromiseKit, but won't be included for a macOS project.)
                    return;
                }
                builder.connectDep(nodeId, depNodeId);
            });
        });
        return builder.build();
    };
    /// CocoaPods guarantees that every pod is only present in one version,
    /// so we can use just the pod name as node ID.
    LockfileParser.prototype.nodeIdForPkgInfo = function (pkgInfo) {
        return pkgInfo.name;
    };
    /// Gathers relevant info from the lockfile and transform
    /// them into the expected labels data structure.
    LockfileParser.prototype.nodeInfoLabelsForPod = function (podName) {
        var nodeInfoLabels = {
            checksum: this.checksumForPod(podName),
        };
        var repository = this.repositoryForPod(podName);
        if (repository) {
            nodeInfoLabels = tslib_1.__assign(tslib_1.__assign({}, nodeInfoLabels), { repository: repository });
        }
        var externalSourceInfo = this.externalSourceInfoForPod(podName);
        if (externalSourceInfo) {
            nodeInfoLabels = tslib_1.__assign(tslib_1.__assign({}, nodeInfoLabels), { externalSourcePodspec: externalSourceInfo[':podspec'], externalSourcePath: externalSourceInfo[':path'], externalSourceGit: externalSourceInfo[':git'], externalSourceTag: externalSourceInfo[':tag'], externalSourceCommit: externalSourceInfo[':commit'], externalSourceBranch: externalSourceInfo[':branch'] });
        }
        var checkoutOptions = this.checkoutOptionsForPod(podName);
        if (checkoutOptions) {
            nodeInfoLabels = tslib_1.__assign(tslib_1.__assign({}, nodeInfoLabels), { checkoutOptionsPodspec: checkoutOptions[':podspec'], checkoutOptionsPath: checkoutOptions[':path'], checkoutOptionsGit: checkoutOptions[':git'], checkoutOptionsTag: checkoutOptions[':tag'], checkoutOptionsCommit: checkoutOptions[':commit'], checkoutOptionsBranch: checkoutOptions[':branch'] });
        }
        // Sanitize labels by removing null fields
        // (as they don't survive a serialization/parse cycle and break tests)
        Object.entries(nodeInfoLabels).forEach(function (_a) {
            var key = _a[0], value = _a[1];
            if (value === null || value === undefined) {
                delete nodeInfoLabels[key];
            }
        });
        return nodeInfoLabels;
    };
    /// The checksum of the pod.
    LockfileParser.prototype.checksumForPod = function (podName) {
        var rootName = utils_1.rootSpecName(podName);
        return this.internalData['SPEC CHECKSUMS'][rootName];
    };
    /// This can be either an URL or the local repository name.
    LockfileParser.prototype.repositoryForPod = function (podName) {
        // Older Podfile.lock might not have this section yet.
        var specRepos = this.internalData['SPEC REPOS'];
        if (!specRepos) {
            return undefined;
        }
        var rootName = utils_1.rootSpecName(podName);
        var specRepoEntry = Object.entries(specRepos).find(function (_a) {
            var deps = _a[1];
            return deps.includes(rootName);
        });
        if (specRepoEntry) {
            return specRepoEntry[0];
        }
        return undefined;
    };
    /// Extracts the external source info for a given pod, if there is any.
    LockfileParser.prototype.externalSourceInfoForPod = function (podName) {
        // Older Podfile.lock might not have this section yet.
        var externalSources = this.internalData['EXTERNAL SOURCES'];
        if (!externalSources) {
            return undefined;
        }
        var externalSourceEntry = externalSources[utils_1.rootSpecName(podName)];
        if (externalSourceEntry) {
            return externalSourceEntry;
        }
        return undefined;
    };
    /// Extracts the checkout options for a given pod, if there is any.
    LockfileParser.prototype.checkoutOptionsForPod = function (podName) {
        // Older Podfile.lock might not have this section yet.
        var checkoutOptions = this.internalData['CHECKOUT OPTIONS'];
        if (!checkoutOptions) {
            return undefined;
        }
        var checkoutOptionsEntry = checkoutOptions[utils_1.rootSpecName(podName)];
        if (checkoutOptionsEntry) {
            return checkoutOptionsEntry;
        }
        return undefined;
    };
    Object.defineProperty(LockfileParser.prototype, "repositories", {
        get: function () {
            // Older Podfile.lock might not have this section yet.
            var specRepos = this.internalData['SPEC REPOS'];
            if (!specRepos) {
                return [];
            }
            return Object.keys(specRepos).map(function (nameOrUrl) {
                return { alias: nameOrUrl };
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LockfileParser.prototype, "pkgManager", {
        get: function () {
            return {
                name: 'CocoaPods',
                version: this.cocoapodsVersion,
                repositories: this.repositories,
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LockfileParser.prototype, "cocoapodsVersion", {
        /// The CocoaPods version encoded in the lockfile which was used to
        /// create this resolution.
        get: function () {
            return this.internalData.COCOAPODS || 'unknown';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LockfileParser.prototype, "podfileChecksum", {
        /// The checksum of the Podfile, which was used when resolving this integration.
        /// - Note: this was not tracked by earlier versions of CocoaPods.
        get: function () {
            return this.internalData['PODFILE CHECKSUM'];
        },
        enumerable: true,
        configurable: true
    });
    return LockfileParser;
}());
exports.default = LockfileParser;
//# sourceMappingURL=lockfile-parser.js.map