"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var _ = require("lodash");
var semver = require("semver");
var graphlib = require("graphlib");
var errors_1 = require("./errors");
var validate_graph_1 = require("./validate-graph");
var dep_graph_1 = require("./dep-graph");
exports.SUPPORTED_SCHEMA_RANGE = '^1.0.0';
function createFromJSON(depGraphData) {
    validateDepGraphData(depGraphData);
    var graph = new graphlib.Graph({
        directed: true,
        multigraph: false,
        compound: false,
    });
    var pkgs = {};
    var pkgNodes = {};
    for (var _i = 0, _a = depGraphData.pkgs; _i < _a.length; _i++) {
        var _b = _a[_i], id = _b.id, info = _b.info;
        // TODO: avoid this, instead just use `info` as is
        pkgs[id] = info.version ? info : tslib_1.__assign(tslib_1.__assign({}, info), { version: null });
    }
    for (var _c = 0, _d = depGraphData.graph.nodes; _c < _d.length; _c++) {
        var node = _d[_c];
        var pkgId = node.pkgId;
        if (!pkgNodes[pkgId]) {
            pkgNodes[pkgId] = new Set();
        }
        pkgNodes[pkgId].add(node.nodeId);
        graph.setNode(node.nodeId, { pkgId: pkgId, info: node.info });
    }
    for (var _e = 0, _f = depGraphData.graph.nodes; _e < _f.length; _e++) {
        var node = _f[_e];
        for (var _g = 0, _h = node.deps; _g < _h.length; _g++) {
            var depNodeId = _h[_g];
            graph.setEdge(node.nodeId, depNodeId.nodeId);
        }
    }
    validate_graph_1.validateGraph(graph, depGraphData.graph.rootNodeId, pkgs, pkgNodes);
    return new dep_graph_1.DepGraphImpl(graph, depGraphData.graph.rootNodeId, pkgs, pkgNodes, depGraphData.pkgManager);
}
exports.createFromJSON = createFromJSON;
function assert(condition, msg) {
    if (!condition) {
        throw new errors_1.ValidationError(msg);
    }
}
function validateDepGraphData(depGraphData) {
    assert(!!semver.valid(depGraphData.schemaVersion)
        && semver.satisfies(depGraphData.schemaVersion, exports.SUPPORTED_SCHEMA_RANGE), "dep-graph schemaVersion not in \"" + exports.SUPPORTED_SCHEMA_RANGE + "\"");
    assert(depGraphData.pkgManager && !!depGraphData.pkgManager.name, '.pkgManager.name is missing');
    var pkgsMap = depGraphData.pkgs.reduce(function (acc, cur) {
        assert(!(cur.id in acc), 'more than one pkg with same id');
        assert(!!cur.info, '.pkgs item missing .info');
        acc[cur.id] = cur.info;
        return acc;
    }, {});
    var nodesMap = depGraphData.graph.nodes.reduce(function (acc, cur) {
        assert(!(cur.nodeId in acc), 'more than on node with same id');
        acc[cur.nodeId] = cur;
        return acc;
    }, {});
    var rootNodeId = depGraphData.graph.rootNodeId;
    var rootNode = nodesMap[rootNodeId];
    assert(rootNodeId in nodesMap, "." + rootNodeId + " root graph node is missing");
    var rootPkgId = rootNode.pkgId;
    assert(rootPkgId in pkgsMap, "." + rootPkgId + " root pkg missing");
    assert(nodesMap[rootNodeId].pkgId === rootPkgId, "the root node .pkgId should be \"" + rootPkgId + "\"");
    var pkgIds = _.keys(pkgsMap);
    // NOTE: this name@version check is very strict,
    // we can relax it later, it just makes things easier now
    assert(pkgIds
        .filter(function (pkgId) { return (pkgId !== dep_graph_1.DepGraphImpl.getPkgId(pkgsMap[pkgId])); })
        .length === 0, 'pkgs ids should be name@version');
    assert(_.values(nodesMap)
        .filter(function (node) { return !(node.pkgId in pkgsMap); })
        .length === 0, 'some instance nodes belong to non-existing pkgIds');
    assert(_.values(pkgsMap)
        .filter(function (pkg) { return !pkg.name; })
        .length === 0, 'some .pkgs elements have no .name field');
}
//# sourceMappingURL=create-from-json.js.map