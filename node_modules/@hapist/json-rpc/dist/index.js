"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const boom_1 = __importDefault(require("@hapi/boom"));
const media_type_1 = __importDefault(require("media-type"));
const config_1 = require("./config");
const processor_1 = require("./processor");
exports.plugin = {
    once: true,
    pkg: require("../package.json"),
    register: (server, options) => {
        config_1.config.load(options);
        if (config_1.config.hasError()) {
            throw config_1.config.getError();
        }
        server.app.schemas = {};
        for (const method of Object.values(options.methods)) {
            server.app.schemas[method.name] = method.schema;
            delete method.schema;
            server.method(method);
        }
        server.ext("onPreHandler", (request, h) => {
            if (request.headers["content-type"]) {
                const contentMedia = media_type_1.default.fromString(request.headers["content-type"]);
                if (contentMedia.parameters.charset === "UTF-8") {
                    delete contentMedia.parameters.charset;
                }
                const hasInvalidType = contentMedia.type !== "application";
                const hasInvalidSubType = contentMedia.subtype !== "vnd.api";
                const hasInvalidParameters = Object.keys(contentMedia.parameters).length > 0;
                if (hasInvalidType || hasInvalidSubType || hasInvalidParameters) {
                    throw boom_1.default.unsupportedMediaType('Expected content-type header to be "application/vnd.api+json"');
                }
            }
            else if (request.headers.accept) {
                if (request.headers.accept.indexOf("application/vnd.api+json") === -1) {
                    throw boom_1.default.notAcceptable('Expected accept header to be "application/vnd.api+json"');
                }
            }
            return h.continue;
        });
        server.route({
            method: "POST",
            path: "/",
            async handler(request) {
                const processor = new processor_1.Processor(request.server, config_1.config.get("processor") || {});
                return Array.isArray(request.payload)
                    ? processor.collection(request.payload)
                    : processor.resource(request.payload);
            },
        });
    },
};
//# sourceMappingURL=index.js.map