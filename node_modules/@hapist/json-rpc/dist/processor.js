"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const dlv_1 = __importDefault(require("dlv"));
class Processor {
    constructor(server, options) {
        this.server = server;
        this.options = options;
    }
    async resource(payload) {
        const { error } = this.options.validate(payload || {}, this.options.schema);
        if (error) {
            return this.createErrorResponse(payload ? payload.id : null, -32600, new Error(error));
        }
        const { method, params, id } = payload;
        try {
            const targetMethod = dlv_1.default(this.server.methods, method);
            if (!targetMethod) {
                return this.createErrorResponse(id, -32601, new Error("The method does not exist / is not available."));
            }
            const schema = this.server.app.schemas[method];
            if (schema) {
                const { error } = this.options.validate(params, schema);
                if (error) {
                    return this.createErrorResponse(id, -32602, new Error(error));
                }
            }
            const result = await targetMethod(params);
            return result.isBoom
                ? this.createErrorResponse(id, result.output.statusCode, result.output.payload)
                : this.createSuccessResponse(id, result);
        }
        catch (error) {
            return this.createErrorResponse(id, -32603, error);
        }
    }
    async collection(payloads) {
        const results = [];
        for (const payload of payloads) {
            results.push(await this.resource(payload));
        }
        return results;
    }
    createSuccessResponse(id, result) {
        return {
            id,
            jsonrpc: "2.0",
            result,
        };
    }
    createErrorResponse(id, code, error) {
        return {
            error: {
                code,
                data: error.stack,
                message: error.message,
            },
            id,
            jsonrpc: "2.0",
        };
    }
}
exports.Processor = Processor;
//# sourceMappingURL=processor.js.map