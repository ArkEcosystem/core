'use strict'; // Import

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var typeChecker = require('typechecker'); // Handle success case


function onSuccess(value) {
  // Reject if an error was returned
  if (typeChecker.isError(value)) return Promise.reject(value); // Success case, so return the value

  return value;
}
/**
 * Ambidextrously execute the method with the passed arguments.
 * If method.length > args.length, then ambi provides the method with a completion callback as the last expected argument.
 * @param {function} method A method, that can either resolve synchronously, via a promise, or via a callback.
 * @param {*} args
 * @returns {Promise<*>} The determined result.
 */


function ambi(method) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  /*
  Different ways functions can be called:
  ambi(function(a,next){next(null, a)}, a)
  	> method.length > args.length
  	> next will be provided automatically
  ambi(function(a){return a}, a)
  	> method.length = args.length
  	> no argument changes by ambi
  ambi(function(a){return a}, a, b)
  	> method.length < args.length
  	> no argument changes by ambi
  */
  try {
    // Inject a completion callback
    if (method.length > args.length) {
      return new Promise(function (resolve, reject) {
        var xargs = args.slice() // add the difference as undefined values
        .concat(new Array(method.length - args.length - 1)) // add the completion callback
        .concat([function ambiCallback(err) {
          if (err) return reject(err);

          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }

          if (args.length === 1) return resolve(args[0]);
          return resolve(args);
        }]);
        method.apply(void 0, _toConsumableArray(xargs));
      }).then(onSuccess);
    } // Execute without a completion callback
    else {
        return Promise.resolve(method.apply(void 0, args)).then(onSuccess);
      }
  } catch (err) {
    return Promise.reject(err);
  }
} // Export


module.exports = ambi;