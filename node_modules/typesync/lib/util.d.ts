import { IWorkspacesSection, IYarnWorkspacesConfig } from './types';
/**
 * Returns unique items.
 *
 * @param source The source to filter
 */
export declare function uniq<T>(source: Array<T>): Array<T>;
/**
 * Does a `map` and a `filter` in one pass.
 *
 * @param source The source to filter and map
 * @param iteratee The iteratee.
 */
export declare function filterMap<T, R>(source: Array<T>, iteratee: (item: T, index: number) => R | false): Array<R>;
/**
 * Merges a sequence of objects into a single object using `reduce`.
 *
 * @param source An array of objects to merge.
 */
export declare function mergeObjects<T>(source: Array<T>): T;
/**
 * Returns the assumed types package name.
 * @param name Package name
 */
export declare function typed(name: string): string;
/**
 * Returns the assumed code package name based on a types package name.
 * @param name
 */
export declare function untyped(name: string): string;
/**
 * Orders an object.
 * @param source
 */
export declare function orderObject<T>(source: T, comparer?: (a: string, b: string) => number): T;
/**
 * Promisifies the specified function.
 *
 * @param fn
 */
export declare function promisify(fn: Function): (...args: any[]) => Promise<any>;
/**
 * Flattens a 2-dimensional array.
 *
 * @param source
 */
export declare function flatten<T>(source: Array<Array<T>>): Array<T>;
/**
 * Async memoize.
 *
 * @param fn
 */
export declare function memoizeAsync<T, U extends any[], V>(fn: (...args: U) => Promise<V>): (...args: U) => Promise<V>;
/**
 * Ensures that we have a valid workspaces array.
 *
 * @param data
 */
export declare function ensureWorkspacesArray(data?: IWorkspacesSection | IYarnWorkspacesConfig): IWorkspacesSection;
