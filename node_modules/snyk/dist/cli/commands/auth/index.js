"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const Debug = require("debug");
const open = require("opn");
const snyk = require("../../../lib");
const config = require("../../../lib/config");
const is_ci_1 = require("../../../lib/is-ci");
const request = require("../../../lib/request");
const url = require("url");
const uuid = require("uuid");
const spinner = require("../../../lib/spinner");
const token_expired_error_1 = require("../../../lib/errors/token-expired-error");
const misconfigured_auth_in_ci_error_1 = require("../../../lib/errors/misconfigured-auth-in-ci-error");
const authentication_failed_error_1 = require("../../../lib/errors/authentication-failed-error");
const is_authed_1 = require("./is-authed");
const apiUrl = url.parse(config.API);
const authUrl = apiUrl.protocol + '//' + apiUrl.host;
const debug = Debug('snyk-auth');
let attemptsLeft = 0;
function resetAttempts() {
    attemptsLeft = 30;
}
function webAuth(via) {
    return __awaiter(this, void 0, void 0, function* () {
        const token = uuid.v4(); // generate a random key
        const redirects = {
            wizard: '/authenticated',
        };
        let urlStr = authUrl + '/login?token=' + token;
        // validate that via comes from our code, and not from user & CLI
        if (redirects[via]) {
            urlStr += '&redirectUri=' + Buffer.from(redirects[via]).toString('base64');
        }
        const msg = '\nNow redirecting you to our auth page, go ahead and log in,\n' +
            "and once the auth is complete, return to this prompt and you'll\n" +
            "be ready to start using snyk.\n\nIf you can't wait use this url:\n" +
            urlStr +
            '\n';
        // suppress this message in CI
        if (!is_ci_1.isCI()) {
            console.log(msg);
        }
        else {
            return Promise.reject(misconfigured_auth_in_ci_error_1.MisconfiguredAuthInCI());
        }
        const lbl = 'Waiting...';
        try {
            yield spinner(lbl);
            yield setTimeout(() => {
                open(urlStr, { wait: false });
            }, 2000);
            const res = yield testAuthComplete(token);
            return res;
        }
        finally {
            spinner.clear(lbl)();
        }
    });
}
function testAuthComplete(token) {
    return __awaiter(this, void 0, void 0, function* () {
        const payload = {
            body: {
                token,
            },
            url: config.API + '/verify/callback',
            json: true,
            method: 'post',
        };
        return new Promise((resolve, reject) => {
            debug(payload);
            request(payload, (error, res, body) => {
                debug(error, (res || {}).statusCode, body);
                if (error) {
                    return reject(error);
                }
                if (res.statusCode !== 200) {
                    return reject(authentication_failed_error_1.AuthFailedError(body.message, res.statusCode));
                }
                // we have success
                if (body.api) {
                    return resolve({
                        res,
                        body,
                    });
                }
                // we need to wait and poll again in a moment
                setTimeout(() => {
                    attemptsLeft--;
                    if (attemptsLeft > 0) {
                        return resolve(testAuthComplete(token));
                    }
                    reject(token_expired_error_1.TokenExpiredError());
                }, 1000);
            });
        });
    });
}
function auth(apiToken, via) {
    return __awaiter(this, void 0, void 0, function* () {
        let promise;
        resetAttempts();
        if (apiToken) {
            // user is manually setting the API token on the CLI - let's trust them
            promise = is_authed_1.verifyAPI(apiToken);
        }
        else {
            promise = webAuth(via);
        }
        return promise.then((data) => {
            const res = data.res;
            const body = res.body;
            debug(body);
            if (res.statusCode === 200 || res.statusCode === 201) {
                snyk.config.set('api', body.api);
                return ('\nYour account has been authenticated. Snyk is now ready to ' +
                    'be used.\n');
            }
            throw authentication_failed_error_1.AuthFailedError(body.message, res.statusCode);
        });
    });
}
module.exports = auth;
//# sourceMappingURL=index.js.map