#!/usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
require("source-map-support/register");
const Debug = require("debug");
// assert supported node runtime version
const runtime = require("./runtime");
// require analytics as soon as possible to start measuring execution time
const analytics = require("../lib/analytics");
const alerts = require("../lib/alerts");
const sln = require("../lib/sln");
const args_1 = require("./args");
const copy_1 = require("./copy");
const spinner = require("../lib/spinner");
const errors = require("../lib/errors/legacy-errors");
const ansiEscapes = require("ansi-escapes");
const detect_1 = require("../lib/detect");
const updater_1 = require("../lib/updater");
const errors_1 = require("../lib/errors");
const debug = Debug('snyk');
const EXIT_CODES = {
    VULNS_FOUND: 1,
    ERROR: 2,
};
function runCommand(args) {
    return __awaiter(this, void 0, void 0, function* () {
        const result = yield args.method(...args.options._);
        const res = analytics({
            args: args.options._,
            command: args.command,
        });
        if (result && !args.options.quiet) {
            if (args.options.copy) {
                copy_1.copy(result);
                console.log('Result copied to clipboard');
            }
            else {
                console.log(result);
            }
        }
        return res;
    });
}
function handleError(args, error) {
    return __awaiter(this, void 0, void 0, function* () {
        spinner.clearAll();
        let command = 'bad-command';
        let exitCode = EXIT_CODES.ERROR;
        const vulnsFound = error.code === 'VULNS';
        if (vulnsFound) {
            // this isn't a bad command, so we won't record it as such
            command = args.command;
            exitCode = EXIT_CODES.VULNS_FOUND;
        }
        if (args.options.debug && !args.options.json) {
            const output = vulnsFound ? error.message : error.stack;
            console.log(output);
        }
        else if (args.options.json) {
            console.log(error.json || error.stack);
        }
        else {
            if (!args.options.quiet) {
                const result = errors.message(error);
                if (args.options.copy) {
                    copy_1.copy(result);
                    console.log('Result copied to clipboard');
                }
                else {
                    if (`${error.code}`.indexOf('AUTH_') === 0) {
                        // remove the last few lines
                        const erase = ansiEscapes.eraseLines(4);
                        process.stdout.write(erase);
                    }
                    console.log(result);
                }
            }
        }
        const analyticsError = vulnsFound
            ? {
                stack: error.jsonNoVulns,
                code: error.code,
                message: 'Vulnerabilities found',
            }
            : {
                stack: error.stack,
                code: error.code,
                message: error.message,
            };
        if (!vulnsFound && !error.stack) {
            // log errors that are not error objects
            analytics.add('error', JSON.stringify(analyticsError));
            analytics.add('command', args.command);
        }
        else {
            analytics.add('error-message', analyticsError.message);
            // Note that error.stack would also contain the error message
            // (see https://nodejs.org/api/errors.html#errors_error_stack)
            analytics.add('error', analyticsError.stack);
            analytics.add('error-code', error.code);
            analytics.add('command', args.command);
        }
        const res = analytics({
            args: args.options._,
            command,
        });
        return { res, exitCode };
    });
}
function checkRuntime() {
    if (!runtime.isSupported(process.versions.node)) {
        console.error(`${process.versions.node} is an unsupported nodejs ` +
            `runtime! Supported runtime range is '${runtime.supportedRange}'`);
        console.error('Please upgrade your nodejs runtime version and try again.');
        process.exit(EXIT_CODES.ERROR);
    }
}
// Check if user specify package file name as part of path
// and throw error if so.
function checkPaths(args) {
    for (const path of args.options._) {
        if (typeof path === 'string' && detect_1.isPathToPackageFile(path)) {
            throw errors_1.MissingTargetFileError(path);
        }
    }
}
function main() {
    return __awaiter(this, void 0, void 0, function* () {
        updater_1.updateCheck();
        checkRuntime();
        const args = args_1.args(process.argv);
        let res;
        let failed = false;
        let exitCode = EXIT_CODES.ERROR;
        try {
            if (args.options.file &&
                typeof args.options.file === 'string' &&
                args.options.file.match(/\.sln$/)) {
                sln.updateArgs(args);
            }
            else if (typeof args.options.file === 'boolean') {
                throw new errors_1.FileFlagBadInputError();
            }
            checkPaths(args);
            res = yield runCommand(args);
        }
        catch (error) {
            failed = true;
            const response = yield handleError(args, error);
            res = response.res;
            exitCode = response.exitCode;
        }
        if (!args.options.json) {
            console.log(alerts.displayAlerts());
        }
        if (!process.env.TAP && failed) {
            debug('Exit code: ' + exitCode);
            process.exitCode = exitCode;
        }
        return res;
    });
}
const cli = main().catch((e) => {
    console.error('Something unexpected went wrong: ', e.stack);
    console.error('Exit code: ' + EXIT_CODES.ERROR);
    process.exit(EXIT_CODES.ERROR);
});
if (module.parent) {
    // eslint-disable-next-line id-blacklist
    module.exports = cli;
}
//# sourceMappingURL=index.js.map