const t=".",e={},i="xstate.guard",s="";function n(t){return Object.keys(t)}function o(e,i,s=t){const r=c(e,s),a=c(i,s);return x(a)?!!x(r)&&a===r:x(r)?r in a:n(r).every(t=>t in a&&o(r[t],a[t]))}function r(t){try{return x(t)||"number"==typeof t?`${t}`:t.type}catch(t){throw new Error("Events must be strings or objects with a string event.type property.")}}function a(t,e){try{return w(t)?t:t.toString().split(e)}catch(e){throw new Error(`'${t}' is not a valid state path.`)}}function c(t,e){if("object"==typeof(i=t)&&"value"in i&&"context"in i&&"event"in i&&"_event"in i)return t.value;var i;if(w(t))return h(t);if("string"!=typeof t)return t;return h(a(t,e))}function h(t){if(1===t.length)return t[0];const e={};let i=e;for(let e=0;e<t.length-1;e++)e===t.length-2?i[t[e]]=t[e+1]:(i[t[e]]={},i=i[t[e]]);return e}function d(t,e){const i={},s=n(t);for(let n=0;n<s.length;n++){const o=s[n];i[o]=e(t[o],o,t,n)}return i}function u(t,e,i){const s={};for(const o of n(t)){const n=t[o];i(n)&&(s[o]=e(n,o,t))}return s}const l=t=>e=>{let i=e;for(const e of t)i=i[e];return i};function f(t){if(!t)return[[]];if(x(t))return[[t]];return p(n(t).map(e=>{const i=t[e];return"string"==typeof i||i&&Object.keys(i).length?f(t[e]).map(t=>[e].concat(t)):[[e]]}))}function p(t){return[].concat(...t)}function g(t){return w(t)?t:[t]}function v(t){return void 0===t?[]:g(t)}function y(t,e,i){if(_(t))return t(e,i.data);const s={};for(const o of n(t)){const n=t[o];_(n)?s[o]=n(e,i.data):s[o]=n}return s}function m(t){return t instanceof Promise||!(null===t||!_(t)&&"object"!=typeof t||!_(t.then))}function b(t,e){const[i,s]=[[],[]];for(const n of t)e(n)?i.push(n):s.push(n);return[i,s]}function S(t,e){return d(t.states,(t,i)=>{if(!t)return;const s=(x(e)?void 0:e[i])||(t?t.current:void 0);return s?{current:s,states:S(t,s)}:void 0})}function w(t){return Array.isArray(t)}function _(t){return"function"==typeof t}function x(t){return"string"==typeof t}function O(t,e){if(t)return x(t)?{type:i,name:t,predicate:e?e[t]:void 0}:_(t)?{type:i,name:t.name,predicate:t}:t}function E(t){try{return"subscribe"in t&&_(t.subscribe)}catch(t){return!1}}const j=(()=>"function"==typeof Symbol&&Symbol.observable||"@@observable")();function N(t){try{return"__xstatenode"in t}catch(t){return!1}}const $=(()=>{let t=0;return()=>(++t).toString(16)})();function T(t,e){return x(t)||"number"==typeof t?Object.assign({type:t},e):t}function k(t,e){if(!x(t)&&"$$type"in t&&"scxml"===t.$$type)return t;const i=T(t);return Object.assign({name:i.type,data:i,$$type:"scxml",type:"external"},e)}function P(t,e){return g(e).map(e=>void 0===e||"string"==typeof e||N(e)?{target:e,event:t}:Object.assign(Object.assign({},e),{event:t}))}function V(t,e){let i;for(const s of n(t))o(s,e)&&(!i||e.length>i.length)&&(i=s);return t[i]}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */function I(t,e){var i={};for(var s in t)Object.prototype.hasOwnProperty.call(t,s)&&e.indexOf(s)<0&&(i[s]=t[s]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var n=0;for(s=Object.getOwnPropertySymbols(t);n<s.length;n++)e.indexOf(s[n])<0&&Object.prototype.propertyIsEnumerable.call(t,s[n])&&(i[s[n]]=t[s[n]])}return i}var L,C;!function(t){t.Start="xstate.start",t.Stop="xstate.stop",t.Raise="xstate.raise",t.Send="xstate.send",t.Cancel="xstate.cancel",t.NullEvent="",t.Assign="xstate.assign",t.After="xstate.after",t.DoneState="done.state",t.DoneInvoke="done.invoke",t.Log="xstate.log",t.Init="xstate.init",t.Invoke="xstate.invoke",t.ErrorExecution="error.execution",t.ErrorCommunication="error.communication",t.ErrorPlatform="error.platform",t.ErrorCustom="xstate.error",t.Update="xstate.update",t.Pure="xstate.pure"}(L||(L={})),function(t){t.Parent="#_parent",t.Internal="#_internal"}(C||(C={}));const A=t=>"atomic"===t.type||"final"===t.type;function R(t){return n(t.states).map(e=>t.states[e])}function M(t){const e=[t];return A(t)?e:e.concat(p(R(t).map(M)))}function D(t,e){const i=F(new Set(t)),s=new Set(e);for(const t of s){let e=t.parent;for(;e&&!s.has(e);)s.add(e),e=e.parent}const n=F(s);for(const t of s)if("compound"!==t.type||n.get(t)&&n.get(t).length){if("parallel"===t.type)for(const e of R(t))"history"!==e.type&&(s.has(e)||(s.add(e),i.get(e)?i.get(e).forEach(t=>s.add(t)):e.initialStateNodes.forEach(t=>s.add(t))))}else i.get(t)?i.get(t).forEach(t=>s.add(t)):t.initialStateNodes.forEach(t=>s.add(t));for(const t of s){let e=t.parent;for(;e&&!s.has(e);)s.add(e),e=e.parent}return s}function F(t){const e=new Map;for(const i of t)e.has(i)||e.set(i,[]),i.parent&&(e.has(i.parent)||e.set(i.parent,[]),e.get(i.parent).push(i));return e}function z(t,e){return function t(e,i){const s=i.get(e);if(!s)return{};if("compound"===e.type){const t=s[0];if(!t)return{};if(A(t))return t.key}const n={};return s.forEach(e=>{n[e.key]=t(e,i)}),n}(t,F(D([t],e)))}function J(t,e){return Array.isArray(t)?t.some(t=>t===e):t instanceof Set&&t.has(e)}function U(t,e){return"compound"===e.type?R(e).some(e=>"final"===e.type&&J(t,e)):"parallel"===e.type&&R(e).every(e=>U(t,e))}const B=L.Start,q=L.Stop,X=L.Raise,G=L.Send,H=L.Cancel,K=L.NullEvent,Q=L.Assign,W=(L.After,L.DoneState,L.Log),Y=L.Init,Z=L.Invoke,tt=(L.ErrorExecution,L.ErrorPlatform),et=L.ErrorCustom,it=L.Update,st=L.Pure,nt=k({type:Y});function ot(t,e){return e&&e[t]||void 0}function rt(t,e){let i;if(x(t)||"number"==typeof t){const s=ot(t,e);i=_(s)?{type:t,exec:s}:s||{type:t,exec:void 0}}else if(_(t))i={type:t.name||t.toString(),exec:t};else{const s=ot(t.type,e);if(_(s))i=Object.assign(Object.assign({},t),{exec:s});else if(s){const{type:e}=t,n=I(t,["type"]);i=Object.assign(Object.assign({type:e},s),n)}else i=t}return Object.defineProperty(i,"toString",{value:()=>i.type,enumerable:!1,configurable:!0}),i}const at=(t,e)=>{if(!t)return[];return(w(t)?t:[t]).map(t=>rt(t,e))};function ct(t){const e=rt(t);return Object.assign(Object.assign({id:x(t)?t:e.id},e),{type:e.type})}function ht(t){return x(t)?{type:X,event:t}:dt(t,{to:C.Internal})}function dt(t,e){return{to:e?e.to:void 0,type:G,event:_(t)?t:T(t),delay:e?e.delay:void 0,id:e&&void 0!==e.id?e.id:_(t)?t.name:r(t)}}function ut(t,e){return dt(t,Object.assign(Object.assign({},e),{to:C.Parent}))}function lt(){return ut(it)}const ft=(t,e)=>({context:t,event:e});const pt=(t,e,i)=>Object.assign(Object.assign({},t),{value:x(t.expr)?t.expr:t.expr(e,i.data,{_event:i})}),gt=t=>({type:H,sendId:t});function vt(t){const e=ct(t);return{type:L.Start,activity:e,exec:void 0}}function yt(t){const e=ct(t);return{type:L.Stop,activity:e,exec:void 0}}const mt=t=>({type:Q,assignment:t});function bt(t,e){const i=e?`#${e}`:"";return`${L.After}(${t})${i}`}function St(t,e){const i=`${L.DoneState}.${t}`,s={type:i,data:e,toString:()=>i};return s}function wt(t,e){const i=`${L.DoneInvoke}.${t}`,s={type:i,data:e,toString:()=>i};return s}function _t(t,e){const i=`${L.ErrorPlatform}.${t}`,s={type:i,data:e,toString:()=>i};return s}function xt(t,e){return dt((t,e)=>e,Object.assign(Object.assign({},e),{to:t}))}function Ot(t,e){const{exec:i}=t;return Object.assign(Object.assign({},t),{exec:void 0!==i?()=>i(e.context,e.event,{action:t,state:e,_event:e._event}):void 0})}class Et{constructor(t){this.actions=[],this.activities=e,this.meta={},this.events=[],this.value=t.value,this.context=t.context,this._event=t._event,this._sessionid=t._sessionid,this.event=this._event.data,this.historyValue=t.historyValue,this.history=t.history,this.actions=t.actions||[],this.activities=t.activities||e,this.meta=t.meta||{},this.events=t.events||[],this.matches=this.matches.bind(this),this.toStrings=this.toStrings.bind(this),this.configuration=t.configuration,this.transitions=t.transitions,this.children=t.children,this.done=!!t.done,Object.defineProperty(this,"nextEvents",{get:()=>(function(t){return p([...new Set(t.map(t=>t.ownEvents))])})(this.configuration)})}static from(t,e){if(t instanceof Et)return t.context!==e?new Et({value:t.value,context:e,_event:t._event,_sessionid:null,historyValue:t.historyValue,history:t.history,actions:[],activities:t.activities,meta:{},events:[],configuration:[],transitions:[],children:{}}):t;return new Et({value:t,context:e,_event:nt,_sessionid:null,historyValue:void 0,history:void 0,actions:[],activities:void 0,meta:void 0,events:[],configuration:[],transitions:[],children:{}})}static create(t){return new Et(t)}static inert(t,e){if(t instanceof Et){if(!t.actions.length)return t;const i=nt;return new Et({value:t.value,context:e,_event:i,_sessionid:null,historyValue:t.historyValue,history:t.history,activities:t.activities,configuration:t.configuration,transitions:[],children:{}})}return Et.from(t,e)}toStrings(t=this.value,e="."){if(x(t))return[t];const i=n(t);return i.concat(...i.map(i=>this.toStrings(t[i],e).map(t=>i+e+t)))}toJSON(){return I(this,["configuration","transitions"])}matches(t){return o(t,this.value)}}function jt(t){try{return"function"==typeof t.send}catch(t){return!1}}const Nt="",$t="#",Tt="*",kt={},Pt=t=>t[0]===$t,Vt=()=>({actions:{},guards:{},services:{},activities:{},delays:{}});class It{constructor(e,i,s){this.config=e,this.context=s,this.order=-1,this.__xstatenode=!0,this.__cache={events:void 0,relativeValue:new Map,initialStateValue:void 0,initialState:void 0,on:void 0,transitions:void 0,candidates:{},delayedTransitions:void 0},this.idMap={},this.options=Object.assign(Vt(),i),this.parent=this.options._parent,this.key=this.config.key||this.options._key||this.config.id||"(machine)",this.machine=this.parent?this.parent.machine:this,this.path=this.parent?this.parent.path.concat(this.key):[],this.delimiter=this.config.delimiter||(this.parent?this.parent.delimiter:t),this.id=this.config.id||[this.machine.key,...this.path].join(this.delimiter),this.version=this.parent?this.parent.version:this.config.version,this.type=this.config.type||(this.config.parallel?"parallel":this.config.states&&n(this.config.states).length?"compound":this.config.history?"history":"atomic"),this.initial=this.config.initial,this.states=this.config.states?d(this.config.states,(t,e)=>{const i=new It(t,{_parent:this,_key:e});return Object.assign(this.idMap,Object.assign({[i.id]:i},i.idMap)),i}):kt;let o=0;!function t(e){e.order=o++;for(const i of R(e))t(i)}(this),this.history=!0===this.config.history?"shallow":this.config.history||!1,this._transient=!!this.config.on&&(Array.isArray(this.config.on)?this.config.on.some(({event:t})=>t===Nt):Nt in this.config.on),this.strict=!!this.config.strict,this.onEntry=v(this.config.entry||this.config.onEntry).map(t=>rt(t)),this.onExit=v(this.config.exit||this.config.onExit).map(t=>rt(t)),this.meta=this.config.meta,this.data="final"===this.type?this.config.data:void 0,this.invoke=v(this.config.invoke).map((t,e)=>{if(N(t))return this.machine.options.services=Object.assign({[t.id]:t},this.machine.options.services),{type:Z,src:t.id,id:t.id};if("string"!=typeof t.src){const i=`${this.id}:invocation[${e}]`;return this.machine.options.services=Object.assign({[i]:t.src},this.machine.options.services),Object.assign(Object.assign({type:Z,id:i},t),{src:i})}return Object.assign(Object.assign({},t),{type:Z,id:t.id||t.src,src:t.src})}),this.activities=v(this.config.activities).concat(this.invoke).map(t=>ct(t)),this.transition=this.transition.bind(this)}_init(){this.__cache.transitions||M(this).forEach(t=>t.on)}withConfig(t,e=this.context){const{actions:i,activities:s,guards:n,services:o,delays:r}=this.options;return new It(this.config,{actions:Object.assign(Object.assign({},i),t.actions),activities:Object.assign(Object.assign({},s),t.activities),guards:Object.assign(Object.assign({},n),t.guards),services:Object.assign(Object.assign({},o),t.services),delays:Object.assign(Object.assign({},r),t.delays)},e)}withContext(t){return new It(this.config,this.options,t)}get definition(){return{id:this.id,key:this.key,version:this.version,context:this.context,type:this.type,initial:this.initial,history:this.history,states:d(this.states,t=>t.definition),on:this.on,transitions:this.transitions,entry:this.onEntry,exit:this.onExit,activities:this.activities||[],meta:this.meta,order:this.order||-1,data:this.data,invoke:this.invoke}}toJSON(){return this.definition}get on(){if(this.__cache.on)return this.__cache.on;const t=this.transitions;return this.__cache.on=t.reduce((t,e)=>(t[e.eventType]=t[e.eventType]||[],t[e.eventType].push(e),t),{})}get after(){return this.__cache.delayedTransitions||(this.__cache.delayedTransitions=this.getDelayedTransitions(),this.__cache.delayedTransitions)}get transitions(){return this.__cache.transitions||(this.__cache.transitions=this.formatTransitions(),this.__cache.transitions)}getCandidates(t){if(this.__cache.candidates[t])return this.__cache.candidates[t];const e=t===Nt,i=this.transitions.filter(i=>{const s=i.eventType===t;return e?s:s||i.eventType===Tt});return this.__cache.candidates[t]=i,i}getDelayedTransitions(){const t=this.config.after;if(!t)return[];const e=(t,e)=>{const i=bt(_(t)?`${this.id}:delay[${e}]`:t,this.id);return this.onEntry.push(dt(i,{delay:t})),this.onExit.push(gt(i)),i};return(w(t)?t.map((t,i)=>{const s=e(t.delay,i);return Object.assign(Object.assign({},t),{event:s})}):p(n(t).map((i,s)=>{const n=t[i],o=x(n)?{target:n}:n,r=isNaN(+i)?i:+i,a=e(r,s);return v(o).map(t=>Object.assign(Object.assign({},t),{event:a,delay:r}))}))).map(t=>{const{delay:e}=t;return Object.assign(Object.assign({},this.formatTransition(t)),{delay:e})})}getStateNodes(t){if(!t)return[];const e=t instanceof Et?t.value:c(t,this.delimiter);if(x(e)){const t=this.getStateNode(e).initial;return void 0!==t?this.getStateNodes({[e]:t}):[this.states[e]]}const i=n(e);return i.map(t=>this.getStateNode(t)).concat(i.reduce((t,i)=>{const s=this.getStateNode(i).getStateNodes(e[i]);return t.concat(s)},[]))}handles(t){const e=r(t);return this.events.includes(e)}resolveState(t){const e=Array.from(D([],this.getStateNodes(t.value)));return new Et(Object.assign(Object.assign({},t),{value:this.resolve(t.value),configuration:e}))}transitionLeafNode(t,e,i){const s=this.getStateNode(t).next(e,i);return s&&s.transitions.length?s:this.next(e,i)}transitionCompoundNode(t,e,i){const s=n(t),o=this.getStateNode(s[0])._transition(t[s[0]],e,i);return o&&o.transitions.length?o:this.next(e,i)}transitionParallelNode(t,e,i){const s={};for(const o of n(t)){const n=t[o];if(!n)continue;const r=this.getStateNode(o)._transition(n,e,i);r&&(s[o]=r)}const o=n(s).map(t=>s[t]),r=p(o.map(t=>t.transitions));if(!o.some(t=>t.transitions.length>0))return this.next(e,i);const a=p(o.map(t=>t.entrySet)),c=p(n(s).map(t=>s[t].configuration));return{transitions:r,entrySet:a,exitSet:p(o.map(t=>t.exitSet)),configuration:c,source:e,actions:p(n(s).map(t=>s[t].actions))}}_transition(t,e,i){return x(t)?this.transitionLeafNode(t,e,i):1===n(t).length?this.transitionCompoundNode(t,e,i):this.transitionParallelNode(t,e,i)}next(t,e){const i=e.name,s=[];let n,r=[];for(const a of this.getCandidates(i)){const{cond:h,in:d}=a,u=t.context,f=!d||(x(d)&&Pt(d)?t.matches(c(this.getStateNodeById(d).path,this.delimiter)):o(c(d,this.delimiter),l(this.path.slice(0,-2))(t.value)));let p=!1;try{p=!h||this.evaluateGuard(h,u,e,t)}catch(t){throw new Error(`Unable to evaluate guard '${h.name||h.type}' in transition for event '${i}' in state node '${this.id}':\n${t.message}`)}if(p&&f){void 0!==a.target&&(r=a.target),s.push(...a.actions),n=a;break}}if(!n)return;if(!r.length)return{transitions:[n],entrySet:[],exitSet:[],configuration:t.value?[this]:[],source:t,actions:s};const a=p(r.map(e=>this.getRelativeStateNodes(e,t.historyValue))),h=!!n.internal;return{transitions:[n],entrySet:h?[]:p(a.map(t=>this.nodesFromChild(t))),exitSet:h?[]:[this],configuration:a,source:t,actions:s}}nodesFromChild(t){if(t.escapes(this))return[];const e=[];let i=t;for(;i&&i!==this;)e.push(i),i=i.parent;return e.push(this),e}escapes(t){if(this===t)return!1;let e=this.parent;for(;e;){if(e===t)return!1;e=e.parent}return!0}evaluateGuard(t,e,s,n){const{guards:o}=this.machine.options,r={state:n,cond:t,_event:s};if(t.type===i)return t.predicate(e,s.data,r);const a=o[t.type];if(!a)throw new Error(`Guard '${t.type}' is not implemented on machine '${this.machine.id}'.`);return a(e,s.data,r)}getActions(t,e,i,s){const n=D([],s?this.getStateNodes(s.value):[this]),o=t.configuration.length?D(n,t.configuration):n;for(const e of o)J(n,e)||t.entrySet.push(e);for(const e of n)J(o,e)&&!J(t.exitSet,e.parent)||t.exitSet.push(e);t.source||(t.exitSet=[],t.entrySet.push(this));const r=p(t.entrySet.map(s=>{const n=[];if("final"!==s.type)return n;const o=s.parent;if(n.push(St(s.id,s.data),St(o.id,s.data?y(s.data,e,i):void 0)),o.parent){const e=o.parent;"parallel"===e.type&&R(e).every(e=>U(t.configuration,e))&&n.push(St(e.id,e.data))}return n}));t.exitSet.sort((t,e)=>e.order-t.order),t.entrySet.sort((t,e)=>t.order-e.order);const a=new Set(t.entrySet),c=new Set(t.exitSet),[h,d]=[p(Array.from(a).map(t=>[...t.activities.map(t=>vt(t)),...t.onEntry])).concat(r.map(ht)),p(Array.from(c).map(t=>[...t.onExit,...t.activities.map(t=>yt(t))]))];return at(d.concat(t.actions).concat(h),this.machine.options.actions)}transition(t=this.initialState,e,i){const s=k(e);let n;if(t instanceof Et)n=void 0===i?t:this.resolveState(Et.from(t,i));else{const e=x(t)?this.resolve(h(this.getResolvedPath(t))):this.resolve(t),s=i||this.machine.context;n=this.resolveState(Et.from(e,s))}if(this.strict&&!this.events.includes(s.name)&&(o=s.name,!/^(done|error)\./.test(o)))throw new Error(`Machine '${this.id}' does not accept event '${s.name}'`);var o;const r=this._transition(n.value,n,s)||{transitions:[],configuration:[],entrySet:[],exitSet:[],source:n,actions:[]},a=D([],this.getStateNodes(n.value)),c=r.configuration.length?D(a,r.configuration):a;return r.configuration=[...c],this.resolveTransition(r,n,s)}resolveRaisedTransition(t,e,i){const s=t.actions;return(t=this.transition(t,e))._event=i,t.event=i.data,t.actions.unshift(...s),t}resolveTransition(t,e,i=nt,s=this.machine.context){const{configuration:o}=t,r=!e||t.transitions.length>0?z(this.machine,o):void 0,a=e?e.historyValue?e.historyValue:t.source?this.machine.historyValue(e.value):void 0:void 0,c=e?e.context:s,h=this.getActions(t,c,i,e),d=e?Object.assign({},e.activities):{};for(const t of h)t.type===B?d[t.activity.type]=t:t.type===q&&(d[t.activity.type]=!1);const[u,l]=b(h,t=>t.type===Q),f=u.length?function(t,e,i,s){return t?i.reduce((t,i)=>{const{assignment:o}=i,r={state:s,action:i,_event:e};let a={};if(_(o))a=o(t,e.data,r);else for(const i of n(o)){const s=o[i];a[i]=_(s)?s(t,e.data,r):s}return Object.assign({},t,a)},t):t}(c,i,u,e):c,g=p(l.map(t=>{switch(t.type){case X:return function(t){return{type:X,_event:k(t.event)}}(t);case G:return function(t,e,i,s){const n={_event:i},o=k(_(t.event)?t.event(e,i.data,n):t.event);let r;if(x(t.delay)){const o=s&&s[t.delay];r=_(o)?o(e,i.data,n):o}else r=_(t.delay)?t.delay(e,i.data,n):t.delay;const a=_(t.to)?t.to(e,i.data,n):t.to;return Object.assign(Object.assign({},t),{to:a,_event:o,event:o.data,delay:r})}(t,f,i,this.machine.options.delays);case W:return pt(t,f,i);case st:return t.get(f,i.data)||[];default:return rt(t,this.options.actions)}})),[v,y]=b(g,t=>t.type===X||t.type===G&&t.to===C.Internal),m=g.filter(t=>t.type===B&&t.activity.type===Z).reduce((t,e)=>(t[e.activity.id]=function(t){const e={id:i=t.id,send:()=>void 0,subscribe:()=>({unsubscribe:()=>void 0}),toJSON:()=>({id:i})};var i;return e.meta=t,e}(e.activity),t),e?Object.assign({},e.children):{}),w=r?t.configuration:e?e.configuration:[],O=w.reduce((t,e)=>(void 0!==e.meta&&(t[e.id]=e.meta),t),{}),E=U(w,this),j=new Et({value:r||e.value,context:f,_event:i,_sessionid:e?e._sessionid:null,historyValue:r?a?(N=a,$=r,{current:$,states:S(N,$)}):void 0:e?e.historyValue:void 0,history:!r||t.source?e:void 0,actions:r?y:[],activities:r?d:e?e.activities:{},meta:r?O:e?e.meta:void 0,events:[],configuration:w,transitions:t.transitions,children:m,done:E});var N,$;j.changed=i.name===it||!!u.length;const{history:T}=j;if(T&&delete T.history,!r)return j;let P=j;if(!E){for((this._transient||o.some(t=>t._transient))&&(P=this.resolveRaisedTransition(P,{type:K},i));v.length;){const t=v.shift();P=this.resolveRaisedTransition(P,t._event,i)}}const V=P.changed||(T?!!P.actions.length||!!u.length||typeof T.value!=typeof P.value||!function t(e,i){if(e===i)return!0;if(void 0===e||void 0===i)return!1;if(x(e)||x(i))return e===i;const s=n(e),o=n(i);return s.length===o.length&&s.every(s=>t(e[s],i[s]))}(P.value,T.value):void 0);return P.changed=V,P.historyValue=j.historyValue,P.history=T,P}getStateNode(t){if(Pt(t))return this.machine.getStateNodeById(t);if(!this.states)throw new Error(`Unable to retrieve child state '${t}' from '${this.id}'; no child states exist.`);const e=this.states[t];if(!e)throw new Error(`Child state '${t}' does not exist on '${this.id}'`);return e}getStateNodeById(t){const e=Pt(t)?t.slice($t.length):t;if(e===this.id)return this;const i=this.machine.idMap[e];if(!i)throw new Error(`Child state node '#${e}' does not exist on machine '${this.id}'`);return i}getStateNodeByPath(t){if("string"==typeof t&&Pt(t))try{return this.getStateNodeById(t.slice(1))}catch(t){}const e=a(t,this.delimiter).slice();let i=this;for(;e.length;){const t=e.shift();if(!t.length)break;i=i.getStateNode(t)}return i}resolve(t){if(!t)return this.initialStateValue||kt;switch(this.type){case"parallel":return d(this.initialStateValue,(e,i)=>e?this.getStateNode(i).resolve(t[i]||e):kt);case"compound":if(x(t)){const e=this.getStateNode(t);return"parallel"===e.type||"compound"===e.type?{[t]:e.initialStateValue}:t}return n(t).length?d(t,(t,e)=>t?this.getStateNode(e).resolve(t):kt):this.initialStateValue||{};default:return t||kt}}getResolvedPath(t){if(Pt(t)){const e=this.machine.idMap[t.slice($t.length)];if(!e)throw new Error(`Unable to find state node '${t}'`);return e.path}return a(t,this.delimiter)}get initialStateValue(){if(this.__cache.initialStateValue)return this.__cache.initialStateValue;let t;if("parallel"===this.type)t=u(this.states,t=>t.initialStateValue||kt,t=>!("history"===t.type));else if(void 0!==this.initial){if(!this.states[this.initial])throw new Error(`Initial state '${this.initial}' not found on '${this.key}'`);t=A(this.states[this.initial])?this.initial:{[this.initial]:this.states[this.initial].initialStateValue}}return this.__cache.initialStateValue=t,this.__cache.initialStateValue}getInitialState(t,e){const i=this.getStateNodes(t);return this.resolveTransition({configuration:i,entrySet:i,exitSet:[],transitions:[],source:void 0,actions:[]},void 0,void 0,e)}get initialState(){this._init();const{initialStateValue:t}=this;if(!t)throw new Error(`Cannot retrieve initial state from simple state '${this.id}'.`);return this.getInitialState(t)}get target(){let t;if("history"===this.type){const e=this.config;t=x(e.target)&&Pt(e.target)?h(this.machine.getStateNodeById(e.target).path.slice(this.path.length-1)):e.target}return t}getRelativeStateNodes(t,e,i=!0){return i?"history"===t.type?t.resolveHistory(e):t.initialStateNodes:[t]}get initialStateNodes(){if(A(this))return[this];if("compound"===this.type&&!this.initial)return[this];return p(f(this.initialStateValue).map(t=>this.getFromRelativePath(t)))}getFromRelativePath(t){if(!t.length)return[this];const[e,...i]=t;if(!this.states)throw new Error(`Cannot retrieve subPath '${e}' from node with no states`);const s=this.getStateNode(e);if("history"===s.type)return s.resolveHistory();if(!this.states[e])throw new Error(`Child state '${e}' does not exist on '${this.id}'`);return this.states[e].getFromRelativePath(i)}historyValue(t){if(n(this.states).length)return{current:t||this.initialStateValue,states:u(this.states,(e,i)=>{if(!t)return e.historyValue();const s=x(t)?void 0:t[i];return e.historyValue(s||e.initialStateValue)},t=>!t.history)}}resolveHistory(t){if("history"!==this.type)return[this];const e=this.parent;if(!t){const t=this.target;return t?p(f(t).map(t=>e.getFromRelativePath(t))):e.initialStateNodes}const i=(s=e.path,n="states",t=>{let e=t;for(const t of s)e=e[n][t];return e})(t).current;var s,n;return x(i)?[e.getStateNode(i)]:p(f(i).map(t=>"deep"===this.history?e.getFromRelativePath(t):[e.states[t[0]]]))}get stateIds(){const t=p(n(this.states).map(t=>this.states[t].stateIds));return[this.id].concat(t)}get events(){if(this.__cache.events)return this.__cache.events;const{states:t}=this,e=new Set(this.ownEvents);if(t)for(const i of n(t)){const s=t[i];if(s.states)for(const t of s.events)e.add(`${t}`)}return this.__cache.events=Array.from(e)}get ownEvents(){const t=new Set(this.transitions.filter(t=>!(!t.target&&!t.actions.length&&t.internal)).map(t=>t.eventType));return Array.from(t)}resolveTarget(t){if(void 0!==t)return t.map(t=>{if(!x(t))return t;const e=t[0]===this.delimiter;if(e&&!this.parent)return this.getStateNodeByPath(t.slice(1));const i=e?this.key+t:t;if(!this.parent)return this.getStateNodeByPath(i);try{return this.parent.getStateNodeByPath(i)}catch(t){throw new Error(`Invalid transition definition for state node '${this.id}':\n${t.message}`)}})}formatTransition(t){const e=function(t){if(void 0!==t&&t!==s)return v(t)}(t.target),i="internal"in t?t.internal:!e||e.some(t=>x(t)&&t[0]===this.delimiter),{guards:n}=this.machine.options,o=this.resolveTarget(e),r=Object.assign(Object.assign({},t),{actions:at(v(t.actions)),cond:O(t.cond,n),target:o,source:this,internal:i,eventType:t.event});return Object.defineProperty(r,"toJSON",{value:()=>Object.assign(Object.assign({},r),{target:r.target?r.target.map(t=>`#${t.id}`):void 0,source:"#{this.id}"})}),r}formatTransitions(){let t;if(this.config.on)if(Array.isArray(this.config.on))t=this.config.on;else{const e=this.config.on,i=Tt,s=e[i],o=void 0===s?[]:s,r=I(e,[i+""]);t=p(n(r).map(t=>{return P(t,r[t])}).concat(P(Tt,o)))}else t=[];const e=this.config.onDone?P(String(St(this.id)),this.config.onDone):[],i=p(this.invoke.map(t=>{const e=[];return t.onDone&&e.push(...P(String(wt(t.id)),t.onDone)),t.onError&&e.push(...P(String(_t(t.id)),t.onError)),e})),s=this.after,o=p([...e,...i,...t].map(t=>v(t).map(t=>this.formatTransition(t))));for(const t of s)o.push(t);return o}}function Lt(t,e,i=t.context){const s="function"==typeof i?i():i;return new It(t,e,s)}function Ct(t,e){const i="function"==typeof t.context?t.context():t.context;return new It(t,e,i)}const At={deferEvents:!1};class Rt{constructor(t){this.processingEvent=!1,this.queue=[],this.initialized=!1,this.options=Object.assign(Object.assign({},At),t)}initialize(t){if(this.initialized=!0,t){if(!this.options.deferEvents)return void this.schedule(t);this.process(t)}this.flushEvents()}schedule(t){if(this.initialized&&!this.processingEvent){if(0!==this.queue.length)throw new Error("Event queue should be empty when it is not processing events");this.process(t),this.flushEvents()}else this.queue.push(t)}clear(){this.queue=[]}flushEvents(){let t=this.queue.shift();for(;t;)this.process(t),t=this.queue.shift()}process(t){this.processingEvent=!0;try{t()}catch(t){throw this.clear(),t}finally{this.processingEvent=!1}}}const Mt=new Map;let Dt=0;const Ft={bookId:()=>`x:${Dt++}`,register:(t,e)=>(Mt.set(t,e),t),get:t=>Mt.get(t),free(t){Mt.delete(t)}},zt={sync:!1,autoForward:!1},Jt=(()=>{const t=[];return(e,i)=>{e&&t.push(e);const s=i(e||t[t.length-1]);return e&&t.pop(),s}})();var Ut;!function(t){t[t.NotStarted=0]="NotStarted",t[t.Running=1]="Running",t[t.Stopped=2]="Stopped"}(Ut||(Ut={}));class Bt{constructor(t,e=Bt.defaultOptions){this.machine=t,this.scheduler=new Rt,this.delayedEventsMap={},this.listeners=new Set,this.contextListeners=new Set,this.stopListeners=new Set,this.doneListeners=new Set,this.eventListeners=new Set,this.sendListeners=new Set,this.initialized=!1,this._status=Ut.NotStarted,this.children=new Map,this.forwardTo=new Set,this.init=this.start,this.send=(t,e)=>{if(w(t))return this.batch(t),this.state;const i=k(T(t,e));if(this._status===Ut.Stopped)return this.state;if(this._status===Ut.NotStarted&&this.options.deferEvents);else if(this._status!==Ut.Running)throw new Error(`Event "${i.name}" was sent to uninitialized service "${this.machine.id}". Make sure .start() is called for this service, or set { deferEvents: true } in the service options.\nEvent: ${JSON.stringify(i.data)}`);return this.scheduler.schedule(()=>{this.forward(i);const t=this.nextState(i);this.update(t,i)}),this._state},this.sendTo=(t,e)=>{const i=this.parent&&(e===C.Parent||this.parent.id===e),s=i?this.parent:jt(e)?e:this.children.get(e)||Ft.get(e);if(s)"machine"in s?s.send(Object.assign(Object.assign({},t),{name:t.name===et?`${_t(this.id)}`:t.name,origin:this.sessionId})):s.send(t.data);else if(!i)throw new Error(`Unable to send event to child '${e}' from service '${this.id}'.`)};const i=Object.assign(Object.assign({},Bt.defaultOptions),e),{clock:s,logger:n,parent:o,id:r}=i,a=void 0!==r?r:t.id;this.id=a,this.logger=n,this.clock=s,this.parent=o,this.options=i,this.scheduler=new Rt({deferEvents:this.options.deferEvents}),this.sessionId=Ft.bookId()}get initialState(){return this._initialState?this._initialState:Jt(this,()=>(this._initialState=this.machine.initialState,this._initialState))}get state(){return this._state}execute(t,e){for(const i of t.actions)this.exec(i,t,e)}update(t,e){if(t._sessionid=this.sessionId,this._state=t,this.options.execute&&this.execute(this.state),this.devTools&&this.devTools.send(e.data,t),t.event)for(const e of this.eventListeners)e(t.event);for(const e of this.listeners)e(t,t.event);for(const t of this.contextListeners)t(this.state.context,this.state.history?this.state.history.context:void 0);const i=U(t.configuration||[],this.machine);if(this.state.configuration&&i){const i=t.configuration.find(t=>"final"===t.type&&t.parent===this.machine),s=i&&i.data?y(i.data,t.context,e):void 0;for(const t of this.doneListeners)t(wt(this.id,s));this.stop()}}onTransition(t){return this.listeners.add(t),this._status===Ut.Running&&t(this.state,this.state.event),this}subscribe(t,e,i){if(!t)return{unsubscribe:()=>void 0};let s,n=i;return"function"==typeof t?s=t:(s=t.next.bind(t),n=t.complete.bind(t)),this.listeners.add(s),this._status===Ut.Running&&s(this.state),n&&this.onDone(n),{unsubscribe:()=>{s&&this.listeners.delete(s),n&&this.doneListeners.delete(n)}}}onEvent(t){return this.eventListeners.add(t),this}onSend(t){return this.sendListeners.add(t),this}onChange(t){return this.contextListeners.add(t),this}onStop(t){return this.stopListeners.add(t),this}onDone(t){return this.doneListeners.add(t),this}off(t){return this.listeners.delete(t),this.eventListeners.delete(t),this.sendListeners.delete(t),this.stopListeners.delete(t),this.doneListeners.delete(t),this.contextListeners.delete(t),this}start(t){if(this._status===Ut.Running)return this;Ft.register(this.sessionId,this),this.initialized=!0,this._status=Ut.Running;const e=void 0===t?this.initialState:Jt(this,()=>(function(t){return!x(t)&&("value"in t&&"history"in t)})(t)?this.machine.resolveState(t):this.machine.resolveState(Et.from(t,this.machine.context)));return this.options.devTools&&this.attachDev(),this.scheduler.initialize(()=>{this.update(e,nt)}),this}stop(){for(const t of this.listeners)this.listeners.delete(t);for(const t of this.stopListeners)t(),this.stopListeners.delete(t);for(const t of this.contextListeners)this.contextListeners.delete(t);for(const t of this.doneListeners)this.doneListeners.delete(t);this.children.forEach(t=>{_(t.stop)&&t.stop()});for(const t of n(this.delayedEventsMap))this.clock.clearTimeout(this.delayedEventsMap[t]);return this.scheduler.clear(),this.initialized=!1,this._status=Ut.Stopped,Ft.free(this.sessionId),this}batch(t){if(this._status===Ut.NotStarted&&this.options.deferEvents);else if(this._status!==Ut.Running)throw new Error(`${t.length} event(s) were sent to uninitialized service "${this.machine.id}". Make sure .start() is called for this service, or set { deferEvents: true } in the service options.`);this.scheduler.schedule(()=>{let e=this.state,i=!1;const s=[];for(const n of t){const t=k(n);this.forward(t),e=Jt(this,()=>this.machine.transition(e,t)),s.push(...e.actions.map(t=>Ot(t,e))),i=i||!!e.changed}e.changed=i,e.actions=s,this.update(e,k(t[t.length-1]))})}sender(t){return this.send.bind(this,t)}nextState(t){const e=k(t);if(0===e.name.indexOf(tt)&&!this.state.nextEvents.some(t=>0===t.indexOf(tt)))throw e.data.data;return Jt(this,()=>this.machine.transition(this.state,e))}forward(t){for(const e of this.forwardTo){const i=this.children.get(e);if(!i)throw new Error(`Unable to forward event '${t}' from interpreter '${this.id}' to nonexistant child '${e}'.`);i.send(t)}}defer(t){this.delayedEventsMap[t.id]=this.clock.setTimeout(()=>{t.to?this.sendTo(t._event,t.to):this.send(t._event)},t.delay)}cancel(t){this.clock.clearTimeout(this.delayedEventsMap[t]),delete this.delayedEventsMap[t]}exec(t,e,i){const{context:s,_event:n}=e,o=ot(t.type,i)||t.exec,r=_(o)?o:o?o.exec:t.exec;if(r)try{return r(s,n.data,{action:t,state:this.state,_event:n})}catch(t){throw this.parent&&this.parent.send({type:"xstate.error",data:t}),t}switch(t.type){case G:const e=t;if("number"==typeof e.delay)return void this.defer(e);e.to?this.sendTo(e._event,e.to):this.send(e._event);break;case H:this.cancel(t.sendId);break;case B:{const e=t.activity;if(!this.state.activities[e.type])break;if(e.type===L.Invoke){const t=this.machine.options.services?this.machine.options.services[e.src]:void 0,{id:i,data:o}=e,r="autoForward"in e?e.autoForward:!!e.forward;if(!t)return;const a=_(t)?t(s,n.data):t;m(a)?this.state.children[i]=this.spawnPromise(Promise.resolve(a),i):_(a)?this.state.children[i]=this.spawnCallback(a,i):E(a)?this.state.children[i]=this.spawnObservable(a,i):N(a)&&(this.state.children[i]=this.spawnMachine(o?a.withContext(y(o,s,n)):a,{id:i,autoForward:r}))}else this.spawnActivity(e);break}case q:this.stopChild(t.activity.id);break;case W:const{label:i,value:o}=t;i?this.logger(i,o):this.logger(o)}}stopChild(t){const e=this.children.get(t);e&&(this.children.delete(t),this.forwardTo.delete(t),delete this.state.children[t],_(e.stop)&&e.stop())}spawn(t,e,i){if(m(t))return this.spawnPromise(Promise.resolve(t),e);if(_(t))return this.spawnCallback(t,e);if(jt(t))return this.spawnActor(t);if(E(t))return this.spawnObservable(t,e);if(N(t))return this.spawnMachine(t,Object.assign(Object.assign({},i),{id:e}));throw new Error(`Unable to spawn entity "${e}" of type "${typeof t}".`)}spawnMachine(t,e={}){const i=new Bt(t,Object.assign(Object.assign({},this.options),{parent:this,id:e.id||t.id})),s=Object.assign(Object.assign({},zt),e);s.sync&&i.onTransition(t=>{this.send(it,{state:t,id:i.id})}),i.onDone(t=>{this.send(k(t,{origin:i.id}))}).start();const n=i;return this.children.set(i.id,n),s.autoForward&&this.forwardTo.add(i.id),n}spawnPromise(t,e){let i=!1;t.then(t=>{i||this.send(k(wt(e,t),{origin:e}))},t=>{if(!i){const i=_t(e,t);try{this.send(k(i,{origin:e}))}catch(t){this.devTools&&this.devTools.send(i,this.state),this.machine.strict&&this.stop()}}});const s={id:e,send:()=>void 0,subscribe:(e,i,s)=>{let n=!1;return t.then(t=>{n||(e&&e(t),n||s&&s())},t=>{n||i(t)}),{unsubscribe:()=>n=!0}},stop:()=>{i=!0},toJSON:()=>({id:e})};return this.children.set(e,s),s}spawnCallback(t,e){let i=!1;const s=new Set,n=new Set,o=t=>{n.forEach(e=>e(t)),i||this.send(t)};let r;try{r=t(o,t=>{s.add(t)})}catch(t){this.send(_t(e,t))}if(m(r))return this.spawnPromise(r,e);const a={id:e,send:t=>s.forEach(e=>e(t)),subscribe:t=>(n.add(t),{unsubscribe:()=>{n.delete(t)}}),stop:()=>{i=!0,_(r)&&r()},toJSON:()=>({id:e})};return this.children.set(e,a),a}spawnObservable(t,e){const i=t.subscribe(t=>{this.send(k(t,{origin:e}))},t=>{this.send(k(_t(e,t),{origin:e}))},()=>{this.send(k(wt(e),{origin:e}))}),s={id:e,send:()=>void 0,subscribe:(e,i,s)=>t.subscribe(e,i,s),stop:()=>i.unsubscribe(),toJSON:()=>({id:e})};return this.children.set(e,s),s}spawnActor(t){return this.children.set(t.id,t),t}spawnActivity(t){const e=this.machine.options&&this.machine.options.activities?this.machine.options.activities[t.type]:void 0;if(!e)return;const i=e(this.state.context,t);this.spawnEffect(t.id,i)}spawnEffect(t,e){this.children.set(t,{id:t,send:()=>void 0,subscribe:()=>({unsubscribe:()=>void 0}),stop:e||void 0,toJSON:()=>({id:t})})}attachDev(){if(this.options.devTools&&"undefined"!=typeof window&&window.__REDUX_DEVTOOLS_EXTENSION__){const t="object"==typeof this.options.devTools?this.options.devTools:void 0;this.devTools=window.__REDUX_DEVTOOLS_EXTENSION__.connect(Object.assign(Object.assign({name:this.id,autoPause:!0,stateSanitizer:t=>({value:t.value,context:t.context,actions:t.actions})},t),{features:Object.assign({jump:!1,skip:!1},t?t.features:void 0)}),this.machine),this.devTools.init(this.state)}}toJSON(){return{id:this.id}}[j](){return this}}Bt.defaultOptions=(t=>({execute:!0,deferEvents:!0,clock:{setTimeout:(e,i)=>t.setTimeout.call(null,e,i),clearTimeout:e=>t.clearTimeout.call(null,e)},logger:t.console.log.bind(console),devTools:!1}))("undefined"==typeof window?global:window),Bt.interpret=Ht;const qt=(t="null")=>({id:t,send:()=>void 0,subscribe:()=>({unsubscribe:()=>{}}),toJSON:()=>({id:t})}),Xt=t=>x(t)?Object.assign(Object.assign({},zt),{name:t}):Object.assign(Object.assign(Object.assign({},zt),{name:$()}),t);function Gt(t,e){const i=Xt(e);return Jt(void 0,e=>e?e.spawn(t,i.name,i):qt(i.name))}function Ht(t,e){return new Bt(t,e)}function Kt(t,e,i){const s=Et.from(t,t instanceof Et?t.context:void 0);for(const[t,i]of e)if(s.matches(t))return i(s);return i(s)}const Qt={raise:ht,send:dt,sendParent:ut,sendUpdate:lt,log:function(t=ft,e){return{type:W,label:e,expr:t}},cancel:gt,start:vt,stop:yt,assign:mt,after:bt,done:St,respond:function(t,e){return dt(t,Object.assign(Object.assign({},e),{to:(t,e,{_event:i})=>i.origin}))},forwardTo:xt,escalate:function(t,e){return ut((e,i,s)=>({type:et,data:_(t)?t(e,i,s):t}),Object.assign(Object.assign({},e),{to:C.Parent}))}};export{L as ActionTypes,Bt as Interpreter,Lt as Machine,C as SpecialTargets,Et as State,It as StateNode,Qt as actions,mt as assign,Ct as createMachine,wt as doneInvoke,xt as forwardTo,Ht as interpret,V as mapState,Kt as matchState,o as matchesState,dt as send,ut as sendParent,lt as sendUpdate,Gt as spawn};
