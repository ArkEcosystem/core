"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.http = exports.HttpError = void 0;
const http_1 = require("http");
const https_1 = require("https");
const url_1 = require("url");
const is_object_1 = require("./is-object");
const is_undefined_1 = require("./is-undefined");
class HttpError extends Error {
    constructor(response, error) {
        const message = error ? error.message : response.statusMessage;
        super(message);
        Object.defineProperty(this, "message", {
            enumerable: false,
            value: message,
        });
        Object.defineProperty(this, "name", {
            enumerable: false,
            value: this.constructor.name,
        });
        Object.defineProperty(this, "response", {
            enumerable: false,
            value: {
                statusMessage: response.statusMessage,
                statusCode: response.statusCode,
                headers: response.headers,
                data: response.data,
            },
        });
        Error.captureStackTrace(this, this.constructor);
    }
}
exports.HttpError = HttpError;
const sendRequest = (method, url, opts) => new Promise((res, rej) => {
    if (!is_object_1.isObject(opts)) {
        opts = {};
    }
    opts = { ...opts, ...url_1.parse(url) };
    opts.method = method.toLowerCase();
    /* istanbul ignore next */
    if (opts.protocol === "http:") {
        opts.agent = http_1.globalAgent;
    }
    if (is_undefined_1.isUndefined(opts.timeout)) {
        opts.timeout = 1500;
    }
    const req = https_1.request(opts, (r) => {
        let accumulator = "";
        r.setEncoding("utf8");
        r.on("data", (chunk) => (accumulator += chunk));
        r.on("end", () => {
            const response = {
                method,
                statusCode: r.statusCode,
                statusMessage: r.statusMessage,
                data: "",
                headers: r.rawHeaders,
            };
            const type = r.headers["content-type"];
            /* istanbul ignore next */
            if (type && accumulator && type.includes("application/json")) {
                try {
                    accumulator = JSON.parse(accumulator);
                }
                catch (error) {
                    rej(new HttpError(response, error));
                }
            }
            response.statusCode = r.statusCode;
            response.statusMessage = r.statusMessage;
            response.data = accumulator;
            if (r.statusCode && r.statusCode >= 400) {
                rej(new HttpError(response));
            }
            res(response);
        });
    });
    req.on("error", rej);
    req.on("timeout", () => req.abort());
    if (opts.body) {
        const body = JSON.stringify(opts.body);
        req.setHeader("content-type", "application/json");
        req.setHeader("content-length", Buffer.byteLength(body));
        req.write(body);
    }
    req.end();
});
exports.http = {
    get: (url, opts) => sendRequest("GET", url, opts),
    head: (url, opts) => sendRequest("HEAD", url, opts),
    post: (url, opts) => sendRequest("POST", url, opts),
    put: (url, opts) => sendRequest("PUT", url, opts),
    patch: (url, opts) => sendRequest("PATCH", url, opts),
    delete: (url, opts) => sendRequest("DELETE", url, opts),
};
//# sourceMappingURL=http.js.map