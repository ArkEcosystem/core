(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.moize = {}));
}(this, function (exports) { 'use strict';

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  // types
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  /**
   * @function assign
   *
   * @description
   * merge the sources into the target, as you would with Object.assign()
   *
   * @param {Object} target object to merge into
   * @param  {...Array<Object>} sources the sources to merge into the target
   * @returns {Object} the merged object
   */

  var assign = function assign(target) {
    var source;

    for (var index = 0; index < (arguments.length <= 1 ? 0 : arguments.length - 1); index++) {
      source = index + 1 < 1 || arguments.length <= index + 1 ? undefined : arguments[index + 1];

      if (source && typeof source === 'object') {
        for (var key in source) {
          if (hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
    }

    return target;
  };
  /**
   * @function cloneArray
   *
   * @description
   * clone the array-like object and return the new array
   *
   * @param {Array<any>|Arguments} arrayLike the array-like object to clone
   * @returns {Array<any>} the clone of the array
   */

  var cloneArray = function cloneArray(arrayLike) {
    var length = arrayLike.length;

    if (!length) {
      return [];
    }

    if (length === 1) {
      return [arrayLike[0]];
    }

    if (length === 2) {
      return [arrayLike[0], arrayLike[1]];
    }

    if (length === 3) {
      return [arrayLike[0], arrayLike[1], arrayLike[2]];
    }

    var array = new Array(length);

    for (var index = 0; index < length; index++) {
      array[index] = arrayLike[index];
    }

    return array;
  };
  var createAreKeysEqual = function createAreKeysEqual(isEqual
  /**
   * @function areKeysEqual
   *
   * @description
   * are the keys shallowly equal to one another
   *
   * @param {Array<any>} keys1 the keys array to test against
   * @param {Array<any>} keys2 the keys array to test
   * @returns {boolean} are the keys shallowly equal
   */
  ) {
    return function (keys1, keys2) {
      if (keys1.length !== keys2.length) {
        return false;
      }

      for (var index = 0, length = keys1.length; index < length; index++) {
        if (!isEqual(keys1[index], keys2[index])) {
          return false;
        }
      }

      return true;
    };
  };
  var createGetKeyIndex = function createGetKeyIndex(isEqual, isMatchingKey) {
    var areKeysEqual = typeof isMatchingKey === 'function' ? isMatchingKey : createAreKeysEqual(isEqual);
    /**
     * @function getKeyIndex
     *
     * @description
     * get the index of the matching key
     *
     * @param {Array<Array<any>>} allKeys the list of all available keys
     * @param {Array<any>} keysToMatch the key to try to match
     *
     * @returns {number} the index of the matching key value, or -1
     */

    return function (allKeys, keysToMatch) {
      for (var index = 0; index < allKeys.length; index++) {
        if (areKeysEqual(allKeys[index], keysToMatch)) {
          return index;
        }
      }

      return -1;
    };
  };
  /**
   * @function isSameValueZero
   *
   * @description
   * are the objects equal based on SameValueZero
   *
   * @param {any} object1 the first object to compare
   * @param {any} object2 the second object to compare
   * @returns {boolean} are the two objects equal
   */

  var isSameValueZero = function isSameValueZero(object1, object2) {
    return object1 === object2 || object1 !== object1 && object2 !== object2;
  };
  var onCacheOperation = function onCacheOperation(cacheIgnored, optionsIgnored, memoizedIgnored) {};
  /**
   * @function orderByLru
   *
   * @description
   * order the array based on a Least-Recently-Used basis
   *
   * @param {Array<any>} array the array to order
   * @param {any} value the value to assign at the beginning of the array
   * @param {number} startingIndex the index of the item to move to the front
   */

  var orderByLru = function orderByLru(array, value, startingIndex) {
    var index = startingIndex;

    while (index--) {
      array[index + 1] = array[index];
    }

    array[0] = value;
  };
  /**
   * @function createSetPromiseHandler
   *
   * @description
   * update the promise method to auto-remove from cache if rejected, and if resolved then fire cache hit / changed
   *
   * @param {Options} options the options for the memoized function
   * @param {function(Cache, function): function} memoized the memoized function
   */

  var createSetPromiseHandler = function createSetPromiseHandler(options) {
    var getKeyIndex = createGetKeyIndex(options.isEqual, options.isMatchingKey);
    return function (cache, memoized) {
      var key = cache.keys[0];
      cache.values[0] = cache.values[0].then(function (value) {
        options.onCacheHit(cache, options, memoized);
        options.onCacheChange(cache, options, memoized);
        return value;
      }).catch(function (error) {
        var keyIndex = getKeyIndex(cache.keys, key);

        if (~keyIndex) {
          cache.keys.splice(keyIndex, 1);
          cache.values.splice(keyIndex, 1);
        }

        throw error;
      });
    };
  };

  function _objectWithoutPropertiesLoose$1(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
  /**
   * @function memoize
   *
   * @description
   * get the memoized version of the method passed
   *
   * @param {function} fn the method to memoize
   * @param {Object} [options={}] the options to build the memoizer with
   * @param {boolean} [options.isEqual=isSameValueZero] the method to compare equality of keys with
   * @param {number} [options.maxSize=1] the number of items to store in cache
   * @returns {function} the memoized method
   */

  function memoize(fn, options) {
    // if it is a memoized method, don't re-memoize it
    if (fn.isMemoized) {
      return fn;
    }

    var _ref = options || {},
        _ref$isEqual = _ref.isEqual,
        isEqual = _ref$isEqual === void 0 ? isSameValueZero : _ref$isEqual,
        isMatchingKey = _ref.isMatchingKey,
        _ref$isPromise = _ref.isPromise,
        isPromise = _ref$isPromise === void 0 ? false : _ref$isPromise,
        _ref$maxSize = _ref.maxSize,
        maxSize = _ref$maxSize === void 0 ? 1 : _ref$maxSize,
        _ref$onCacheAdd = _ref.onCacheAdd,
        onCacheAdd = _ref$onCacheAdd === void 0 ? onCacheOperation : _ref$onCacheAdd,
        _ref$onCacheChange = _ref.onCacheChange,
        onCacheChange = _ref$onCacheChange === void 0 ? onCacheOperation : _ref$onCacheChange,
        _ref$onCacheHit = _ref.onCacheHit,
        onCacheHit = _ref$onCacheHit === void 0 ? onCacheOperation : _ref$onCacheHit,
        transformKey = _ref.transformKey,
        extraOptions = _objectWithoutPropertiesLoose$1(_ref, ["isEqual", "isMatchingKey", "isPromise", "maxSize", "onCacheAdd", "onCacheChange", "onCacheHit", "transformKey"]);

    var normalizedOptions = assign({}, extraOptions, {
      isEqual: isEqual,
      isMatchingKey: isMatchingKey,
      isPromise: isPromise,
      maxSize: maxSize,
      onCacheAdd: onCacheAdd,
      onCacheChange: onCacheChange,
      onCacheHit: onCacheHit,
      transformKey: transformKey
    });
    var getKeyIndex = createGetKeyIndex(isEqual, isMatchingKey);
    var setPromiseHandler = createSetPromiseHandler(normalizedOptions);
    var shouldCloneArguments = !!(transformKey || isMatchingKey);
    var cache = {
      keys: [],

      get size() {
        return cache.keys.length;
      },

      values: []
    };
    var keys = cache.keys,
        values = cache.values;
    /**
     * @function memoized
     *
     * @description
     * the memoized version of the method passed
     *
     * @param {...Array<any>} key the arguments passed, which create a unique cache key
     * @returns {any} the value of the method called with the arguments
     */

    function memoized() {
      var args = arguments;
      var normalizedArgs = shouldCloneArguments ? cloneArray(args) : args;
      var key = transformKey ? transformKey(normalizedArgs) : normalizedArgs;
      var keyIndex = getKeyIndex(keys, key);

      if (~keyIndex) {
        onCacheHit(cache, normalizedOptions, memoized);

        if (keyIndex) {
          orderByLru(keys, keys[keyIndex], keyIndex);
          orderByLru(values, values[keyIndex], keyIndex);
          onCacheChange(cache, normalizedOptions, memoized);
        }
      } else {
        if (keys.length >= maxSize) {
          keys.pop();
          values.pop();
        }

        var newKey = shouldCloneArguments ? key : cloneArray(normalizedArgs);
        var newValue = fn.apply(this, args);
        orderByLru(keys, newKey, keys.length);
        orderByLru(values, newValue, values.length);

        if (isPromise) {
          setPromiseHandler(cache, memoized);
        }

        onCacheAdd(cache, normalizedOptions, memoized);
        onCacheChange(cache, normalizedOptions, memoized);
      }

      return values[0];
    }

    Object.defineProperties(memoized, {
      cache: {
        configurable: true,
        get: function get() {
          return cache;
        }
      },
      cacheSnapshot: {
        configurable: true,
        get: function get() {
          return {
            keys: cloneArray(cache.keys),
            size: cache.size,
            values: cloneArray(cache.values)
          };
        }
      },
      isMemoized: {
        configurable: true,
        get: function get() {
          return true;
        }
      },
      options: {
        configurable: true,
        get: function get() {
          return normalizedOptions;
        }
      }
    });
    return memoized;
  }

  // types

  /**
   * @private
   *
   * @constant {Object} DEFAULT_OPTIONS
   */
  var DEFAULT_OPTIONS = {
    equals: undefined,
    isDeepEqual: false,
    isPromise: false,
    isReact: false,
    isSerialized: false,
    matchesKey: undefined,
    maxAge: undefined,
    maxArgs: undefined,
    maxSize: Infinity,
    onExpire: undefined,
    profileName: undefined,
    serializer: undefined,
    shouldSerializeFunctions: false,
    transformArgs: undefined,
    updateExpire: false
  };

  // constants

  /**
   * @private
   *
   * @function combine
   *
   * @description
   * method to combine functions and return a single function that fires them all
   *
   * @param {...Array<any>} functions the functions to compose
   * @returns {function(...Array<any>): any} the composed function
   */
  var combine = function combine() {
    for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
      functions[_key] = arguments[_key];
    }

    if (functions.length) {
      return functions.reduce( // $FlowIgnore return value is always a function
      function (f, g) {
        return typeof f === 'function' ? typeof g === 'function' ? function () {
          // eslint-disable-next-line prefer-rest-params
          g.apply(this, arguments); // eslint-disable-next-line prefer-rest-params

          f.apply(this, arguments);
        } : f : typeof g === 'function' ? g : undefined;
      });
    }
  };
  /**
   * @private
   *
   * @function compose
   *
   * @description
   * method to compose functions and return a single function
   *
   * @param {...Array<any>} functions the functions to compose
   * @returns {function(...Array<any>): any} the composed function
   */

  var compose = function compose() {
    for (var _len2 = arguments.length, functions = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      functions[_key2] = arguments[_key2];
    }

    if (functions.length) {
      return functions.reduce( // $FlowIgnore return value is always a function
      function (f, g) {
        return typeof f === 'function' ? typeof g === 'function' ? function () {
          // eslint-disable-next-line prefer-rest-params
          return f(g.apply(this, arguments));
        } : f : typeof g === 'function' ? g : undefined;
      });
    }
  };
  /**
   * @private
   *
   * @function findExpirationIndex
   *
   * @description
   * find the index of the expiration based on the key
   *
   * @param {Array<Expiration>} expirations the list of expirations
   * @param {Array<any>} key the key to match
   * @returns {number} the index of the expiration
   */

  var findExpirationIndex = function findExpirationIndex(expirations, key) {
    for (var index = 0; index < expirations.length; index++) {
      if (expirations[index].key === key) {
        return index;
      }
    }

    return -1;
  };
  var createFindKeyIndex = function createFindKeyIndex(isEqual, isMatchingKey) {
    var areKeysEqual = typeof isMatchingKey === 'function' ? isMatchingKey : function (cacheKey, key) {
      for (var index = 0; index < key.length; index++) {
        if (!isEqual(cacheKey[index], key[index])) {
          return false;
        }
      }

      return true;
    };
    /**
     * @private
     *
     * @function findKeyIndex
     *
     * @description
     * find the index of the key in the list of cache keys
     *
     * @param {Array<Array<any>>} keys the list of keys in cache
     * @param {Array<any>} key the key to match
     * @returns {number} the index of the key
     */

    return function (keys, key) {
      for (var keysIndex = 0; keysIndex < keys.length; keysIndex++) {
        if (keys[keysIndex].length === key.length) {
          if (areKeysEqual(keys[keysIndex], key)) {
            return keysIndex;
          }
        }
      }

      return -1;
    };
  };
  /**
   * @private
   *
   * @function getArrayKey
   *
   * @description
   * return the transformed key as an array
   *
   * @param {any} key the transformed key
   * @returns {Array<any>} the key as an array
   */

  var getArrayKey = function getArrayKey(key) {
    return Array.isArray(key) ? key : [key];
  };
  /**
   * @private
   *
   * @function mergeOptions
   *
   * @description
   * merge two options objects, combining or composing functions as necessary
   *
   * @param {Options} originalOptions the options that already exist on the method
   * @param {Options} newOptions the new options to merge
   * @returns {Options} the merged options
   */

  var mergeOptions = function mergeOptions(originalOptions, newOptions) {
    return newOptions === DEFAULT_OPTIONS ? originalOptions : Object.assign({}, originalOptions, newOptions, {
      // $FlowIgnore undefined value is ok
      onCacheAdd: combine(originalOptions.onCacheAdd, newOptions.onCacheAdd),
      // $FlowIgnore undefined value is ok
      onCacheChange: combine(originalOptions.onCacheChange, newOptions.onCacheChange),
      // $FlowIgnore undefined value is ok
      onCacheHit: combine(originalOptions.onCacheHit, newOptions.onCacheHit),
      // $FlowIgnore undefined value is ok
      transformArgs: compose(originalOptions.transformArgs, newOptions.transformArgs)
    });
  };

  // types
  /**
   * @private
   *
   * @function clearExpiration
   *
   * @description
   * clear an active expiration and remove it from the list if applicable
   *
   * @param {Array<Expiration>} expirations the list of expirations
   * @param {any} key the key to clear
   * @param {boolean} [shouldRemove] should the expiration be removed from the list
   */

  var clearExpiration = function clearExpiration(expirations, key, shouldRemove) {
    var expirationIndex = findExpirationIndex(expirations, key);

    if (~expirationIndex) {
      clearTimeout(expirations[expirationIndex].timeoutId);

      if (shouldRemove) {
        expirations.splice(expirationIndex, 1);
      }
    }
  };
  var createOnCacheAddSetExpiration = function createOnCacheAddSetExpiration(expirations, options, isEqual, isMatchingKey) {
    var maxAge = options.maxAge,
        onCacheChange = options.onCacheChange,
        onExpire = options.onExpire;
    var findKeyIndex = createFindKeyIndex(isEqual, isMatchingKey);
    /**
     * @private
     *
     * @function onCacheAdd
     *
     * @description
     * when an item is added to the cache, add an expiration for it
     *
     * @modifies {expirations}
     *
     * @param {Cache} cache the cache of the memoized function
     * @param {Options} moizedOptions the options passed to the memoized function
     * @param {function} moized the memoized function
     * @returns {void}
     */

    return function onCacheAdd(cache, moizedOptions, moized) {
      var key = cache.keys[0];

      if (!~findExpirationIndex(expirations, key)) {
        var expirationMethod = function expirationMethod() {
          var keyIndex = findKeyIndex(cache.keys, key);
          var value = cache.values[keyIndex];

          if (~keyIndex) {
            cache.keys.splice(keyIndex, 1);
            cache.values.splice(keyIndex, 1);

            if (typeof onCacheChange === 'function') {
              onCacheChange(cache, moizedOptions, moized);
            }
          }

          clearExpiration(expirations, key, true);

          if (typeof onExpire === 'function' && onExpire(key) === false) {
            cache.keys.unshift(key);
            cache.values.unshift(value);
            createOnCacheAddSetExpiration(expirations, options, isEqual)(cache, moizedOptions, moized);

            if (typeof onCacheChange === 'function') {
              onCacheChange(cache, moizedOptions, moized);
            }
          }
        };

        expirations.push({
          expirationMethod: expirationMethod,
          key: key,
          // $FlowIgnore maxAge is an number
          timeoutId: setTimeout(expirationMethod, maxAge)
        });
      }
    };
  };
  var createOnCacheHitResetExpiration = function createOnCacheHitResetExpiration(expirations, options) {
    var maxAge = options.maxAge;
    /**
     * @private
     *
     * @function onCacheHit
     *
     * @description
     * when a cache item is hit, reset the expiration
     *
     * @modifies {expirations}
     *
     * @param {Cache} cache the cache of the memoized function
     * @returns {void}
     */

    return function onCacheHit(cache) {
      var key = cache.keys[0];
      var expirationIndex = findExpirationIndex(expirations, key);

      if (~expirationIndex) {
        clearExpiration(expirations, key, false);
        expirations[expirationIndex].timeoutId = setTimeout(expirations[expirationIndex].expirationMethod, maxAge);
      }
    };
  };
  /**
   * @private
   *
   * @function getMaxAgeOptions
   *
   * @description
   * get the micro-memoize options specific to the maxAge option
   *
   * @param {Array<Expiration>} expirations the expirations for the memoized function
   * @param {Options} options the options passed to the moizer
   * @param {function} isEqual the function to test equality of the key on a per-argument basis
   * @param {function} isMatchingKey the function to test equality of the whole key
   * @returns {Object} the object of options based on the entries passed
   */

  var getMaxAgeOptions = function getMaxAgeOptions(expirations, options, isEqual, isMatchingKey) {
    var maxAge = options.maxAge,
        updateExpire = options.updateExpire;
    var onCacheAdd = typeof maxAge === 'number' && isFinite(maxAge) ? createOnCacheAddSetExpiration(expirations, options, isEqual, isMatchingKey) : undefined;
    return {
      onCacheAdd: onCacheAdd,
      onCacheHit: onCacheAdd && updateExpire ? createOnCacheHitResetExpiration(expirations, options) : undefined
    };
  };

  // types

  /**
   * @private
   *
   * @constant {StatsCache} statsCache
   */
  var statsCache = {
    anonymousProfileNameCounter: 1,
    isCollectingStats: false,
    profiles: {}
  };
  /**
   * @private
   *
   * @var {boolean} hasWarningDisplayed
   */

  var hasWarningDisplayed = false;
  /**
   * @private
   *
   * @function collectStats
   *
   * @description
   * activate stats collection
   */

  var collectStats = function collectStats() {
    statsCache.isCollectingStats = true;
  };
  var createOnCacheAddIncrementCalls = function createOnCacheAddIncrementCalls(options) {
    var profileName = options.profileName; // $FlowIgnore profileName is populated

    if (!statsCache.profiles[profileName]) {
      // $FlowIgnore profileName is populated
      statsCache.profiles[profileName] = {
        calls: 0,
        hits: 0
      };
    }
    /**
     * @private
     *
     * @function onCacheAddIncrementCalls
     *
     * @description
     * increment the number of calls for the specific profile
     *
     * @modifies {statsCache}
     */


    return function () {
      // $FlowIgnore profileName is populated
      statsCache.profiles[profileName].calls++;
    };
  };
  var createOnCacheHitIncrementCallsAndHits = function createOnCacheHitIncrementCallsAndHits(options) {
    var profileName = options.profileName;
    /**
     * @private
     *
     * @function onCacheHitIncrementCallsAndHits
     *
     * @description
     * increment the number of calls and cache hits for the specific profile
     *
     * @modifies {statsCache}
     */

    return function () {
      // $FlowIgnore profileName is populated
      statsCache.profiles[profileName].calls++; // $FlowIgnore profileName is populated

      statsCache.profiles[profileName].hits++;
    };
  };
  /**
   * @private
   *
   * @function getDefaultProfileName
   *
   * @description
   * get the profileName for the function when one is not provided
   *
   * @param {function} fn the function to be memoized
   * @returns {string} the derived profileName for the function
   */

  var getDefaultProfileName = function getDefaultProfileName(fn) {
    var stack = new Error().stack;
    var fnName = fn.displayName || fn.name || "Anonymous " + statsCache.anonymousProfileNameCounter++;

    if (!stack) {
      return fnName;
    }

    var lines = stack.split('\n').slice(3);
    var line, profileNameLocation;

    for (var index = 0; index < lines.length; index++) {
      line = lines[index];

      if (!~line.indexOf('/moize/') && !~line.indexOf(' (native)') && !~line.indexOf(' Function.')) {
        profileNameLocation = line.replace(/\n/g, '\\n').trim();
        break;
      }
    }

    return profileNameLocation ? fnName + " " + profileNameLocation : fnName;
  };
  /**
   * @private
   *
   * @function getUsagePercentage
   *
   * @description
   * get the usage percentage based on the number of hits and total calls
   *
   * @param {number} calls the number of calls made
   * @param {number} hits the number of cache hits when called
   * @returns {string} the usage as a percentage string
   */

  var getUsagePercentage = function getUsagePercentage(calls, hits) {
    return calls ? (hits / calls * 100).toFixed(4) + "%" : '0%';
  };
  /**
   * @private
   *
   * @function getStats
   *
   * @description
   * get the statistics for a given method or all methods
   *
   * @param {string} [profileName] the profileName to get the statistics for (get all when not provided)
   * @returns {StatsObject} the object with stats information
   */

  var getStats = function getStats(profileName) {
    if (!statsCache.isCollectingStats && !hasWarningDisplayed) {
      console.warn('Stats are not currently being collected, please run "collectStats" to enable them.'); // eslint-disable-line no-console

      hasWarningDisplayed = true;
    }

    if (profileName) {
      if (!statsCache.profiles[profileName]) {
        return {
          calls: 0,
          hits: 0,
          usage: '0%'
        };
      }

      var profile = statsCache.profiles[profileName];
      return Object.assign({}, profile, {
        usage: getUsagePercentage(profile.calls, profile.hits)
      });
    }

    var completeStats = Object.keys(statsCache.profiles).reduce(function (profiles, profileName) {
      profiles.calls += statsCache.profiles[profileName].calls;
      profiles.hits += statsCache.profiles[profileName].hits;
      return profiles;
    }, {
      calls: 0,
      hits: 0
    });
    return Object.assign({}, completeStats, {
      profiles: Object.keys(statsCache.profiles).reduce(function (profiles, profileName) {
        profiles[profileName] = getStats(profileName);
        return profiles;
      }, {}),
      usage: getUsagePercentage(completeStats.calls, completeStats.hits)
    });
  };
  /**
   * @private
   *
   * @function getStatsOptions
   *
   * @description
   * get the options specific to storing statistics
   *
   * @param {Options} options the options passed to the moizer
   * @returns {Object} the options specific to keeping stats
   */

  var getStatsOptions = function getStatsOptions(options) {
    return statsCache.isCollectingStats ? {
      onCacheAdd: createOnCacheAddIncrementCalls(options),
      onCacheHit: createOnCacheHitIncrementCallsAndHits(options)
    } : {};
  };

  // external dependencies
  /**
   * @private
   *
   * @function addInstanceMethods
   *
   * @description
   * add methods to the moized fuction object that allow extra features
   *
   * @modifies {moized}
   *
   * @param {function} moized the memoized function
   * @returns {void}
   */

  var addInstanceMethods = function addInstanceMethods(moized, _ref) {
    var expirations = _ref.expirations;
    var _moized$options = moized.options,
        isEqual = _moized$options.isEqual,
        isMatchingKey = _moized$options.isMatchingKey,
        onCacheAdd = _moized$options.onCacheAdd,
        onCacheChange = _moized$options.onCacheChange,
        transformKey = _moized$options.transformKey;
    var findKeyIndex = createFindKeyIndex(isEqual, isMatchingKey);

    moized.add = function (key, value) {
      var savedKey = transformKey ? transformKey(key) : key;

      if (!~findKeyIndex(moized.cache.keys, savedKey)) {
        if (moized.cache.size >= moized.options.maxSize) {
          moized.cache.keys.pop();
          moized.cache.values.pop();
        }

        moized.cache.keys.unshift(savedKey);
        moized.cache.values.unshift(value);
        onCacheAdd(moized.cache, moized.options, moized);
        onCacheChange(moized.cache, moized.options, moized);
      }
    };

    moized.clear = function () {
      moized.cache.keys.length = 0;
      moized.cache.values.length = 0;
      onCacheChange(moized.cache, moized.options, moized);
    };

    moized.get = function (key) {
      var keyIndex = findKeyIndex(moized.cache.keys, transformKey ? transformKey(key) : key);
      return ~keyIndex ? moized.apply(this, moized.cache.keys[keyIndex]) : undefined; // eslint-disable-line prefer-spread
    };

    moized.getStats = function () {
      var profileName = moized.options.profileName;
      return getStats(profileName);
    };

    moized.has = function (key) {
      return !!~findKeyIndex(moized.cache.keys, transformKey ? transformKey(key) : key);
    };

    moized.keys = function () {
      return moized.cacheSnapshot.keys;
    };

    moized.remove = function (key) {
      var keyIndex = findKeyIndex(moized.cache.keys, transformKey ? transformKey(key) : key);

      if (~keyIndex) {
        var existingKey = moized.cache.keys[keyIndex];
        moized.cache.keys.splice(keyIndex, 1);
        moized.cache.values.splice(keyIndex, 1);
        onCacheChange(moized.cache, moized.options, moized);
        clearExpiration(expirations, existingKey, true);
      }
    };

    moized.update = function (key, value) {
      var keyIndex = findKeyIndex(moized.cache.keys, transformKey ? transformKey(key) : key);

      if (~keyIndex) {
        var existingKey = moized.cache.keys[keyIndex];
        orderByLru(moized.cache.keys, existingKey, keyIndex);
        orderByLru(moized.cache.values, value, keyIndex);
        onCacheChange(moized.cache, moized.options, moized);
      }
    };

    moized.values = function () {
      return moized.cacheSnapshot.values;
    };
  };
  /**
   * @private
   *
   * @function addInstanceMethods
   *
   * @description
   * add propeties to the moized fuction object that surfaces extra information
   *
   * @modifies {moized}
   *
   * @param {function} moized the memoized function
   * @param {Array<Expiration>} expirations the list of expirations for cache items
   * @param {Options} options the options passed to the moizer
   * @param {function} originalFunction the function that is being memoized
   * @returns {void}
   */

  var addInstanceProperties = function addInstanceProperties(moized, _ref2) {
    var expirations = _ref2.expirations,
        moizeOptions = _ref2.options,
        originalFunction = _ref2.originalFunction;
    var microMemoizeOptions = moized.options;
    Object.defineProperties(moized, {
      _microMemoizeOptions: {
        configurable: true,
        get: function get() {
          return microMemoizeOptions;
        }
      },
      expirations: {
        configurable: true,
        get: function get() {
          return expirations;
        }
      },
      expirationsSnapshot: {
        configurable: true,
        get: function get() {
          return expirations.slice(0);
        }
      },
      isCollectingStats: {
        configurable: true,
        get: function get() {
          return statsCache.isCollectingStats;
        }
      },
      isMoized: {
        configurable: true,
        get: function get() {
          return true;
        }
      },
      options: {
        configurable: true,
        get: function get() {
          return moizeOptions;
        }
      },
      originalFunction: {
        configurable: true,
        get: function get() {
          return originalFunction;
        }
      }
    });

    if (moizeOptions.isReact) {
      moized.contextTypes = originalFunction.contextTypes;
      moized.defaultProps = originalFunction.defaultProps;
      moized.displayName = "Moized(" + (originalFunction.displayName || originalFunction.name || 'Component') + ")";
      moized.propTypes = originalFunction.propTypes;
    }
  };
  /**
   * @private
   *
   * @function augmentMoizeInstance
   *
   * @description
   * add methods and properties to the memoized function for more features
   *
   * @param {function} moized the memoized function
   * @param {Object} configuration the configuration object for the instance
   * @returns {function} the memoized function passed
   */

  var augmentMoizeInstance = function augmentMoizeInstance(moized, configuration) {
    addInstanceMethods(moized, configuration);
    addInstanceProperties(moized, configuration);
    return moized;
  };

  /**
   * @constant {boolean} HAS_MAP_SUPPORT
   */
  var HAS_MAP_SUPPORT = typeof Map === 'function';
  /**
   * @constant {boolean} HAS_SET_SUPPORT
   */

  var HAS_SET_SUPPORT = typeof Set === 'function';
  /**
   * @constant {boolean} HAS_WEAKSET_SUPPORT
   */

  var HAS_WEAKSET_SUPPORT = typeof WeakSet === 'function';

  // constants
  var keys = Object.keys;
  /**
   * @function addObjectToCache
   *
   * @description
   * add object to cache if it is indeed an object
   *
   * @param {any} object the object to potentially add to the cache
   * @param {Object|WeakSet} cache the cache to add to
   * @returns {void}
   */

  var addObjectToCache = function addObjectToCache(object, cache) {
    return object && typeof object === 'object' && cache.add(object);
  };
  /**
   *
   * @param {Array<Array<any>>} pairs the pairs to check in
   * @param {Array<any>} pairToMatch the pair to check if exists
   * @param {function} isEqual the equality comparator
   * @param {any} meta the meta item to pass through
   * @returns {boolean} does the pair exist in the pairs
   */

  var hasPair = function hasPair(pairs, pairToMatch, isEqual, meta) {
    var pair;

    for (var index = 0; index < pairs.length; index++) {
      pair = pairs[index];

      if (isEqual(pair[0], pairToMatch[0], meta) && isEqual(pair[1], pairToMatch[1], meta)) {
        return true;
      }
    }

    return false;
  };
  /**
   * @function hasValue
   *
   * @description
   * does the values include the vakye passed
   *
   * @param {Array<any>} values the values to check in
   * @param {any} item the value to locate
   * @param {function} isEqual the equality comparator
   * @param {any} meta the meta item to pass through
   * @returns {boolean} does the value exist in the values
   */

  var hasValue = function hasValue(values, item, isEqual, meta) {
    for (var index = 0; index < values.length; index++) {
      if (isEqual(values[index], item, meta)) {
        return true;
      }
    }

    return false;
  };
  /**
   * @function sameValueZeroEqual
   *
   * @description
   * are the objects passed strictly equal or both NaN
   *
   * @param {any} objectA the object to compare against
   * @param {any} objectB the object to test
   * @returns {boolean} are the objects equal by the SameValueZero principle
   */

  var sameValueZeroEqual = function sameValueZeroEqual(objectA, objectB) {
    return objectA === objectB || objectA !== objectA && objectB !== objectB;
  };
  /**
   * @function isPlainObject
   *
   * @description
   * is the object a plain object
   *
   * @param {any} object the object to test
   * @returns {boolean} is the object a plain object
   */

  var isPlainObject = function isPlainObject(object) {
    return object.constructor === Object;
  };
  /**
   * @function isPromiseLike
   *
   * @description
   * is the object promise-like (thenable)
   *
   * @param {any} object the object to test
   * @returns {boolean} is the object promise-like
   */

  var isPromiseLike = function isPromiseLike(object) {
    return typeof object.then === 'function';
  };
  /**
   * @function isReactElement
   *
   * @description
   * is the object passed a react element
   *
   * @param {any} object the object to test
   * @returns {boolean} is the object a react element
   */

  var isReactElement = function isReactElement(object) {
    return !!(object.$$typeof && object._store);
  };
  /**
   * @function getNewCache
   *
   * @description
   * get a new cache object to prevent circular references
   *
   * @returns {Object|Weakset} the new cache object
   */

  var getNewCache = function getNewCache() {
    return HAS_WEAKSET_SUPPORT ? new WeakSet() : Object.create({
      _values: [],
      add: function add(value) {
        this._values.push(value);
      },
      has: function has(value) {
        return !!~this._values.indexOf(value);
      }
    });
  };
  /**
   * @function createCircularEqual
   *
   * @description
   * create a custom isEqual handler specific to circular objects
   *
   * @param {funtion} [isEqual] the isEqual comparator to use instead of isDeepEqual
   * @returns {function(any, any): boolean}
   */

  var createCircularEqual = function createCircularEqual(isEqual) {
    return function (isDeepEqual) {
      var comparator = isEqual || isDeepEqual;
      return function (objectA, objectB, cache) {
        if (cache === void 0) {
          cache = getNewCache();
        }

        var cacheHasA = cache.has(objectA);
        var cacheHasB = cache.has(objectB);

        if (cacheHasA || cacheHasB) {
          return cacheHasA && cacheHasB;
        }

        addObjectToCache(objectA, cache);
        addObjectToCache(objectB, cache);
        return comparator(objectA, objectB, cache);
      };
    };
  };
  /**
   * @function toPairs
   *
   * @param {Map} map the map to convert to [key, value] pairs (entries)
   * @returns {Array<Array<*>>} the [key, value] pairs
   */

  var toPairs = function toPairs(map) {
    var pairs = [];
    map.forEach(function (value, key) {
      return pairs.push([key, value]);
    });
    return pairs;
  };
  /**
   * @function toValues
   *
   * @param {Set} set the set to convert to values
   * @returns {Array<*>} the values
   */

  var toValues = function toValues(set) {
    var values = [];
    set.forEach(function (value) {
      return values.push(value);
    });
    return values;
  };
  /**
   * @function areArraysEqual
   *
   * @description
   * are the arrays equal in value
   *
   * @param {Array<any>} arrayA the array to test
   * @param {Array<any>} arrayB the array to test against
   * @param {function} isEqual the comparator to determine equality
   * @param {any} meta the meta object to pass through
   * @returns {boolean} are the arrays equal
   */

  var areArraysEqual = function areArraysEqual(arrayA, arrayB, isEqual, meta) {
    if (arrayA.length !== arrayB.length) {
      return false;
    }

    for (var index = 0; index < arrayA.length; index++) {
      if (!isEqual(arrayA[index], arrayB[index], meta)) {
        return false;
      }
    }

    return true;
  };
  /**
   * @function areMapsEqual
   *
   * @description
   * are the maps equal in value
   *
   * @param {Map} mapA the map to test
   * @param {Map} mapB the map to test against
   * @param {function} isEqual the comparator to determine equality
   * @param {any} meta the meta map to pass through
   * @returns {boolean} are the maps equal
   */

  var areMapsEqual = function areMapsEqual(mapA, mapB, isEqual, meta) {
    var pairsA = toPairs(mapA);
    var pairsB = toPairs(mapB);

    if (pairsA.length !== pairsB.length) {
      return false;
    }

    for (var index = 0; index < pairsA.length; index++) {
      if (!hasPair(pairsB, pairsA[index], isEqual, meta) || !hasPair(pairsA, pairsB[index], isEqual, meta)) {
        return false;
      }
    }

    return true;
  };
  /**
   * @function areObjectsEqual
   *
   * @description
   * are the objects equal in value
   *
   * @param {Object} objectA the object to test
   * @param {Object} objectB the object to test against
   * @param {function} isEqual the comparator to determine equality
   * @param {any} meta the meta object to pass through
   * @returns {boolean} are the objects equal
   */

  var areObjectsEqual = function areObjectsEqual(objectA, objectB, isEqual, meta) {
    var keysA = keys(objectA);
    var keysB = keys(objectB);

    if (keysA.length !== keysB.length) {
      return false;
    }

    var key;

    for (var index = 0; index < keysA.length; index++) {
      key = keysA[index];

      if (!hasValue(keysB, key, sameValueZeroEqual)) {
        return false;
      } // if a react element, ignore the "_owner" key because its not necessary for equality comparisons


      if (key === '_owner' && isReactElement(objectA) && isReactElement(objectB)) {
        continue;
      }

      if (!isEqual(objectA[key], objectB[key], meta)) {
        return false;
      }
    }

    return true;
  };
  /**
   * @function areRegExpsEqual
   *
   * @description
   * are the regExps equal in value
   *
   * @param {RegExp} regExpA the regExp to test
   * @param {RegExp} regExpB the regExp to test agains
   * @returns {boolean} are the regExps equal
   */

  var areRegExpsEqual = function areRegExpsEqual(regExpA, regExpB) {
    return regExpA.source === regExpB.source && regExpA.global === regExpB.global && regExpA.ignoreCase === regExpB.ignoreCase && regExpA.multiline === regExpB.multiline && regExpA.unicode === regExpB.unicode && regExpA.sticky === regExpB.sticky && regExpA.lastIndex === regExpB.lastIndex;
  };
  /**
   * @function areSetsEqual
   *
   * @description
   * are the sets equal in value
   *
   * @param {Set} setA the set to test
   * @param {Set} setB the set to test against
   * @param {function} isEqual the comparator to determine equality
   * @param {any} meta the meta set to pass through
   * @returns {boolean} are the sets equal
   */

  var areSetsEqual = function areSetsEqual(setA, setB, isEqual, meta) {
    var valuesA = toValues(setA);
    var valuesB = toValues(setB);

    if (valuesA.length !== valuesB.length) {
      return false;
    }

    for (var index = 0; index < valuesA.length; index++) {
      if (!hasValue(valuesB, valuesA[index], isEqual, meta) || !hasValue(valuesA, valuesB[index], isEqual, meta)) {
        return false;
      }
    }

    return true;
  };

  // constants
  var isArray = Array.isArray;

  var createComparator = function createComparator(createIsEqual) {
    // eslint-disable-next-line no-use-before-define
    var isEqual = typeof createIsEqual === 'function' ? createIsEqual(comparator) : comparator;
    /**
     * @function comparator
     *
     * @description
     * compare the value of the two objects and return true if they are equivalent in values
     *
     * @param {any} objectA the object to test against
     * @param {any} objectB the object to test
     * @param {any} [meta] an optional meta object that is passed through to all equality test calls
     * @returns {boolean} are objectA and objectB equivalent in value
     */

    function comparator(objectA, objectB, meta) {
      if (sameValueZeroEqual(objectA, objectB)) {
        return true;
      }

      var typeOfA = typeof objectA;

      if (typeOfA !== typeof objectB || typeOfA !== 'object' || !objectA || !objectB) {
        return false;
      }

      if (isPlainObject(objectA) && isPlainObject(objectB)) {
        return areObjectsEqual(objectA, objectB, isEqual, meta);
      }

      var arrayA = isArray(objectA);
      var arrayB = isArray(objectB);

      if (arrayA || arrayB) {
        return arrayA === arrayB && areArraysEqual(objectA, objectB, isEqual, meta);
      }

      var dateA = objectA instanceof Date;
      var dateB = objectB instanceof Date;

      if (dateA || dateB) {
        return dateA === dateB && sameValueZeroEqual(objectA.getTime(), objectB.getTime());
      }

      var regexpA = objectA instanceof RegExp;
      var regexpB = objectB instanceof RegExp;

      if (regexpA || regexpB) {
        return regexpA === regexpB && areRegExpsEqual(objectA, objectB);
      }

      if (isPromiseLike(objectA) || isPromiseLike(objectB)) {
        return objectA === objectB;
      }

      if (HAS_MAP_SUPPORT) {
        var mapA = objectA instanceof Map;
        var mapB = objectB instanceof Map;

        if (mapA || mapB) {
          return mapA === mapB && areMapsEqual(objectA, objectB, isEqual, meta);
        }
      }

      if (HAS_SET_SUPPORT) {
        var setA = objectA instanceof Set;
        var setB = objectB instanceof Set;

        if (setA || setB) {
          return setA === setB && areSetsEqual(objectA, objectB, isEqual, meta);
        }
      }

      return areObjectsEqual(objectA, objectB, isEqual, meta);
    }

    return comparator;
  };

  // comparator
  var circularDeepEqual = createComparator(createCircularEqual());
  var circularShallowEqual = createComparator(createCircularEqual(sameValueZeroEqual));
  var deepEqual = createComparator();
  var shallowEqual = createComparator(function () {
    return sameValueZeroEqual;
  });

  var createGetInitialArgs = function createGetInitialArgs(size
  /**
   * @private
   *
   * @function getInitialArgs
   *
   * @description
   * take the first N number of items from the array (faster than slice)
   *
   * @param {Array<any>} args the args to take from
   * @returns {Array<any>} the shortened list of args as an array
   */
  ) {
    return function (args) {
      if (size >= args.length) {
        return args;
      }

      switch (size) {
        case 0:
          return [];

        case 1:
          return [args[0]];

        case 2:
          return [args[0], args[1]];

        case 3:
          return [args[0], args[1], args[2]];

        case 4:
          return [args[0], args[1], args[2], args[3]];

        case 5:
          return [args[0], args[1], args[2], args[3], args[4]];
      }

      return Array.prototype.slice.call(args, 0, size);
    };
  };

  /**
   * @function first
   *
   * @description
   * get the first n number of items from the array as a new array (faster than native splice)
   *
   * @param {Array<any>} array the array to get the items from
   * @param {number} length the length to limit the size to
   * @returns {Array<any>} the array limited in size
   */
  var first = function first(array, length) {
    var newArray = new Array(length);

    for (var index = 0; index < length; index++) {
      newArray[index] = array[index];
    }

    return newArray;
  };
  /**
   * @function getCircularValue
   *
   * @description
   * create a method that will get a placeholder for the circular value based
   * on the value saved in the cache for it
   *
   * @param {any} key the key of the object to stringify
   * @param {any} value the value of the object at key
   * @param {number} refCount the index of the ref
   * @returns {string} the circular value
   */

  var getCircularValue = function getCircularValue(key, value, refCount) {
    return "[ref-" + refCount + "]";
  };
  /**
   * @function indexOf
   *
   * @description
   * get the index of the value in the array (faster than native indexOf)
   *
   * @param {Array<any>} array the array to get the index of the value at
   * @param {any} value the value to match
   * @returns {number} the index of the value in array
   */

  var indexOf = function indexOf(array, value) {
    for (var index = 0; index < array.length; index++) {
      if (array[index] === value) {
        return index;
      }
    }

    return -1;
  };
  /**
   * @function createReplacer
   *
   * @description
   * create a replacer method that handles circular values
   *
   * @param {function} [replacer] a custom replacer to use for non-circular values
   * @param {function} [circularReplacer] a custom replacer to use for circular methods
   * @returns {any} the value to stringify
   */

  var createReplacer = function createReplacer(replacer, circularReplacer) {
    var getCircularReplacer = circularReplacer || getCircularValue;
    var hasReplacer = typeof replacer === 'function';
    var cache = [],
        locationOfThis,
        locationOfValue;
    return function (key, value) {
      if (cache.length) {
        locationOfThis = indexOf(cache, this);

        if (~locationOfThis) {
          cache = first(cache, locationOfThis + 1);
        } else {
          cache[cache.length] = this;
        }

        locationOfValue = indexOf(cache, value);

        if (~locationOfValue) {
          return getCircularReplacer.call(this, key, value, locationOfValue);
        }
      } else {
        cache[0] = value;
      }

      return hasReplacer ? replacer.call(this, key, value) : value;
    };
  };

  // utils
  /**
   * @function stringify
   *
   * @description
   * strinigifer that handles circular values
   *
   * @param {any} value the value to stringify
   * @param {function} [replacer] a custom replacer function for stringifying standard values
   * @param {number} [indent] the number of spaces to indent the output by
   * @param {function} [circularReplacer] a custom replacer function for stringifying circular values
   * @returns {string} the stringified output
   */

  function stringify(value, replacer, indent, circularReplacer) {
    return JSON.stringify(value, createReplacer(replacer, circularReplacer), indent);
  }

  // external dependencies
  /**
   * @private
   *
   * @function customReplacer
   *
   * @description
   * custom replacer for the stringify function
   *
   * @param {string} key key in json object
   * @param {*} value value in json object
   * @returns {*} if function then toString of it, else the value itself
   */

  var customReplacer = function customReplacer(key, value) {
    return typeof value === 'function' ? "" + value : value;
  };
  /**
   * @private
   *
   * @function stringify
   *
   * @description
   * stringify with a custom replacer if circular, else use standard JSON.stringify
   *
   * @param {*} value value to stringify
   * @param {function} [replacer] replacer to used in stringification
   * @returns {string} the stringified version of value
   */

  var stringify$1 = function stringify$1(value, replacer) {
    try {
      return JSON.stringify(value, replacer);
    } catch (exception) {
      return stringify(value, replacer);
    }
  };
  /**
   * @private
   *
   * @function getStringifiedArgument
   *
   * @description
   * get the stringified version of the argument passed
   *
   * @param {*} arg argument to stringify
   * @param {function} [replacer] replacer to used in stringification
   * @returns {string} the stringified argument
   */

  var getStringifiedArgument = function getStringifiedArgument(arg, replacer) {
    var typeOfArg = typeof arg;
    return arg && (typeOfArg === 'object' || typeOfArg === 'function') ? stringify$1(arg, replacer) : arg;
  };
  /**
   * @private
   *
   * @function createArgumentSerializer
   *
   * @description
   * create the internal argument serializer based on the options passed
   *
   * @param {Options} options the options passed to the moizer
   * @param {boolean} options.serializeFunctions should functions be included in the serialization
   * @param {number} options.maxArgs the cap on the number of arguments used in serialization
   * @returns {function(...Array<*>): string} argument serialization method
   */

  var createArgumentSerializer = function createArgumentSerializer(options) {
    var replacer = options.shouldSerializeFunctions ? customReplacer : null;
    return function (args) {
      var key = '|';

      for (var index = 0; index < args.length; index++) {
        key += getStringifiedArgument(args[index], replacer) + "|";
      }

      return [key];
    };
  };
  /**
   * @private
   *
   * @function getSerializerFunction
   *
   * @description
   * based on the options passed, either use the serializer passed or generate the internal one
   *
   * @param {Options} options the options passed to the moized function
   * @returns {function} the function to use in serializing the arguments
   */

  var getSerializerFunction = function getSerializerFunction(options
  /* eslint-disable operator-linebreak */
  ) {
    return typeof options.serializer === 'function' ? // $FlowIgnore serializer is a function
    compose(getArrayKey, options.serializer) : createArgumentSerializer(options);
  };
  /* eslint-enable */

  /**
   * @private
   *
   * @function getIsSerializedKeyEqual
   *
   * @description
   * are the serialized keys equal to one another
   *
   * @param {Array<string>} cacheKey the cache key to compare
   * @param {*} key the key to test
   * @returns {boolean} are the keys equal
   */

  var getIsSerializedKeyEqual = function getIsSerializedKeyEqual(cacheKey, key) {
    return cacheKey[0] === key[0];
  };

  // external dependencies
  var createOnCacheOperation = function createOnCacheOperation(fn) {
    if (typeof fn === 'function') {
      return function (cache, _microMemoizeOptions, memoized // $FlowIgnore fn is a function if this is hit
      ) {
        return fn(memoized.cache, memoized.options, memoized);
      };
    }
  };
  /**
   * @private
   *
   * @function getIsEqual
   *
   * @description
   * get the isEqual method passed to micro-memoize
   *
   * @param {Options} options the options passed to the moizer
   * @returns {function} the isEqual method to apply
   */

  var getIsEqual = function getIsEqual(_ref) {
    var equals = _ref.equals,
        isDeepEqual = _ref.isDeepEqual,
        isReact = _ref.isReact;
    return equals || isDeepEqual && deepEqual || isReact && shallowEqual || sameValueZeroEqual;
  };
  /**
   * @private
   *
   * @function getIsMatchingKey
   *
   * @description
   * get the isEqual method passed to micro-memoize
   *
   * @param {Options} options the options passed to the moizer
   * @returns {function} the isEqual method to apply
   */

  var getIsMatchingKey = function getIsMatchingKey(_ref2) {
    var isSerialized = _ref2.isSerialized,
        matchesKey = _ref2.matchesKey;
    return matchesKey || isSerialized && getIsSerializedKeyEqual || undefined;
  };
  /**
   * @private
   *
   * @function getTransformKey
   *
   * @description
   * get the function that will transform the key based on the arguments passed
   *
   * @param {Options} options the options passed to the moizer
   * @returns {function|void} the function to transform the key with
   */

  var getTransformKey = function getTransformKey(options) {
    var maxArgs = options.maxArgs,
        isReact = options.isReact,
        isSerialized = options.isSerialized,
        transformArgs = options.transformArgs;
    return compose(isSerialized && getSerializerFunction(options), typeof transformArgs === 'function' && compose(getArrayKey, transformArgs), isReact && createGetInitialArgs(2), typeof maxArgs === 'number' && createGetInitialArgs(maxArgs));
  };

  /**
   * @function moize
   *
   * @description
   * memoize a function based its arguments passed, potentially improving runtime performance
   *
   * @example
   * import moize from 'moize';
   *
   * // standard implementation
   * const fn = (foo, bar) => `${foo} ${bar}`;
   * const memoizedFn = moize(fn);
   *
   * // implementation with options
   * const fn = async (id) => get(`http://foo.com/${id}`);
   * const memoizedFn = moize(fn, {isPromise: true, maxSize: 5});
   *
   * // implementation with convenience methods
   * const Foo = ({foo}) => <div>{foo}</div>;
   * const MemoizedFoo = moize.react(Foo);
   *
   * @param {function|Options} fn the function to memoized, or a list of options when currying
   * @param {Options} [options=DEFAULT_OPTIONS] the options to apply
   * @returns {function} the memoized function
   */

  function moize(fn, options) {
    if (options === void 0) {
      options = DEFAULT_OPTIONS;
    }

    if (fn.isMoized) {
      // $FlowIgnore if moized, originalFunction and options exist
      return moize(fn.originalFunction, mergeOptions(fn.options, options));
    }

    if (typeof fn === 'object') {
      return function (curriedFn
      /* eslint-disable operator-linebreak */
      , curriedOptions) {
        if (curriedOptions === void 0) {
          curriedOptions = {};
        }

        return typeof curriedFn === 'function' ? // $FlowIgnore fn is actually an object of options
        moize(curriedFn, mergeOptions(fn, curriedOptions)) : // $FlowIgnore fn is actually an object of options
        moize(mergeOptions(fn, curriedFn));
      };
      /* eslint-enable */
    }

    var coalescedOptions = Object.assign({}, DEFAULT_OPTIONS, options, {
      maxArgs: typeof options.maxArgs === 'number' && options.maxArgs >= 0 ? options.maxArgs : DEFAULT_OPTIONS.maxArgs,
      maxSize: typeof options.maxSize === 'number' && options.maxSize >= 0 ? options.maxSize : DEFAULT_OPTIONS.maxSize,
      profileName: options.profileName || getDefaultProfileName(fn)
    });
    var expirations = [];

    var equalsIgnored = coalescedOptions.equals,
        isDeepEqualIgnored = coalescedOptions.isDeepEqual,
        isPromise = coalescedOptions.isPromise,
        isReactIgnored = coalescedOptions.isReact,
        isSerialzedIgnored = coalescedOptions.isSerialized,
        matchesKeyIgnored = coalescedOptions.matchesKey,
        maxAgeIgnored = coalescedOptions.maxAge,
        maxArgsIgnored = coalescedOptions.maxArgs,
        maxSize = coalescedOptions.maxSize,
        onCacheAdd = coalescedOptions.onCacheAdd,
        onCacheChange = coalescedOptions.onCacheChange,
        onCacheHit = coalescedOptions.onCacheHit,
        onExpireIgnored = coalescedOptions.onExpire,
        profileNameIgnored = coalescedOptions.profileName,
        shouldSerializeFunctionsIgnored = coalescedOptions.shouldSerializeFunctions,
        serializerIgnored = coalescedOptions.serializer,
        transformArgsIgnored = coalescedOptions.transformArgs,
        updateExpireIgnored = coalescedOptions.updateExpire,
        customOptions = _objectWithoutPropertiesLoose(coalescedOptions, ["equals", "isDeepEqual", "isPromise", "isReact", "isSerialized", "matchesKey", "maxAge", "maxArgs", "maxSize", "onCacheAdd", "onCacheChange", "onCacheHit", "onExpire", "profileName", "shouldSerializeFunctions", "serializer", "transformArgs", "updateExpire"]);

    var isEqual = getIsEqual(coalescedOptions);
    var isMatchingKey = getIsMatchingKey(coalescedOptions);
    var maxAgeOptions = getMaxAgeOptions(expirations, coalescedOptions, isEqual, isMatchingKey);
    var statsOptions = getStatsOptions(coalescedOptions);
    var transformKey = getTransformKey(coalescedOptions);
    var microMemoizeOptions = Object.assign({}, customOptions, {
      isEqual: isEqual,
      isMatchingKey: isMatchingKey,
      isPromise: isPromise,
      maxSize: maxSize,
      onCacheAdd: createOnCacheOperation(combine(onCacheAdd, maxAgeOptions.onCacheAdd, statsOptions.onCacheAdd)),
      onCacheChange: createOnCacheOperation(onCacheChange),
      onCacheHit: createOnCacheOperation(combine(onCacheHit, maxAgeOptions.onCacheHit, statsOptions.onCacheHit)),
      transformKey: transformKey
    });
    return augmentMoizeInstance(memoize(fn, microMemoizeOptions), {
      expirations: expirations,
      options: coalescedOptions,
      originalFunction: fn
    });
  }
  /**
   * @function
   * @name collectStats
   * @memberof module:moize
   * @alias moize.collectStats
   *
   * @description
   * start collecting statistics
   */


  moize.collectStats = collectStats;
  /**
   * @function
   * @name compose
   * @memberof module:moize
   * @alias moize.compose
   *
   * @description
   * method to compose moized methods and return a single moized function
   *
   * @param {...Array<(function)>} functions the functions to compose
   * @returns {function(...Array<*>): *} the composed function
   */

  moize.compose = function () {
    // eslint-disable-next-line prefer-rest-params
    return compose.apply(null, arguments) || moize;
  };
  /**
   * @function
   * @name deep
   * @memberof module:moize
   * @alias moize.deep
   *
   * @description
   * should deep equality check be used
   *
   * @returns {function} the moizer function
   */


  moize.deep = moize({
    isDeepEqual: true
  });
  /**
   * @function
   * @name getStats
   * @memberof module:moize
   * @alias moize.getStats
   *
   * @description
   * get the statistics of a given profile, or overall usage
   *
   * @returns {StatsProfile} statistics for a given profile or overall usage
   */

  moize.getStats = getStats;
  /**
   * @function
   * @name isCollectingStats
   * @memberof module:moize
   * @alias moize.isCollectingStats
   *
   * @description
   * are stats being collected
   *
   * @returns {boolean} are stats being collected
   */

  moize.isCollectingStats = function isCollectingStats() {
    return statsCache.isCollectingStats;
  };
  /**
   * @function
   * @name isMoized
   * @memberof module:moize
   * @alias moize.isMoized
   *
   * @description
   * is the fn passed a moized function
   *
   * @param {*} fn the object to test
   * @returns {boolean} is fn a moized function
   */


  moize.isMoized = function isMoized(fn) {
    return typeof fn === 'function' && !!fn.isMoized;
  };
  /**
   * @function
   * @name maxAge
   * @memberof module:moize
   * @alias moize.maxAge
   *
   * @description
   * a moized method where the age of the cache is limited to the number of milliseconds passed
   *
   * @param {number} maxAge the TTL of the value in cache
   * @returns {function} the moizer function
   */


  moize.maxAge = function maxAge(maxAge) {
    return moize({
      maxAge: maxAge
    });
  };
  /**
   * @function
   * @name maxArgs
   * @memberof module:moize
   * @alias moize.maxArgs
   *
   * @description
   * a moized method where the number of arguments used for determining cache is limited to the value passed
   *
   * @param {number} maxArgs the number of args to base the key on
   * @returns {function} the moizer function
   */


  moize.maxArgs = function maxArgs(maxArgs) {
    return moize({
      maxArgs: maxArgs
    });
  };
  /**
   * @function
   * @name maxSize
   * @memberof module:moize
   * @alias moize.maxSize
   *
   * @description
   * a moized method where the total size of the cache is limited to the value passed
   *
   * @param {number} maxSize the maximum size of the cache
   * @returns {function} the moizer function
   */


  moize.maxSize = function maxSize(maxSize) {
    return moize({
      maxSize: maxSize
    });
  };
  /**
   * @function
   * @name promise
   * @memberof module:moize
   * @alias moize.promise
   *
   * @description
   * a moized method specific to caching resolved promise / async values
   *
   * @returns {function} the moizer function
   */


  moize.promise = moize({
    isPromise: true,
    updateExpire: true
  });
  /**
   * @function
   * @name react
   * @memberof module:moize
   * @alias moize.react
   *
   * @description
   * a moized method specific to caching React element values
   *
   * @returns {function} the moizer function
   */

  moize.react = moize({
    isReact: true
  });
  /**
   * @function
   * @name reactSimple
   * @memberof module:moize
   * @alias moize.reactSimple
   *
   * @description
   * a moized method specific to caching React element values, limiting to only the most recent result
   *
   * @returns {function} the moizer function
   */

  moize.reactSimple = moize({
    isReact: true,
    maxSize: 1
  });
  /**
   * @function
   * @name serialize
   * @memberof module:moize
   * @alias moize.serialize
   *
   * @description
   * a moized method that will serialize the arguments passed to use as the cache key
   *
   * @returns {function} the moizer function
   */

  moize.serialize = moize({
    isSerialized: true
  });
  /**
   * @function
   * @name simple
   * @memberof module:moize
   * @alias moize.simple
   *
   * @description
   * a moized method that will limit the cache values to only the most recent result
   *
   * @returns {function} the moizer function
   */

  moize.simple = moize({
    maxSize: 1
  });

  exports.collectStats = collectStats;
  exports.default = moize;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=moize.js.map
