function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

// external dependencies
import memoize from "micro-memoize/mjs"; // constants

import { DEFAULT_OPTIONS } from './constants'; // instance

import { augmentMoizeInstance } from './instance'; // max age

import { getMaxAgeOptions } from './maxAge'; // options

import { createOnCacheOperation, getIsEqual, getIsMatchingKey, getTransformKey } from './options'; // stats

import { collectStats, getDefaultProfileName, getStats, getStatsOptions, statsCache } from './stats'; // types

// utils
import { combine, compose, mergeOptions } from './utils';
/**
 * @module moize
 */

export { collectStats };
/**
 * @function moize
 *
 * @description
 * memoize a function based its arguments passed, potentially improving runtime performance
 *
 * @example
 * import moize from 'moize';
 *
 * // standard implementation
 * const fn = (foo, bar) => `${foo} ${bar}`;
 * const memoizedFn = moize(fn);
 *
 * // implementation with options
 * const fn = async (id) => get(`http://foo.com/${id}`);
 * const memoizedFn = moize(fn, {isPromise: true, maxSize: 5});
 *
 * // implementation with convenience methods
 * const Foo = ({foo}) => <div>{foo}</div>;
 * const MemoizedFoo = moize.react(Foo);
 *
 * @param {function|Options} fn the function to memoized, or a list of options when currying
 * @param {Options} [options=DEFAULT_OPTIONS] the options to apply
 * @returns {function} the memoized function
 */

function moize(fn, options) {
  if (options === void 0) {
    options = DEFAULT_OPTIONS;
  }

  if (fn.isMoized) {
    // $FlowIgnore if moized, originalFunction and options exist
    return moize(fn.originalFunction, mergeOptions(fn.options, options));
  }

  if (typeof fn === 'object') {
    return function (curriedFn
    /* eslint-disable operator-linebreak */
    , curriedOptions) {
      if (curriedOptions === void 0) {
        curriedOptions = {};
      }

      return typeof curriedFn === 'function' ? // $FlowIgnore fn is actually an object of options
      moize(curriedFn, mergeOptions(fn, curriedOptions)) : // $FlowIgnore fn is actually an object of options
      moize(mergeOptions(fn, curriedFn));
    };
    /* eslint-enable */
  }

  var coalescedOptions = Object.assign({}, DEFAULT_OPTIONS, options, {
    maxArgs: typeof options.maxArgs === 'number' && options.maxArgs >= 0 ? options.maxArgs : DEFAULT_OPTIONS.maxArgs,
    maxSize: typeof options.maxSize === 'number' && options.maxSize >= 0 ? options.maxSize : DEFAULT_OPTIONS.maxSize,
    profileName: options.profileName || getDefaultProfileName(fn)
  });
  var expirations = [];

  var equalsIgnored = coalescedOptions.equals,
      isDeepEqualIgnored = coalescedOptions.isDeepEqual,
      isPromise = coalescedOptions.isPromise,
      isReactIgnored = coalescedOptions.isReact,
      isSerialzedIgnored = coalescedOptions.isSerialized,
      matchesKeyIgnored = coalescedOptions.matchesKey,
      maxAgeIgnored = coalescedOptions.maxAge,
      maxArgsIgnored = coalescedOptions.maxArgs,
      maxSize = coalescedOptions.maxSize,
      onCacheAdd = coalescedOptions.onCacheAdd,
      onCacheChange = coalescedOptions.onCacheChange,
      onCacheHit = coalescedOptions.onCacheHit,
      onExpireIgnored = coalescedOptions.onExpire,
      profileNameIgnored = coalescedOptions.profileName,
      shouldSerializeFunctionsIgnored = coalescedOptions.shouldSerializeFunctions,
      serializerIgnored = coalescedOptions.serializer,
      transformArgsIgnored = coalescedOptions.transformArgs,
      updateExpireIgnored = coalescedOptions.updateExpire,
      customOptions = _objectWithoutPropertiesLoose(coalescedOptions, ["equals", "isDeepEqual", "isPromise", "isReact", "isSerialized", "matchesKey", "maxAge", "maxArgs", "maxSize", "onCacheAdd", "onCacheChange", "onCacheHit", "onExpire", "profileName", "shouldSerializeFunctions", "serializer", "transformArgs", "updateExpire"]);

  var isEqual = getIsEqual(coalescedOptions);
  var isMatchingKey = getIsMatchingKey(coalescedOptions);
  var maxAgeOptions = getMaxAgeOptions(expirations, coalescedOptions, isEqual, isMatchingKey);
  var statsOptions = getStatsOptions(coalescedOptions);
  var transformKey = getTransformKey(coalescedOptions);
  var microMemoizeOptions = Object.assign({}, customOptions, {
    isEqual: isEqual,
    isMatchingKey: isMatchingKey,
    isPromise: isPromise,
    maxSize: maxSize,
    onCacheAdd: createOnCacheOperation(combine(onCacheAdd, maxAgeOptions.onCacheAdd, statsOptions.onCacheAdd)),
    onCacheChange: createOnCacheOperation(onCacheChange),
    onCacheHit: createOnCacheOperation(combine(onCacheHit, maxAgeOptions.onCacheHit, statsOptions.onCacheHit)),
    transformKey: transformKey
  });
  return augmentMoizeInstance(memoize(fn, microMemoizeOptions), {
    expirations: expirations,
    options: coalescedOptions,
    originalFunction: fn
  });
}
/**
 * @function
 * @name collectStats
 * @memberof module:moize
 * @alias moize.collectStats
 *
 * @description
 * start collecting statistics
 */


moize.collectStats = collectStats;
/**
 * @function
 * @name compose
 * @memberof module:moize
 * @alias moize.compose
 *
 * @description
 * method to compose moized methods and return a single moized function
 *
 * @param {...Array<(function)>} functions the functions to compose
 * @returns {function(...Array<*>): *} the composed function
 */

moize.compose = function () {
  // eslint-disable-next-line prefer-rest-params
  return compose.apply(null, arguments) || moize;
};
/**
 * @function
 * @name deep
 * @memberof module:moize
 * @alias moize.deep
 *
 * @description
 * should deep equality check be used
 *
 * @returns {function} the moizer function
 */


moize.deep = moize({
  isDeepEqual: true
});
/**
 * @function
 * @name getStats
 * @memberof module:moize
 * @alias moize.getStats
 *
 * @description
 * get the statistics of a given profile, or overall usage
 *
 * @returns {StatsProfile} statistics for a given profile or overall usage
 */

moize.getStats = getStats;
/**
 * @function
 * @name isCollectingStats
 * @memberof module:moize
 * @alias moize.isCollectingStats
 *
 * @description
 * are stats being collected
 *
 * @returns {boolean} are stats being collected
 */

moize.isCollectingStats = function isCollectingStats() {
  return statsCache.isCollectingStats;
};
/**
 * @function
 * @name isMoized
 * @memberof module:moize
 * @alias moize.isMoized
 *
 * @description
 * is the fn passed a moized function
 *
 * @param {*} fn the object to test
 * @returns {boolean} is fn a moized function
 */


moize.isMoized = function isMoized(fn) {
  return typeof fn === 'function' && !!fn.isMoized;
};
/**
 * @function
 * @name maxAge
 * @memberof module:moize
 * @alias moize.maxAge
 *
 * @description
 * a moized method where the age of the cache is limited to the number of milliseconds passed
 *
 * @param {number} maxAge the TTL of the value in cache
 * @returns {function} the moizer function
 */


moize.maxAge = function maxAge(maxAge) {
  return moize({
    maxAge: maxAge
  });
};
/**
 * @function
 * @name maxArgs
 * @memberof module:moize
 * @alias moize.maxArgs
 *
 * @description
 * a moized method where the number of arguments used for determining cache is limited to the value passed
 *
 * @param {number} maxArgs the number of args to base the key on
 * @returns {function} the moizer function
 */


moize.maxArgs = function maxArgs(maxArgs) {
  return moize({
    maxArgs: maxArgs
  });
};
/**
 * @function
 * @name maxSize
 * @memberof module:moize
 * @alias moize.maxSize
 *
 * @description
 * a moized method where the total size of the cache is limited to the value passed
 *
 * @param {number} maxSize the maximum size of the cache
 * @returns {function} the moizer function
 */


moize.maxSize = function maxSize(maxSize) {
  return moize({
    maxSize: maxSize
  });
};
/**
 * @function
 * @name promise
 * @memberof module:moize
 * @alias moize.promise
 *
 * @description
 * a moized method specific to caching resolved promise / async values
 *
 * @returns {function} the moizer function
 */


moize.promise = moize({
  isPromise: true,
  updateExpire: true
});
/**
 * @function
 * @name react
 * @memberof module:moize
 * @alias moize.react
 *
 * @description
 * a moized method specific to caching React element values
 *
 * @returns {function} the moizer function
 */

moize.react = moize({
  isReact: true
});
/**
 * @function
 * @name reactSimple
 * @memberof module:moize
 * @alias moize.reactSimple
 *
 * @description
 * a moized method specific to caching React element values, limiting to only the most recent result
 *
 * @returns {function} the moizer function
 */

moize.reactSimple = moize({
  isReact: true,
  maxSize: 1
});
/**
 * @function
 * @name serialize
 * @memberof module:moize
 * @alias moize.serialize
 *
 * @description
 * a moized method that will serialize the arguments passed to use as the cache key
 *
 * @returns {function} the moizer function
 */

moize.serialize = moize({
  isSerialized: true
});
/**
 * @function
 * @name simple
 * @memberof module:moize
 * @alias moize.simple
 *
 * @description
 * a moized method that will limit the cache values to only the most recent result
 *
 * @returns {function} the moizer function
 */

moize.simple = moize({
  maxSize: 1
});
export default moize;