// external dependencies
import stringifySafe from 'fast-stringify'; // types

// utils
import { compose, getArrayKey } from './utils';
/**
 * @private
 *
 * @function customReplacer
 *
 * @description
 * custom replacer for the stringify function
 *
 * @param {string} key key in json object
 * @param {*} value value in json object
 * @returns {*} if function then toString of it, else the value itself
 */

export var customReplacer = function customReplacer(key, value) {
  return typeof value === 'function' ? "" + value : value;
};
/**
 * @private
 *
 * @function stringify
 *
 * @description
 * stringify with a custom replacer if circular, else use standard JSON.stringify
 *
 * @param {*} value value to stringify
 * @param {function} [replacer] replacer to used in stringification
 * @returns {string} the stringified version of value
 */

export var stringify = function stringify(value, replacer) {
  try {
    return JSON.stringify(value, replacer);
  } catch (exception) {
    return stringifySafe(value, replacer);
  }
};
/**
 * @private
 *
 * @function getStringifiedArgument
 *
 * @description
 * get the stringified version of the argument passed
 *
 * @param {*} arg argument to stringify
 * @param {function} [replacer] replacer to used in stringification
 * @returns {string} the stringified argument
 */

export var getStringifiedArgument = function getStringifiedArgument(arg, replacer) {
  var typeOfArg = typeof arg;
  return arg && (typeOfArg === 'object' || typeOfArg === 'function') ? stringify(arg, replacer) : arg;
};
/**
 * @private
 *
 * @function createArgumentSerializer
 *
 * @description
 * create the internal argument serializer based on the options passed
 *
 * @param {Options} options the options passed to the moizer
 * @param {boolean} options.serializeFunctions should functions be included in the serialization
 * @param {number} options.maxArgs the cap on the number of arguments used in serialization
 * @returns {function(...Array<*>): string} argument serialization method
 */

export var createArgumentSerializer = function createArgumentSerializer(options) {
  var replacer = options.shouldSerializeFunctions ? customReplacer : null;
  return function (args) {
    var key = '|';

    for (var index = 0; index < args.length; index++) {
      key += getStringifiedArgument(args[index], replacer) + "|";
    }

    return [key];
  };
};
/**
 * @private
 *
 * @function getSerializerFunction
 *
 * @description
 * based on the options passed, either use the serializer passed or generate the internal one
 *
 * @param {Options} options the options passed to the moized function
 * @returns {function} the function to use in serializing the arguments
 */

export var getSerializerFunction = function getSerializerFunction(options
/* eslint-disable operator-linebreak */
) {
  return typeof options.serializer === 'function' ? // $FlowIgnore serializer is a function
  compose(getArrayKey, options.serializer) : createArgumentSerializer(options);
};
/* eslint-enable */

/**
 * @private
 *
 * @function getIsSerializedKeyEqual
 *
 * @description
 * are the serialized keys equal to one another
 *
 * @param {Array<string>} cacheKey the cache key to compare
 * @param {*} key the key to test
 * @returns {boolean} are the keys equal
 */

export var getIsSerializedKeyEqual = function getIsSerializedKeyEqual(cacheKey, key) {
  return cacheKey[0] === key[0];
};