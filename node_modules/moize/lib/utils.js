"use strict";

exports.__esModule = true;
exports.mergeOptions = exports.getArrayKey = exports.createFindKeyIndex = exports.findExpirationIndex = exports.compose = exports.combine = void 0;

var _constants = require("./constants");

// constants

/**
 * @private
 *
 * @function combine
 *
 * @description
 * method to combine functions and return a single function that fires them all
 *
 * @param {...Array<any>} functions the functions to compose
 * @returns {function(...Array<any>): any} the composed function
 */
var combine = function combine() {
  for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
    functions[_key] = arguments[_key];
  }

  if (functions.length) {
    return functions.reduce( // $FlowIgnore return value is always a function
    function (f, g) {
      return typeof f === 'function' ? typeof g === 'function' ? function () {
        // eslint-disable-next-line prefer-rest-params
        g.apply(this, arguments); // eslint-disable-next-line prefer-rest-params

        f.apply(this, arguments);
      } : f : typeof g === 'function' ? g : undefined;
    });
  }
};
/**
 * @private
 *
 * @function compose
 *
 * @description
 * method to compose functions and return a single function
 *
 * @param {...Array<any>} functions the functions to compose
 * @returns {function(...Array<any>): any} the composed function
 */


exports.combine = combine;

var compose = function compose() {
  for (var _len2 = arguments.length, functions = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    functions[_key2] = arguments[_key2];
  }

  if (functions.length) {
    return functions.reduce( // $FlowIgnore return value is always a function
    function (f, g) {
      return typeof f === 'function' ? typeof g === 'function' ? function () {
        // eslint-disable-next-line prefer-rest-params
        return f(g.apply(this, arguments));
      } : f : typeof g === 'function' ? g : undefined;
    });
  }
};
/**
 * @private
 *
 * @function findExpirationIndex
 *
 * @description
 * find the index of the expiration based on the key
 *
 * @param {Array<Expiration>} expirations the list of expirations
 * @param {Array<any>} key the key to match
 * @returns {number} the index of the expiration
 */


exports.compose = compose;

var findExpirationIndex = function findExpirationIndex(expirations, key) {
  for (var index = 0; index < expirations.length; index++) {
    if (expirations[index].key === key) {
      return index;
    }
  }

  return -1;
};

exports.findExpirationIndex = findExpirationIndex;

var createFindKeyIndex = function createFindKeyIndex(isEqual, isMatchingKey) {
  var areKeysEqual = typeof isMatchingKey === 'function' ? isMatchingKey : function (cacheKey, key) {
    for (var index = 0; index < key.length; index++) {
      if (!isEqual(cacheKey[index], key[index])) {
        return false;
      }
    }

    return true;
  };
  /**
   * @private
   *
   * @function findKeyIndex
   *
   * @description
   * find the index of the key in the list of cache keys
   *
   * @param {Array<Array<any>>} keys the list of keys in cache
   * @param {Array<any>} key the key to match
   * @returns {number} the index of the key
   */

  return function (keys, key) {
    for (var keysIndex = 0; keysIndex < keys.length; keysIndex++) {
      if (keys[keysIndex].length === key.length) {
        if (areKeysEqual(keys[keysIndex], key)) {
          return keysIndex;
        }
      }
    }

    return -1;
  };
};
/**
 * @private
 *
 * @function getArrayKey
 *
 * @description
 * return the transformed key as an array
 *
 * @param {any} key the transformed key
 * @returns {Array<any>} the key as an array
 */


exports.createFindKeyIndex = createFindKeyIndex;

var getArrayKey = function getArrayKey(key) {
  return Array.isArray(key) ? key : [key];
};
/**
 * @private
 *
 * @function mergeOptions
 *
 * @description
 * merge two options objects, combining or composing functions as necessary
 *
 * @param {Options} originalOptions the options that already exist on the method
 * @param {Options} newOptions the new options to merge
 * @returns {Options} the merged options
 */


exports.getArrayKey = getArrayKey;

var mergeOptions = function mergeOptions(originalOptions, newOptions) {
  return newOptions === _constants.DEFAULT_OPTIONS ? originalOptions : Object.assign({}, originalOptions, newOptions, {
    // $FlowIgnore undefined value is ok
    onCacheAdd: combine(originalOptions.onCacheAdd, newOptions.onCacheAdd),
    // $FlowIgnore undefined value is ok
    onCacheChange: combine(originalOptions.onCacheChange, newOptions.onCacheChange),
    // $FlowIgnore undefined value is ok
    onCacheHit: combine(originalOptions.onCacheHit, newOptions.onCacheHit),
    // $FlowIgnore undefined value is ok
    transformArgs: compose(originalOptions.transformArgs, newOptions.transformArgs)
  });
};

exports.mergeOptions = mergeOptions;