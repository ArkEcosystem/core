"use strict";

exports.__esModule = true;
exports.getIsSerializedKeyEqual = exports.getSerializerFunction = exports.createArgumentSerializer = exports.getStringifiedArgument = exports.stringify = exports.customReplacer = void 0;

var _fastStringify = _interopRequireDefault(require("fast-stringify"));

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// external dependencies
// utils

/**
 * @private
 *
 * @function customReplacer
 *
 * @description
 * custom replacer for the stringify function
 *
 * @param {string} key key in json object
 * @param {*} value value in json object
 * @returns {*} if function then toString of it, else the value itself
 */
var customReplacer = function customReplacer(key, value) {
  return typeof value === 'function' ? "" + value : value;
};
/**
 * @private
 *
 * @function stringify
 *
 * @description
 * stringify with a custom replacer if circular, else use standard JSON.stringify
 *
 * @param {*} value value to stringify
 * @param {function} [replacer] replacer to used in stringification
 * @returns {string} the stringified version of value
 */


exports.customReplacer = customReplacer;

var stringify = function stringify(value, replacer) {
  try {
    return JSON.stringify(value, replacer);
  } catch (exception) {
    return (0, _fastStringify.default)(value, replacer);
  }
};
/**
 * @private
 *
 * @function getStringifiedArgument
 *
 * @description
 * get the stringified version of the argument passed
 *
 * @param {*} arg argument to stringify
 * @param {function} [replacer] replacer to used in stringification
 * @returns {string} the stringified argument
 */


exports.stringify = stringify;

var getStringifiedArgument = function getStringifiedArgument(arg, replacer) {
  var typeOfArg = typeof arg;
  return arg && (typeOfArg === 'object' || typeOfArg === 'function') ? stringify(arg, replacer) : arg;
};
/**
 * @private
 *
 * @function createArgumentSerializer
 *
 * @description
 * create the internal argument serializer based on the options passed
 *
 * @param {Options} options the options passed to the moizer
 * @param {boolean} options.serializeFunctions should functions be included in the serialization
 * @param {number} options.maxArgs the cap on the number of arguments used in serialization
 * @returns {function(...Array<*>): string} argument serialization method
 */


exports.getStringifiedArgument = getStringifiedArgument;

var createArgumentSerializer = function createArgumentSerializer(options) {
  var replacer = options.shouldSerializeFunctions ? customReplacer : null;
  return function (args) {
    var key = '|';

    for (var index = 0; index < args.length; index++) {
      key += getStringifiedArgument(args[index], replacer) + "|";
    }

    return [key];
  };
};
/**
 * @private
 *
 * @function getSerializerFunction
 *
 * @description
 * based on the options passed, either use the serializer passed or generate the internal one
 *
 * @param {Options} options the options passed to the moized function
 * @returns {function} the function to use in serializing the arguments
 */


exports.createArgumentSerializer = createArgumentSerializer;

var getSerializerFunction = function getSerializerFunction(options
/* eslint-disable operator-linebreak */
) {
  return typeof options.serializer === 'function' ? // $FlowIgnore serializer is a function
  (0, _utils.compose)(_utils.getArrayKey, options.serializer) : createArgumentSerializer(options);
};
/* eslint-enable */

/**
 * @private
 *
 * @function getIsSerializedKeyEqual
 *
 * @description
 * are the serialized keys equal to one another
 *
 * @param {Array<string>} cacheKey the cache key to compare
 * @param {*} key the key to test
 * @returns {boolean} are the keys equal
 */


exports.getSerializerFunction = getSerializerFunction;

var getIsSerializedKeyEqual = function getIsSerializedKeyEqual(cacheKey, key) {
  return cacheKey[0] === key[0];
};

exports.getIsSerializedKeyEqual = getIsSerializedKeyEqual;