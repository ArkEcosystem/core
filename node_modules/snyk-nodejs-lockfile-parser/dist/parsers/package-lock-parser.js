"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var _ = require("lodash");
var graphlib = require("graphlib");
var uuid = require("uuid/v4");
var set_immediate_promise_1 = require("../set-immediate-promise");
var _1 = require("./");
var errors_1 = require("../errors");
var PackageLockParser = /** @class */ (function () {
    function PackageLockParser() {
        // package names must not contain URI unsafe characters, so one of them is
        // a good delimiter (https://www.ietf.org/rfc/rfc1738.txt)
        this.pathDelimiter = '|';
    }
    PackageLockParser.prototype.parseLockFile = function (lockFileContents) {
        try {
            var packageLock = JSON.parse(lockFileContents);
            packageLock.type = _1.LockfileType.npm;
            return packageLock;
        }
        catch (e) {
            throw new errors_1.InvalidUserInputError('package-lock.json parsing failed with ' +
                ("error " + e.message));
        }
    };
    PackageLockParser.prototype.getDependencyTree = function (manifestFile, lockfile, includeDev, strict) {
        if (includeDev === void 0) { includeDev = false; }
        if (strict === void 0) { strict = true; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var packageLock, depTree, nodeVersion, depMap, depGraph, cycleStarts, cycles, _i, cycles_1, cycle, _a, depTrees, depTreesSizes, topLevelDeps, treeSize, _b, topLevelDeps_1, dep, depName;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (lockfile.type !== _1.LockfileType.npm) {
                            throw new errors_1.InvalidUserInputError('Unsupported lockfile provided. Please ' +
                                'provide `package-lock.json`.');
                        }
                        packageLock = lockfile;
                        depTree = {
                            dependencies: {},
                            hasDevDependencies: !_.isEmpty(manifestFile.devDependencies),
                            name: manifestFile.name,
                            size: 1,
                            version: manifestFile.version || '',
                        };
                        nodeVersion = _.get(manifestFile, 'engines.node');
                        if (nodeVersion) {
                            _.set(depTree, 'meta.nodeVersion', nodeVersion);
                        }
                        // asked to process empty deps
                        if (_.isEmpty(manifestFile.dependencies) && !includeDev) {
                            return [2 /*return*/, depTree];
                        }
                        depMap = this.flattenLockfile(packageLock);
                        depGraph = this.createGraphOfDependencies(depMap);
                        cycleStarts = {};
                        if (!graphlib.alg.isAcyclic(depGraph)) {
                            cycles = graphlib.alg.findCycles(depGraph);
                            for (_i = 0, cycles_1 = cycles; _i < cycles_1.length; _i++) {
                                cycle = cycles_1[_i];
                                // Since one of top level dependencies can be a start of cycle and that node
                                // will be duplicated, we need to store a link between original node
                                // and the new one in order to identify those duplicated top level dependencies
                                cycleStarts = tslib_1.__assign({}, cycleStarts, this.removeCycle(cycle, depMap, depGraph));
                            }
                        }
                        return [4 /*yield*/, this.createDepTrees(depMap, depGraph)];
                    case 1:
                        _a = _c.sent(), depTrees = _a.depTrees, depTreesSizes = _a.depTreesSizes;
                        topLevelDeps = _1.getTopLevelDeps(manifestFile, includeDev);
                        treeSize = 1;
                        _b = 0, topLevelDeps_1 = topLevelDeps;
                        _c.label = 2;
                    case 2:
                        if (!(_b < topLevelDeps_1.length)) return [3 /*break*/, 6];
                        dep = topLevelDeps_1[_b];
                        depName = cycleStarts[dep.name] || dep.name;
                        if (!depTrees[depName]) return [3 /*break*/, 4];
                        // if the top level dependency is dev, all children are dev
                        depTree.dependencies[dep.name] = dep.dev ?
                            this.setDevDepRec(_.cloneDeep(depTrees[depName])) : depTrees[depName];
                        treeSize += depTreesSizes[depName];
                        return [4 /*yield*/, set_immediate_promise_1.setImmediatePromise()];
                    case 3:
                        _c.sent();
                        return [3 /*break*/, 5];
                    case 4:
                        if (/^file:/.test(dep.version)) {
                            depTree.dependencies[dep.name] = _1.createPkgTreeFromDep(dep);
                            treeSize++;
                        }
                        else {
                            // TODO: also check the package version
                            // for a stricter check
                            if (strict) {
                                throw new errors_1.OutOfSyncError(depName, 'npm');
                            }
                            depTree.dependencies[dep.name] = _1.createPkgTreeFromDep(dep);
                            depTree.dependencies[dep.name].missingLockFileEntry = true;
                            treeSize++;
                        }
                        _c.label = 5;
                    case 5:
                        _b++;
                        return [3 /*break*/, 2];
                    case 6:
                        depTree.size = treeSize;
                        return [2 /*return*/, depTree];
                }
            });
        });
    };
    PackageLockParser.prototype.setDevDepRec = function (pkgTree) {
        for (var _i = 0, _a = _.entries(pkgTree.dependencies); _i < _a.length; _i++) {
            var _b = _a[_i], name = _b[0], subTree = _b[1];
            pkgTree.dependencies[name] = this.setDevDepRec(subTree);
        }
        pkgTree.labels = {
            scope: _1.Scope.dev,
        };
        return pkgTree;
    };
    /* Algorithm for cycle removal:
      For every node in a cycle:
        1. Create a duplicate of entry node (without edges)
        2. For every cyclic dependency of entry node, create a duplicate of
            the dependency and connect it with the duplicated entry node
        3.a If edge goes to already-visited dependency, end of cycle is found;
            update metadata and do not continue traversing
        3.b Follow the edge and repeat the process, storing visited dependency-paths.
            All non-cyclic dependencies of duplicated node need to be updated.
        4. All non-cyclic dependencies or dependants of original node need to be
          updated to be connected with the duplicated one
  
      Once completed for all nodes in a cycle, original cyclic nodes can
      be removed.
    */
    PackageLockParser.prototype.removeCycle = function (cycle, depMap, depGraph) {
        var _this = this;
        /* FUNCTION DEFINITION
        To keep an order of algorithm steps readable, function is defined on-the-fly
        Arrow function is used for calling `this` without .bind(this) in the end
        */
        var acyclicDuplicationRec = function (node, traversed, currentCycle, nodeCopy) {
            // 2. For every cyclic dependency of entry node...
            var edgesToProcess = depGraph.inEdges(node)
                .filter(function (e) { return _.includes(currentCycle, e.v); });
            for (var _i = 0, edgesToProcess_1 = edgesToProcess; _i < edgesToProcess_1.length; _i++) {
                var edge = edgesToProcess_1[_i];
                // ... create a duplicate of the dependency...
                var child = edge.v;
                var dependencyCopy = _this.cloneNodeWithoutEdges(child, depMap, depGraph);
                // ...and connect it with the duplicated entry node
                depGraph.setEdge(dependencyCopy, nodeCopy);
                // 3.a If edge goes to already-visited dependency, end of cycle is found;
                if (_.includes(traversed, child)) {
                    // update metadata and labels and do not continue traversing
                    depMap[dependencyCopy].cyclic = true;
                    if (!depMap[dependencyCopy].labels) {
                        depMap[dependencyCopy].labels = {};
                    }
                    depMap[dependencyCopy].labels.pruned = 'cyclic';
                }
                else {
                    // 3.b Follow the edge and repeat the process, storing visited dependency-paths
                    acyclicDuplicationRec(child, traversed.concat([node]), currentCycle, dependencyCopy);
                    // All non-cyclic dependencies of duplicated node need to be updated.
                    _this.cloneAcyclicNodeEdges(child, dependencyCopy, cycle, depGraph, { inEdges: true, outEdges: false });
                }
            }
        };
        var cycleStarts = {};
        // For every node in a cycle:
        for (var _i = 0, cycle_1 = cycle; _i < cycle_1.length; _i++) {
            var start = cycle_1[_i];
            // 1. Create a uniqe duplicate of entry node (without edges)
            var clonedNode = this.cloneNodeWithoutEdges(start, depMap, depGraph);
            cycleStarts[start] = clonedNode;
            // CALL of previously defined function
            acyclicDuplicationRec(start, [], cycle, clonedNode);
            // 4. All non-cyclic dependencies or dependants of original node need to be
            //   updated to be connected with the duplicated one
            this.cloneAcyclicNodeEdges(start, clonedNode, cycle, depGraph, { inEdges: true, outEdges: true });
        }
        // Once completed for all nodes in a cycle, original cyclic nodes can
        // be removed.
        for (var _a = 0, cycle_2 = cycle; _a < cycle_2.length; _a++) {
            var start = cycle_2[_a];
            depGraph.removeNode(start);
        }
        return cycleStarts;
    };
    PackageLockParser.prototype.cloneAcyclicNodeEdges = function (nodeFrom, nodeTo, cycle, depGraph, _a) {
        var inEdges = _a.inEdges, outEdges = _a.outEdges;
        // node has to have edges
        var edges = depGraph.nodeEdges(nodeFrom);
        if (outEdges) {
            var parentEdges = edges.filter(function (e) { return !_.includes(cycle, e.w); });
            for (var _i = 0, parentEdges_1 = parentEdges; _i < parentEdges_1.length; _i++) {
                var edge = parentEdges_1[_i];
                var parent = edge.w;
                depGraph.setEdge(nodeTo, parent);
            }
        }
        if (inEdges) {
            var childEdges = edges.filter(function (e) { return !_.includes(cycle, e.v); });
            for (var _b = 0, childEdges_1 = childEdges; _b < childEdges_1.length; _b++) {
                var edge = childEdges_1[_b];
                var child = edge.v;
                depGraph.setEdge(child, nodeTo);
            }
        }
    };
    PackageLockParser.prototype.cloneNodeWithoutEdges = function (node, depMap, depGraph) {
        var newNode = node + uuid();
        // update depMap with new node
        depMap[newNode] = _.cloneDeep(depMap[node]);
        // add new node to the graph
        depGraph.setNode(newNode);
        return newNode;
    };
    PackageLockParser.prototype.createGraphOfDependencies = function (depMap) {
        var depGraph = new graphlib.Graph();
        for (var _i = 0, _a = Object.keys(depMap); _i < _a.length; _i++) {
            var depKey = _a[_i];
            depGraph.setNode(depKey);
        }
        for (var _b = 0, _c = _.entries(depMap); _b < _c.length; _b++) {
            var _d = _c[_b], depPath = _d[0], dep = _d[1];
            for (var _e = 0, _f = dep.requires; _e < _f.length; _e++) {
                var depName = _f[_e];
                var subDepPath = this.findDepsPath(depPath, depName, depMap);
                // direction is from the dependency to the package requiring it
                depGraph.setEdge(subDepPath, depPath);
            }
        }
        return depGraph;
    };
    // dependency in package-lock.json v1 can be defined either inside `dependencies`
    // of other dependency or anywhere upward towards root
    PackageLockParser.prototype.findDepsPath = function (startPath, depName, depMap) {
        var depPath = startPath.split(this.pathDelimiter);
        while (depPath.length) {
            var currentPath = depPath.concat(depName).join(this.pathDelimiter);
            if (depMap[currentPath]) {
                return currentPath;
            }
            depPath.pop();
        }
        if (!depMap[depName]) {
            throw new errors_1.OutOfSyncError(depName, 'npm');
        }
        return depName;
    };
    // Algorithm is based on dynamic programming technique and tries to build
    // "more simple" trees and compose them into bigger ones.
    PackageLockParser.prototype.createDepTrees = function (depMap, depGraph) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var depTrees, depTreesSizes, depOrder, depKey, dep, treeSize, _i, _a, subDepPath, subDep, pkgTree;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        // Graph has to be acyclic
                        if (!graphlib.alg.isAcyclic(depGraph)) {
                            throw new Error('Cycles were not removed from graph.');
                        }
                        depTrees = {};
                        depTreesSizes = {};
                        depOrder = graphlib.alg.topsort(depGraph);
                        _b.label = 1;
                    case 1:
                        if (!depOrder.length) return [3 /*break*/, 3];
                        depKey = depOrder.shift();
                        dep = depMap[depKey];
                        treeSize = 1;
                        // direction is from the dependency to the package requiring it, so we are
                        // looking for predecessors
                        for (_i = 0, _a = depGraph.predecessors(depKey); _i < _a.length; _i++) {
                            subDepPath = _a[_i];
                            subDep = depTrees[subDepPath];
                            dep.dependencies[subDep.name] = subDep;
                            treeSize += depTreesSizes[subDepPath];
                        }
                        pkgTree = {
                            dependencies: dep.dependencies,
                            labels: dep.labels,
                            name: dep.name,
                            version: dep.version,
                        };
                        if (dep.cyclic) {
                            pkgTree.cyclic = dep.cyclic;
                        }
                        if (dep.hasDevDependencies) {
                            pkgTree.hasDevDependencies = dep.hasDevDependencies;
                        }
                        depTrees[depKey] = pkgTree;
                        depTreesSizes[depKey] = treeSize;
                        // Since this code doesn't handle any I/O or network, we need to force
                        // event loop to tick while being used in server for request processing
                        return [4 /*yield*/, set_immediate_promise_1.setImmediatePromise()];
                    case 2:
                        // Since this code doesn't handle any I/O or network, we need to force
                        // event loop to tick while being used in server for request processing
                        _b.sent();
                        return [3 /*break*/, 1];
                    case 3: return [2 /*return*/, { depTrees: depTrees, depTreesSizes: depTreesSizes }];
                }
            });
        });
    };
    PackageLockParser.prototype.flattenLockfile = function (lockfile) {
        var _this = this;
        var depMap = {};
        var flattenLockfileRec = function (lockfileDeps, path) {
            for (var _i = 0, _a = _.entries(lockfileDeps); _i < _a.length; _i++) {
                var _b = _a[_i], depName = _b[0], dep = _b[1];
                var depNode = {
                    dependencies: {},
                    labels: {
                        scope: dep.dev ? _1.Scope.dev : _1.Scope.prod,
                    },
                    name: depName,
                    requires: [],
                    version: dep.version,
                };
                if (dep.requires) {
                    depNode.requires = Object.keys(dep.requires);
                }
                var depPath = path.concat([depName]);
                var depKey = depPath.join(_this.pathDelimiter);
                depMap[depKey] = depNode;
                if (dep.dependencies) {
                    flattenLockfileRec(dep.dependencies, depPath);
                }
            }
        };
        flattenLockfileRec(lockfile.dependencies || {}, []);
        return depMap;
    };
    return PackageLockParser;
}());
exports.PackageLockParser = PackageLockParser;
//# sourceMappingURL=package-lock-parser.js.map