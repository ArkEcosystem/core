"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const docker_1 = require("../docker");
function detect(targetImage, dockerfileAnalysis, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const docker = new docker_1.Docker(targetImage, options);
        let osRelease = yield tryOSRelease(docker);
        // First generic fallback
        if (!osRelease) {
            osRelease = yield tryLSBRelease(docker);
        }
        // Fallbacks for specific older distributions
        if (!osRelease) {
            osRelease = yield tryDebianVersion(docker);
        }
        if (!osRelease) {
            osRelease = yield tryAlpineRelease(docker);
        }
        if (!osRelease) {
            osRelease = yield tryOracleRelease(docker);
        }
        if (!osRelease) {
            osRelease = yield tryRedHatRelease(docker);
        }
        if (!osRelease) {
            if (dockerfileAnalysis && dockerfileAnalysis.baseImage === "scratch") {
                // If the docker file was build from a scratch image
                // then we don't have a known OS
                osRelease = { name: "scratch", version: "0.0" };
            }
            else {
                throw new Error("Failed to detect OS release");
            }
        }
        // Oracle Linux identifies itself as "ol"
        if (osRelease.name.trim() === "ol") {
            osRelease.name = "oracle";
        }
        return osRelease;
    });
}
exports.detect = detect;
function tryOSRelease(docker) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const text = yield tryRelease(docker, "/etc/os-release");
        if (!text) {
            return null;
        }
        const idRes = text.match(/^ID=(.+)$/m);
        if (!idRes) {
            throw new Error("Failed to parse /etc/os-release");
        }
        const name = idRes[1].replace(/"/g, "");
        const versionRes = text.match(/^VERSION_ID=(.+)$/m);
        let version = versionRes ? versionRes[1].replace(/"/g, "") : "unstable";
        if (name === "ol") {
            version = version.split(".")[0];
        }
        return { name, version };
    });
}
function tryLSBRelease(docker) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const text = yield tryRelease(docker, "/etc/lsb-release");
        if (!text) {
            return null;
        }
        const idRes = text.match(/^DISTRIB_ID=(.+)$/m);
        const versionRes = text.match(/^DISTRIB_RELEASE=(.+)$/m);
        if (!idRes || !versionRes) {
            throw new Error("Failed to parse /etc/lsb-release");
        }
        const name = idRes[1].replace(/"/g, "").toLowerCase();
        const version = versionRes[1].replace(/"/g, "");
        return { name, version };
    });
}
function tryDebianVersion(docker) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let text = yield tryRelease(docker, "/etc/debian_version");
        if (!text) {
            return null;
        }
        text = text.trim();
        if (text.length < 2) {
            throw new Error("Failed to parse /etc/debian_version");
        }
        return { name: "debian", version: text.split(".")[0] };
    });
}
function tryAlpineRelease(docker) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let text = yield tryRelease(docker, "/etc/alpine-release");
        if (!text) {
            return null;
        }
        text = text.trim();
        if (text.length < 2) {
            throw new Error("Failed to parse /etc/alpine-release");
        }
        return { name: "alpine", version: text };
    });
}
function tryRedHatRelease(docker) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const text = yield tryRelease(docker, "/etc/redhat-release");
        if (!text) {
            return null;
        }
        const idRes = text.match(/^(\S+)/m);
        const versionRes = text.match(/(\d+)\./m);
        if (!idRes || !versionRes) {
            throw new Error("Failed to parse /etc/redhat-release");
        }
        const name = idRes[1].replace(/"/g, "").toLowerCase();
        const version = versionRes[1].replace(/"/g, "");
        return { name, version };
    });
}
function tryOracleRelease(docker) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const text = yield tryRelease(docker, "/etc/oracle-release");
        if (!text) {
            return null;
        }
        const idRes = text.match(/^(\S+)/m);
        const versionRes = text.match(/(\d+\.\d+)/m);
        if (!idRes || !versionRes) {
            throw new Error("Failed to parse /etc/oracle-release");
        }
        const name = idRes[1].replace(/"/g, "").toLowerCase();
        const version = versionRes[1].replace(/"/g, "").split(".")[0];
        return { name, version };
    });
}
function tryRelease(docker, release) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            return (yield docker.catSafe(release)).stdout;
        }
        catch (error) {
            throw new Error(error.stderr);
        }
    });
}
//# sourceMappingURL=os-release-detector.js.map