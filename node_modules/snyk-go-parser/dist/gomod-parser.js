"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var errors_1 = require("./errors");
// go.mod file format:
// https://tip.golang.org/cmd/go/#hdr-The_go_mod_file
// See https://tip.golang.org/cmd/go/#hdr-Pseudo_versions
// Subgroups: baseVersion, suffix, timestamp, hash
var rePseudoVersion = /(v\d+\.\d+\.\d+)-(.*?)(\d{14})-([0-9a-f]{12})/;
var reIndirect = /\/\/ indirect/;
var reExactVersion = /^(.*?)(\+incompatible)?$/;
var reStatementWord = /^(module|go|require|replace|exclude) (\(?)/;
var reLineWithComments = /^(.*?)(\/\/.*)?$/;
function parseModuleAndMaybeVersion(lineRemainder) {
    var _a = tslib_1.__read(lineRemainder.trim().split(' '), 2), moduleName = _a[0], versionString = _a[1];
    if (!versionString) {
        return { moduleName: moduleName };
    }
    return { moduleName: moduleName, version: parseVersion(versionString) };
}
function parseModuleAndVersion(lineRemainder) {
    var _a = tslib_1.__read(lineRemainder.trim().split(' '), 2), moduleName = _a[0], versionString = _a[1];
    if (!moduleName || !versionString) {
        throw new Error("could not split \"" + lineRemainder + "\" into moduleName and version");
    }
    return { moduleName: moduleName, version: parseVersion(versionString) };
}
function parseVersion(versionString) {
    var maybeRegexMatch = rePseudoVersion.exec(versionString);
    if (maybeRegexMatch) {
        var _a = tslib_1.__read(maybeRegexMatch.slice(1), 4), baseVersion = _a[0], suffix = _a[1], timestamp = _a[2], hash = _a[3];
        return { baseVersion: baseVersion, suffix: suffix, timestamp: timestamp, hash: hash };
    }
    else {
        // No pseudo version recognized, assuming the provided version string is exact
        var _b = tslib_1.__read(reExactVersion.exec(versionString).slice(1), 2), exactVersion = _b[0], incompatibleStr = _b[1];
        return { exactVersion: exactVersion, incompatible: !!incompatibleStr };
    }
}
exports.parseVersion = parseVersion;
// Takes the current parser state and an input line;
// returns the new parser state and the line remainder to be processed
// according to the current directive (verb).
function updateParserState(line, state) {
    if (!state.inMultilineDirective) {
        var maybeStatement = reStatementWord.exec(line);
        if (maybeStatement) {
            var currentVerb = maybeStatement[1];
            var inMultilineDirective = !!maybeStatement[2]; // whether we found "("
            if (inMultilineDirective) {
                return { inMultilineDirective: inMultilineDirective, currentVerb: currentVerb, lineRemainder: null };
            }
            else {
                return { inMultilineDirective: inMultilineDirective, currentVerb: currentVerb,
                    lineRemainder: line.substr(currentVerb.length + 1).trim() };
            }
        }
        else {
            var lineNoComment = reLineWithComments.exec(line)[1].trim();
            if (lineNoComment) {
                throw new Error('Unrecognized statement: ' + line);
            }
            return { inMultilineDirective: false, currentVerb: null, lineRemainder: null };
        }
    }
    else if (line === ')') {
        return { inMultilineDirective: false, currentVerb: null, lineRemainder: null };
    }
    else {
        return { inMultilineDirective: true, currentVerb: state.currentVerb, lineRemainder: line };
    }
}
function processLineForDirective(verb, lineRemainder, res, lineNumber) {
    try {
        switch (verb) {
            case 'module':
                res.moduleName = lineRemainder;
                break;
            case 'go':
                res.golangVersion = lineRemainder;
                break;
            case 'require':
                var req = parseModuleAndVersion(lineRemainder);
                req.indirect = reIndirect.test(lineRemainder);
                res.requires.push(req);
                break;
            case 'exclude':
                res.excludes.push(parseModuleAndVersion(lineRemainder));
                break;
            case 'replace':
                var _a = tslib_1.__read(lineRemainder.split('=>'), 2), oldMod = _a[0], newMod = _a[1];
                if (!oldMod || !newMod) {
                    throw new Error('could not split the line in two on "=>"');
                }
                res.replaces.push({
                    oldMod: parseModuleAndMaybeVersion(oldMod),
                    newMod: parseModuleAndMaybeVersion(newMod),
                });
                break;
            default:
                throw new Error("Attempting to process unknown verb: " + verb + ", line remainder: " + lineRemainder);
        }
    }
    catch (e) {
        throw new errors_1.InvalidUserInputError("Could not parse line " + lineNumber + " as " + verb + " directive:\n" + lineRemainder + "\nbecause of error: " + e);
    }
}
function parseGoMod(goModStr) {
    var e_1, _a;
    try {
        var lines = goModStr.split('\n');
        var res = {
            moduleName: '',
            requires: [],
            replaces: [],
            excludes: [],
        };
        var state = { inMultilineDirective: false, currentVerb: null };
        var i = 0;
        try {
            for (var lines_1 = tslib_1.__values(lines), lines_1_1 = lines_1.next(); !lines_1_1.done; lines_1_1 = lines_1.next()) {
                var line = lines_1_1.value;
                i++;
                line = line.trim();
                var stateAndRemainder = updateParserState(line, state);
                state = stateAndRemainder;
                if (stateAndRemainder.lineRemainder) {
                    processLineForDirective(state.currentVerb, stateAndRemainder.lineRemainder, res, i);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (lines_1_1 && !lines_1_1.done && (_a = lines_1.return)) _a.call(lines_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (!res.moduleName) {
            throw new errors_1.InvalidUserInputError('No module name specified in go.mod file');
        }
        return res;
    }
    catch (e) {
        if (e.name === 'InvalidUserInputError') {
            throw e;
        }
        else {
            throw new errors_1.InvalidUserInputError('go.mod parsing failed with error: ' + e.message);
        }
    }
}
exports.parseGoMod = parseGoMod;
function toSnykVersion(v) {
    var hash = v.hash;
    if (hash) {
        return '#' + hash;
    }
    else {
        return v.exactVersion;
    }
}
exports.toSnykVersion = toSnykVersion;
//# sourceMappingURL=gomod-parser.js.map