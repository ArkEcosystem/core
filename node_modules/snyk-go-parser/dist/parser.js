"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var toml = require("toml");
var errors_1 = require("./errors/");
// TODO(kyegupov): split into go-dep-parser and go-vendor-parser files
function parseGoPkgConfig(manifestFileContents, lockFileContents) {
    if (!manifestFileContents && !lockFileContents) {
        throw new errors_1.InvalidUserInputError('Gopkg.lock and Gopkg.toml file contents are empty');
    }
    if (!lockFileContents) {
        throw new errors_1.InvalidUserInputError('Gopkg.lock is empty, cannot proceed parsing');
    }
    var lockedVersions = parseDepLockContents(lockFileContents);
    var ignoredPkgs = [];
    if (manifestFileContents) {
        var manifest = parseDepManifestContents(manifestFileContents);
        ignoredPkgs = manifest.ignored;
    }
    return { lockedVersions: lockedVersions, ignoredPkgs: ignoredPkgs };
}
exports.parseGoPkgConfig = parseGoPkgConfig;
function parseGoVendorConfig(manifestFileContents) {
    if (!manifestFileContents) {
        throw new errors_1.InvalidUserInputError('vendor.json file contents are empty');
    }
    return parseGovendorJsonContents(manifestFileContents);
}
exports.parseGoVendorConfig = parseGoVendorConfig;
function parseDepLockContents(lockFileString) {
    try {
        var lockJson = toml.parse(lockFileString);
        var deps_1 = {};
        if (lockJson.projects) {
            lockJson.projects.forEach(function (proj) {
                var version = proj.version || ('#' + proj.revision);
                proj.packages.forEach(function (subpackageName) {
                    var name = (subpackageName === '.' ?
                        proj.name :
                        proj.name + '/' + subpackageName);
                    var dep = {
                        name: name,
                        version: version,
                    };
                    deps_1[dep.name] = dep;
                });
            });
        }
        return deps_1;
    }
    catch (e) {
        throw new errors_1.InvalidUserInputError('Gopkg.lock parsing failed with error ' + e.message);
    }
}
function parseDepManifestContents(manifestToml) {
    try {
        var manifestJson = toml.parse(manifestToml) || {};
        manifestJson.ignored = manifestJson.ignored || [];
        return manifestJson;
    }
    catch (e) {
        throw new errors_1.InvalidUserInputError('Gopkg.toml parsing failed with error ' + e.message);
    }
}
// TODO: branch, old Version can be a tag too?
function parseGovendorJsonContents(jsonStr) {
    try {
        var gvJson = JSON.parse(jsonStr);
        var goProjectConfig_1 = {
            ignoredPkgs: [],
            lockedVersions: {},
            packageName: gvJson.rootPath,
        };
        var packages = (gvJson.package || gvJson.Package);
        if (packages) {
            packages.forEach(function (pkg) {
                var revision = pkg.revision || pkg.Revision || pkg.version || pkg.Version;
                var version = pkg.versionExact || ('#' + revision);
                var dep = {
                    name: pkg.path,
                    version: version,
                };
                goProjectConfig_1.lockedVersions[dep.name] = dep;
            });
        }
        var ignores = gvJson.ignore || '';
        ignores.split(/\s/).filter(function (s) {
            // otherwise it's a build-tag rather than a pacakge
            return s.indexOf('/') !== -1;
        }).forEach(function (pkgName) {
            pkgName = pkgName.replace(/\/+$/, ''); // remove trailing /
            goProjectConfig_1.ignoredPkgs.push(pkgName);
            goProjectConfig_1.ignoredPkgs.push(pkgName + '/*');
        });
        return goProjectConfig_1;
    }
    catch (e) {
        throw new errors_1.InvalidUserInputError('vendor.json parsing failed with error ' + e.message);
    }
}
exports.parseGovendorJsonContents = parseGovendorJsonContents;
//# sourceMappingURL=parser.js.map