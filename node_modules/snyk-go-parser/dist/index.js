"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var parser_1 = require("./parser");
exports.parseGoPkgConfig = parser_1.parseGoPkgConfig;
exports.parseGoVendorConfig = parser_1.parseGoVendorConfig;
var gomod_parser_1 = require("./gomod-parser");
exports.parseGoMod = gomod_parser_1.parseGoMod;
exports.toSnykVersion = gomod_parser_1.toSnykVersion;
exports.parseVersion = gomod_parser_1.parseVersion;
// TODO(kyegupov): make all build* functions sync
// TODO(kyegupov): pin down the types for "options"
// Build dep tree from the manifest/lock files only.
// This does not scan the source code for imports, so it's not accurate;
// in particular, it cannot build the proper dependency graph (only a flat list).
function buildGoPkgDepTree(manifestFileContents, lockFileContents, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        return tslib_1.__generator(this, function (_a) {
            return [2 /*return*/, buildGoDepTree(parser_1.parseGoPkgConfig(manifestFileContents, lockFileContents))];
        });
    });
}
exports.buildGoPkgDepTree = buildGoPkgDepTree;
// Build dep tree from the manifest/lock files only.
// This does not scan the source code for imports, so it's not accurate;
// in particular, it cannot build the proper dependency graph (only a flat list).
function buildGoVendorDepTree(manifestFileContents, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        return tslib_1.__generator(this, function (_a) {
            return [2 /*return*/, buildGoDepTree(parser_1.parseGoVendorConfig(manifestFileContents))];
        });
    });
}
exports.buildGoVendorDepTree = buildGoVendorDepTree;
function buildGoDepTree(goProjectConfig) {
    var e_1, _a;
    var depTree = {
        name: goProjectConfig.packageName || 'root',
        version: '0.0.0',
        dependencies: {},
    };
    var dependencies = depTree.dependencies;
    try {
        for (var _b = tslib_1.__values(Object.keys(goProjectConfig.lockedVersions)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var dep = _c.value;
            dependencies[dep] = {
                name: dep,
                version: goProjectConfig.lockedVersions[dep].version,
            };
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return depTree;
}
//# sourceMappingURL=index.js.map