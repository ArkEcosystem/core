{"version":3,"file":"http.js","sourceRoot":"","sources":["../../src/integrations/http.ts"],"names":[],"mappings":"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","sourcesContent":["import { getCurrentHub } from '@sentry/core';\nimport { Integration } from '@sentry/types';\nimport { fill } from '@sentry/utils';\nimport * as http from 'http';\nimport * as util from 'util';\n\nlet lastResponse: http.ServerResponse | undefined;\n\n/**\n * Request interface which can carry around unified url\n * independently of used framework\n */\ninterface SentryRequest extends http.IncomingMessage {\n  __ravenBreadcrumbUrl?: string;\n}\n\n/** http module integration */\nexport class Http implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public name: string = Http.id;\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'Http';\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(): void {\n    const nativeModule = require('module');\n    fill(nativeModule, '_load', loadWrapper(nativeModule));\n    // observation: when the https module does its own require('http'), it *does not* hit our hooked require to instrument http on the fly\n    // but if we've previously instrumented http, https *does* get our already-instrumented version\n    // this is because raven's transports are required before this instrumentation takes place, which loads https (and http)\n    // so module cache will have uninstrumented http; proactively loading it here ensures instrumented version is in module cache\n    // alternatively we could refactor to load our transports later, but this is easier and doesn't have much drawback\n    require('http');\n  }\n}\n\n/**\n * Function that can combine together a url that'll be used for our breadcrumbs.\n *\n * @param options url that should be returned or an object containing it's parts.\n * @returns constructed url\n */\nfunction createBreadcrumbUrl(options: string | http.ClientRequestArgs): string {\n  // We could just always reconstruct this from this.agent, this._headers, this.path, etc\n  // but certain other http-instrumenting libraries (like nock, which we use for tests) fail to\n  // maintain the guarantee that after calling origClientRequest, those fields will be populated\n  if (typeof options === 'string') {\n    return options;\n  }\n  const protocol = options.protocol || '';\n  const hostname = options.hostname || options.host || '';\n  // Don't log standard :80 (http) and :443 (https) ports to reduce the noise\n  const port = !options.port || options.port === 80 || options.port === 443 ? '' : `:${options.port}`;\n  const path = options.path || '/';\n  return `${protocol}//${hostname}${port}${path}`;\n}\n\n/**\n * Wrapper function for internal _load calls within `require`\n */\nfunction loadWrapper(nativeModule: any): any {\n  // We need to use some functional-style currying to pass values around\n  // as we cannot rely on `bind`, because this has to preserve correct\n  // context for native calls\n  return function(originalLoad: () => any): any {\n    return function(this: SentryRequest, moduleId: string): any {\n      const originalModule = originalLoad.apply(nativeModule, arguments);\n\n      if (moduleId !== 'http' || originalModule.__sentry__) {\n        return originalModule;\n      }\n\n      const origClientRequest = originalModule.ClientRequest;\n      const clientRequest = function(\n        this: SentryRequest,\n        options: http.ClientRequestArgs | string,\n        callback: () => void,\n      ): any {\n        // Note: this won't capture a breadcrumb if a response never comes\n        // It would be useful to know if that was the case, though, so\n        // TODO: revisit to see if we can capture sth indicating response never came\n        // possibility: capture one breadcrumb for \"req sent\" and one for \"res recvd\"\n        // seems excessive but solves the problem and *is* strictly more information\n        // could be useful for weird response sequencing bug scenarios\n\n        origClientRequest.call(this, options, callback);\n        this.__ravenBreadcrumbUrl = createBreadcrumbUrl(options);\n      };\n\n      util.inherits(clientRequest, origClientRequest);\n\n      fill(clientRequest.prototype, 'emit', emitWrapper);\n\n      fill(originalModule, 'ClientRequest', function(): any {\n        return clientRequest;\n      });\n\n      // http.request orig refs module-internal ClientRequest, not exported one, so\n      // it still points at orig ClientRequest after our monkeypatch; these reimpls\n      // just get that reference updated to use our new ClientRequest\n      fill(originalModule, 'request', function(): any {\n        return function(options: http.ClientRequestArgs, callback: () => void): any {\n          return new originalModule.ClientRequest(options, callback) as http.IncomingMessage;\n        };\n      });\n\n      fill(originalModule, 'get', function(): any {\n        return function(options: http.ClientRequestArgs, callback: () => void): any {\n          const req = originalModule.request(options, callback);\n          req.end();\n          return req;\n        };\n      });\n\n      originalModule.__sentry__ = true;\n      return originalModule;\n    };\n  };\n}\n\n/**\n * Wrapper function for request's `emit` calls\n */\nfunction emitWrapper(origEmit: EventListener): (event: string, response: http.ServerResponse) => EventListener {\n  return function(this: SentryRequest, event: string, response: http.ServerResponse): any {\n    // I'm not sure why but Node.js (at least in v8.X)\n    // is emitting all events twice :|\n    if (lastResponse === undefined || lastResponse !== response) {\n      lastResponse = response;\n    } else {\n      return origEmit.apply(this, arguments);\n    }\n\n    const client = getCurrentHub().getClient();\n    if (client) {\n      const dsn = client.getDsn();\n\n      const isInterestingEvent = event === 'response' || event === 'error';\n      const isNotSentryRequest = dsn && this.__ravenBreadcrumbUrl && this.__ravenBreadcrumbUrl.indexOf(dsn.host) === -1;\n\n      if (isInterestingEvent && isNotSentryRequest && getCurrentHub().getIntegration(Http)) {\n        getCurrentHub().addBreadcrumb(\n          {\n            category: 'http',\n            data: {\n              method: this.method,\n              status_code: response.statusCode,\n              url: this.__ravenBreadcrumbUrl,\n            },\n            type: 'http',\n          },\n          {\n            event,\n            request: this,\n            response,\n          },\n        );\n      }\n    }\n\n    return origEmit.apply(this, arguments);\n  };\n}\n"]}