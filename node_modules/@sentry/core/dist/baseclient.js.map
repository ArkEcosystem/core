{"version":3,"file":"baseclient.js","sourceRoot":"","sources":["../src/baseclient.ts"],"names":[],"mappings":"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","sourcesContent":["import { Scope } from '@sentry/hub';\nimport { Client, Event, EventHint, Integration, IntegrationClass, Options, SdkInfo, Severity } from '@sentry/types';\nimport { isPrimitive, isThenable, logger, SyncPromise, truncate, uuid4 } from '@sentry/utils';\n\nimport { Backend, BackendClass } from './basebackend';\nimport { Dsn } from './dsn';\nimport { IntegrationIndex, setupIntegrations } from './integration';\n\n/**\n * Base implementation for all JavaScript SDK clients.\n *\n * Call the constructor with the corresponding backend constructor and options\n * specific to the client subclass. To access these options later, use\n * {@link Client.getOptions}. Also, the Backend instance is available via\n * {@link Client.getBackend}.\n *\n * If a Dsn is specified in the options, it will be parsed and stored. Use\n * {@link Client.getDsn} to retrieve the Dsn at any moment. In case the Dsn is\n * invalid, the constructor will throw a {@link SentryException}. Note that\n * without a valid Dsn, the SDK will not send any events to Sentry.\n *\n * Before sending an event via the backend, it is passed through\n * {@link BaseClient.prepareEvent} to add SDK information and scope data\n * (breadcrumbs and context). To add more custom information, override this\n * method and extend the resulting prepared event.\n *\n * To issue automatically created events (e.g. via instrumentation), use\n * {@link Client.captureEvent}. It will prepare the event and pass it through\n * the callback lifecycle. To issue auto-breadcrumbs, use\n * {@link Client.addBreadcrumb}.\n *\n * @example\n * class NodeClient extends BaseClient<NodeBackend, NodeOptions> {\n *   public constructor(options: NodeOptions) {\n *     super(NodeBackend, options);\n *   }\n *\n *   // ...\n * }\n */\nexport abstract class BaseClient<B extends Backend, O extends Options> implements Client<O> {\n  /**\n   * The backend used to physically interact in the enviornment. Usually, this\n   * will correspond to the client. When composing SDKs, however, the Backend\n   * from the root SDK will be used.\n   */\n  protected readonly _backend: B;\n\n  /** Options passed to the SDK. */\n  protected readonly _options: O;\n\n  /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */\n  protected readonly _dsn?: Dsn;\n\n  /** Array of used integrations. */\n  protected readonly _integrations: IntegrationIndex = {};\n\n  /** Is the client still processing a call? */\n  protected _processing: boolean = false;\n\n  /**\n   * Initializes this client instance.\n   *\n   * @param backendClass A constructor function to create the backend.\n   * @param options Options for the client.\n   */\n  protected constructor(backendClass: BackendClass<B, O>, options: O) {\n    this._backend = new backendClass(options);\n    this._options = options;\n\n    if (options.dsn) {\n      this._dsn = new Dsn(options.dsn);\n    }\n\n    if (this._isEnabled()) {\n      this._integrations = setupIntegrations(this._options);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public captureException(exception: any, hint?: EventHint, scope?: Scope): string | undefined {\n    let eventId: string | undefined = hint && hint.event_id;\n    this._processing = true;\n\n    this._getBackend()\n      .eventFromException(exception, hint)\n      .then(event => this._processEvent(event, hint, scope))\n      .then(finalEvent => {\n        // We need to check for finalEvent in case beforeSend returned null\n        eventId = finalEvent && finalEvent.event_id;\n        this._processing = false;\n      })\n      .catch(reason => {\n        logger.error(reason);\n        this._processing = false;\n      });\n\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public captureMessage(message: string, level?: Severity, hint?: EventHint, scope?: Scope): string | undefined {\n    let eventId: string | undefined = hint && hint.event_id;\n\n    this._processing = true;\n\n    const promisedEvent = isPrimitive(message)\n      ? this._getBackend().eventFromMessage(`${message}`, level, hint)\n      : this._getBackend().eventFromException(message, hint);\n\n    promisedEvent\n      .then(event => this._processEvent(event, hint, scope))\n      .then(finalEvent => {\n        // We need to check for finalEvent in case beforeSend returned null\n        eventId = finalEvent && finalEvent.event_id;\n        this._processing = false;\n      })\n      .catch(reason => {\n        logger.error(reason);\n        this._processing = false;\n      });\n\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public captureEvent(event: Event, hint?: EventHint, scope?: Scope): string | undefined {\n    let eventId: string | undefined = hint && hint.event_id;\n    this._processing = true;\n\n    this._processEvent(event, hint, scope)\n      .then(finalEvent => {\n        // We need to check for finalEvent in case beforeSend returned null\n        eventId = finalEvent && finalEvent.event_id;\n        this._processing = false;\n      })\n      .catch(reason => {\n        logger.error(reason);\n        this._processing = false;\n      });\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getDsn(): Dsn | undefined {\n    return this._dsn;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getOptions(): O {\n    return this._options;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public flush(timeout?: number): Promise<boolean> {\n    return this._isClientProcessing(timeout).then(status => {\n      clearInterval(status.interval);\n      return this._getBackend()\n        .getTransport()\n        .close(timeout)\n        .then(transportFlushed => status.ready && transportFlushed);\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public close(timeout?: number): Promise<boolean> {\n    return this.flush(timeout).then(result => {\n      this.getOptions().enabled = false;\n      return result;\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getIntegrations(): IntegrationIndex {\n    return this._integrations || {};\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getIntegration<T extends Integration>(integration: IntegrationClass<T>): T | null {\n    try {\n      return (this._integrations[integration.id] as T) || null;\n    } catch (_oO) {\n      logger.warn(`Cannot retrieve integration ${integration.id} from the current Client`);\n      return null;\n    }\n  }\n\n  /** Waits for the client to be done with processing. */\n  protected _isClientProcessing(timeout?: number): Promise<{ ready: boolean; interval: number }> {\n    return new SyncPromise<{ ready: boolean; interval: number }>(resolve => {\n      let ticked: number = 0;\n      const tick: number = 1;\n\n      let interval = 0;\n      clearInterval(interval);\n\n      interval = (setInterval(() => {\n        if (!this._processing) {\n          resolve({\n            interval,\n            ready: true,\n          });\n        } else {\n          ticked += tick;\n          if (timeout && ticked >= timeout) {\n            resolve({\n              interval,\n              ready: false,\n            });\n          }\n        }\n      }, tick) as unknown) as number;\n    });\n  }\n\n  /** Returns the current backend. */\n  protected _getBackend(): B {\n    return this._backend;\n  }\n\n  /** Determines whether this SDK is enabled and a valid Dsn is present. */\n  protected _isEnabled(): boolean {\n    return this.getOptions().enabled !== false && this._dsn !== undefined;\n  }\n\n  /**\n   * Adds common information to events.\n   *\n   * The information includes release and environment from `options`,\n   * breadcrumbs and context (extra, tags and user) from the scope.\n   *\n   * Information that is already present in the event is never overwritten. For\n   * nested objects, such as the context, keys are merged.\n   *\n   * @param event The original event.\n   * @param hint May contain additional informartion about the original exception.\n   * @param scope A scope containing event metadata.\n   * @returns A new event with more information.\n   */\n  protected _prepareEvent(event: Event, scope?: Scope, hint?: EventHint): Promise<Event | null> {\n    const { environment, release, dist, maxValueLength = 250 } = this.getOptions();\n\n    const prepared: Event = { ...event };\n    if (prepared.environment === undefined && environment !== undefined) {\n      prepared.environment = environment;\n    }\n    if (prepared.release === undefined && release !== undefined) {\n      prepared.release = release;\n    }\n\n    if (prepared.dist === undefined && dist !== undefined) {\n      prepared.dist = dist;\n    }\n\n    if (prepared.message) {\n      prepared.message = truncate(prepared.message, maxValueLength);\n    }\n\n    const exception = prepared.exception && prepared.exception.values && prepared.exception.values[0];\n    if (exception && exception.value) {\n      exception.value = truncate(exception.value, maxValueLength);\n    }\n\n    const request = prepared.request;\n    if (request && request.url) {\n      request.url = truncate(request.url, maxValueLength);\n    }\n\n    if (prepared.event_id === undefined) {\n      prepared.event_id = uuid4();\n    }\n\n    this._addIntegrations(prepared.sdk);\n\n    // We prepare the result here with a resolved Event.\n    let result = SyncPromise.resolve<Event | null>(prepared);\n\n    // This should be the last thing called, since we want that\n    // {@link Hub.addEventProcessor} gets the finished prepared event.\n    if (scope) {\n      // In case we have a hub we reassign it.\n      result = scope.applyToEvent(prepared, hint);\n    }\n\n    return result;\n  }\n\n  /**\n   * This function adds all used integrations to the SDK info in the event.\n   * @param sdkInfo The sdkInfo of the event that will be filled with all integrations.\n   */\n  protected _addIntegrations(sdkInfo?: SdkInfo): void {\n    const integrationsArray = Object.keys(this._integrations);\n    if (sdkInfo && integrationsArray.length > 0) {\n      sdkInfo.integrations = integrationsArray;\n    }\n  }\n\n  /**\n   * Processes an event (either error or message) and sends it to Sentry.\n   *\n   * This also adds breadcrumbs and context information to the event. However,\n   * platform specific meta data (such as the User's IP address) must be added\n   * by the SDK implementor.\n   *\n   *\n   * @param event The event to send to Sentry.\n   * @param hint May contain additional informartion about the original exception.\n   * @param scope A scope containing event metadata.\n   * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.\n   */\n  protected _processEvent(event: Event, hint?: EventHint, scope?: Scope): Promise<Event> {\n    const { beforeSend, sampleRate } = this.getOptions();\n\n    if (!this._isEnabled()) {\n      return SyncPromise.reject('SDK not enabled, will not send event.');\n    }\n\n    // 1.0 === 100% events are sent\n    // 0.0 === 0% events are sent\n    if (typeof sampleRate === 'number' && Math.random() > sampleRate) {\n      return SyncPromise.reject('This event has been sampled, will not send event.');\n    }\n\n    return new SyncPromise((resolve, reject) => {\n      this._prepareEvent(event, scope, hint)\n        .then(prepared => {\n          if (prepared === null) {\n            reject('An event processor returned null, will not send event.');\n            return;\n          }\n\n          let finalEvent: Event | null = prepared;\n\n          try {\n            const isInternalException = hint && hint.data && (hint.data as { [key: string]: any }).__sentry__ === true;\n            if (isInternalException || !beforeSend) {\n              this._getBackend().sendEvent(finalEvent);\n              resolve(finalEvent);\n              return;\n            }\n\n            const beforeSendResult = beforeSend(prepared, hint);\n            if ((typeof beforeSendResult as any) === 'undefined') {\n              logger.error('`beforeSend` method has to return `null` or a valid event.');\n            } else if (isThenable(beforeSendResult)) {\n              this._handleAsyncBeforeSend(beforeSendResult as Promise<Event | null>, resolve, reject);\n            } else {\n              finalEvent = beforeSendResult as Event | null;\n\n              if (finalEvent === null) {\n                logger.log('`beforeSend` returned `null`, will not send event.');\n                resolve(null);\n                return;\n              }\n\n              // From here on we are really async\n              this._getBackend().sendEvent(finalEvent);\n              resolve(finalEvent);\n            }\n          } catch (exception) {\n            this.captureException(exception, {\n              data: {\n                __sentry__: true,\n              },\n              originalException: exception as Error,\n            });\n            reject('`beforeSend` threw an error, will not send event.');\n          }\n        })\n        .catch(() => {\n          reject('`beforeSend` threw an error, will not send event.');\n        });\n    });\n  }\n\n  /**\n   * Resolves before send Promise and calls resolve/reject on parent SyncPromise.\n   */\n  private _handleAsyncBeforeSend(\n    beforeSend: Promise<Event | null>,\n    resolve: (event: Event) => void,\n    reject: (reason: string) => void,\n  ): void {\n    beforeSend\n      .then(processedEvent => {\n        if (processedEvent === null) {\n          reject('`beforeSend` returned `null`, will not send event.');\n          return;\n        }\n        // From here on we are really async\n        this._getBackend().sendEvent(processedEvent);\n        resolve(processedEvent);\n      })\n      .catch(e => {\n        reject(`beforeSend rejected with ${e}`);\n      });\n  }\n}\n"]}