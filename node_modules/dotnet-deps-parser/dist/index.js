"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
require("source-map-support/register");
var fs = require("fs");
var path = require("path");
var _ = require("lodash");
var parsers_1 = require("./parsers");
exports.DepType = parsers_1.DepType;
var project_assets_json_parser_1 = require("./parsers/project-assets-json-parser");
var PROJ_FILE_EXTENSIONS = [
    '.csproj',
    '.vbproj',
    '.fsproj',
];
function buildDepTreeFromProjectJson(manifestFileContents, includeDev) {
    if (includeDev === void 0) { includeDev = false; }
    // trimming required to address files with UTF-8 with BOM encoding
    var manifestFile = JSON.parse(manifestFileContents.trim());
    return parsers_1.getDependencyTreeFromProjectJson(manifestFile, includeDev);
}
exports.buildDepTreeFromProjectJson = buildDepTreeFromProjectJson;
// TODO: Figure out what to do about devDeps
function buildDepTreeFromProjectAssetsJson(manifestFileContents, targetFramework) {
    if (!targetFramework) {
        throw new Error('Missing targetFramework for project.assets.json');
    }
    // trimming required to address files with UTF-8 with BOM encoding
    var manifestFile = JSON.parse(manifestFileContents.trim());
    return project_assets_json_parser_1.getDependencyTreeFromProjectAssetsJson(manifestFile, targetFramework);
}
exports.buildDepTreeFromProjectAssetsJson = buildDepTreeFromProjectAssetsJson;
function buildDepTreeFromPackagesConfig(manifestFileContents, includeDev) {
    if (includeDev === void 0) { includeDev = false; }
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var manifestFile;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, parsers_1.parseManifestFile(manifestFileContents)];
                case 1:
                    manifestFile = _a.sent();
                    return [2 /*return*/, parsers_1.getDependencyTreeFromPackagesConfig(manifestFile, includeDev)];
            }
        });
    });
}
exports.buildDepTreeFromPackagesConfig = buildDepTreeFromPackagesConfig;
function buildDepTreeFromProjectFile(manifestFileContents, includeDev) {
    if (includeDev === void 0) { includeDev = false; }
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var manifestFile;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, parsers_1.parseManifestFile(manifestFileContents)];
                case 1:
                    manifestFile = _a.sent();
                    return [2 /*return*/, parsers_1.getDependencyTreeFromProjectFile(manifestFile, includeDev)];
            }
        });
    });
}
exports.buildDepTreeFromProjectFile = buildDepTreeFromProjectFile;
function buildDepTreeFromFiles(root, manifestFilePath, includeDev, targetFramework) {
    if (includeDev === void 0) { includeDev = false; }
    if (!root || !manifestFilePath) {
        throw new Error('Missing required parameters for buildDepTreeFromFiles()');
    }
    var manifestFileFullPath = path.resolve(root, manifestFilePath);
    if (!fs.existsSync(manifestFileFullPath)) {
        throw new Error('No packages.config, project.json or project file found at ' +
            ("location: " + manifestFileFullPath));
    }
    var manifestFileContents = fs.readFileSync(manifestFileFullPath, 'utf-8');
    var manifestFileExtension = path.extname(manifestFileFullPath);
    if (_.includes(PROJ_FILE_EXTENSIONS, manifestFileExtension)) {
        return buildDepTreeFromProjectFile(manifestFileContents, includeDev);
    }
    else if (_.endsWith(manifestFilePath, 'packages.config')) {
        return buildDepTreeFromPackagesConfig(manifestFileContents, includeDev);
    }
    else if (_.endsWith(manifestFilePath, 'project.json')) {
        return buildDepTreeFromProjectJson(manifestFileContents, includeDev);
    }
    else if (_.endsWith(manifestFilePath, 'project.assets.json')) {
        return buildDepTreeFromProjectAssetsJson(manifestFileContents, targetFramework);
    }
    else {
        throw new Error("Unsupported file " + manifestFilePath + ", Please provide " +
            'either packages.config or project file.');
    }
}
exports.buildDepTreeFromFiles = buildDepTreeFromFiles;
function extractTargetFrameworksFromFiles(root, manifestFilePath, includeDev) {
    if (includeDev === void 0) { includeDev = false; }
    if (!root || !manifestFilePath) {
        throw new Error('Missing required parameters for extractTargetFrameworksFromFiles()');
    }
    var manifestFileFullPath = path.resolve(root, manifestFilePath);
    if (!fs.existsSync(manifestFileFullPath)) {
        throw new Error('No project file found at ' +
            ("location: " + manifestFileFullPath));
    }
    var manifestFileContents = fs.readFileSync(manifestFileFullPath, 'utf-8');
    var manifestFileExtension = path.extname(manifestFileFullPath);
    if (_.includes(PROJ_FILE_EXTENSIONS, manifestFileExtension)) {
        return extractTargetFrameworksFromProjectFile(manifestFileContents);
    }
    else if (_.endsWith(manifestFilePath, 'packages.config')) {
        return extractTargetFrameworksFromProjectConfig(manifestFileContents);
    }
    else if (_.endsWith(manifestFilePath, 'project.json')) {
        return extractTargetFrameworksFromProjectJson(manifestFileContents);
    }
    else if (_.endsWith(manifestFilePath, 'project.assets.json')) {
        return extractTargetFrameworksFromProjectAssetsJson(manifestFileContents);
    }
    else {
        throw new Error("Unsupported file " + manifestFilePath + ", Please provide " +
            'a project *.csproj, *.vbproj, *.fsproj or packages.config file.');
    }
}
exports.extractTargetFrameworksFromFiles = extractTargetFrameworksFromFiles;
function extractTargetFrameworksFromProjectFile(manifestFileContents) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var manifestFile, err_1;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 2, , 3]);
                    return [4 /*yield*/, parsers_1.parseManifestFile(manifestFileContents)];
                case 1:
                    manifestFile = _a.sent();
                    return [2 /*return*/, parsers_1.getTargetFrameworksFromProjectFile(manifestFile)];
                case 2:
                    err_1 = _a.sent();
                    throw new Error("Extracting target framework failed with error " + err_1.message);
                case 3: return [2 /*return*/];
            }
        });
    });
}
exports.extractTargetFrameworksFromProjectFile = extractTargetFrameworksFromProjectFile;
function extractTargetFrameworksFromProjectConfig(manifestFileContents) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var manifestFile, err_2;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 2, , 3]);
                    return [4 /*yield*/, parsers_1.parseManifestFile(manifestFileContents)];
                case 1:
                    manifestFile = _a.sent();
                    return [2 /*return*/, parsers_1.getTargetFrameworksFromProjectConfig(manifestFile)];
                case 2:
                    err_2 = _a.sent();
                    throw new Error("Extracting target framework failed with error " + err_2.message);
                case 3: return [2 /*return*/];
            }
        });
    });
}
exports.extractTargetFrameworksFromProjectConfig = extractTargetFrameworksFromProjectConfig;
function containsPackageReference(manifestFileContents) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var manifestFile, projectItems, referenceIndex;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, parsers_1.parseManifestFile(manifestFileContents)];
                case 1:
                    manifestFile = _a.sent();
                    projectItems = _.get(manifestFile, 'Project.ItemGroup', []);
                    referenceIndex = _.findIndex(projectItems, function (itemGroup) { return _.has(itemGroup, 'PackageReference'); });
                    return [2 /*return*/, referenceIndex !== -1];
            }
        });
    });
}
exports.containsPackageReference = containsPackageReference;
function extractTargetFrameworksFromProjectJson(manifestFileContents) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var manifestFile;
        return tslib_1.__generator(this, function (_a) {
            try {
                manifestFile = JSON.parse(manifestFileContents.trim());
                return [2 /*return*/, parsers_1.getTargetFrameworksFromProjectJson(manifestFile)];
            }
            catch (err) {
                throw new Error("Extracting target framework failed with error " + err.message);
            }
            return [2 /*return*/];
        });
    });
}
exports.extractTargetFrameworksFromProjectJson = extractTargetFrameworksFromProjectJson;
function extractTargetFrameworksFromProjectAssetsJson(manifestFileContents) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var manifestFile;
        return tslib_1.__generator(this, function (_a) {
            try {
                manifestFile = JSON.parse(manifestFileContents.trim());
                return [2 /*return*/, parsers_1.getTargetFrameworksFromProjectAssetsJson(manifestFile)];
            }
            catch (err) {
                throw new Error("Extracting target framework failed with error " + err.message);
            }
            return [2 /*return*/];
        });
    });
}
exports.extractTargetFrameworksFromProjectAssetsJson = extractTargetFrameworksFromProjectAssetsJson;
//# sourceMappingURL=index.js.map