"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var parseXML = require("xml2js");
var _ = require("lodash");
var errors_1 = require("../errors");
var DepType;
(function (DepType) {
    DepType["prod"] = "prod";
    DepType["dev"] = "dev";
})(DepType = exports.DepType || (exports.DepType = {}));
var ProjectJsonDepType;
(function (ProjectJsonDepType) {
    ProjectJsonDepType["build"] = "build";
    ProjectJsonDepType["project"] = "project";
    ProjectJsonDepType["platform"] = "platform";
    ProjectJsonDepType["default"] = "default";
})(ProjectJsonDepType = exports.ProjectJsonDepType || (exports.ProjectJsonDepType = {}));
function getDependencyTreeFromProjectJson(manifestFile, includeDev) {
    if (includeDev === void 0) { includeDev = false; }
    var depTree = {
        dependencies: {},
        hasDevDependencies: false,
        name: '',
        version: '',
    };
    for (var depName in manifestFile.dependencies) {
        if (!manifestFile.dependencies.hasOwnProperty(depName)) {
            continue;
        }
        var depValue = manifestFile.dependencies[depName];
        var version = depValue.version || depValue;
        var isDev = depValue.type === 'build';
        depTree.hasDevDependencies = depTree.hasDevDependencies || isDev;
        if (isDev && !includeDev) {
            continue;
        }
        depTree.dependencies[depName] = buildSubTreeFromProjectJson(depName, version, isDev);
    }
    return depTree;
}
exports.getDependencyTreeFromProjectJson = getDependencyTreeFromProjectJson;
function buildSubTreeFromProjectJson(name, version, isDev) {
    var depSubTree = {
        depType: isDev ? DepType.dev : DepType.prod,
        dependencies: {},
        name: name,
        version: version,
    };
    return depSubTree;
}
function getDependencyTreeFromPackagesConfig(manifestFile, includeDev) {
    if (includeDev === void 0) { includeDev = false; }
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var depTree, packageList, _i, packageList_1, dep, depName, isDev;
        return tslib_1.__generator(this, function (_a) {
            depTree = {
                dependencies: {},
                hasDevDependencies: false,
                name: '',
                version: '',
            };
            packageList = _.get(manifestFile, 'packages.package', []);
            for (_i = 0, packageList_1 = packageList; _i < packageList_1.length; _i++) {
                dep = packageList_1[_i];
                depName = dep.$.id;
                isDev = !!dep.$.developmentDependency;
                depTree.hasDevDependencies = depTree.hasDevDependencies || isDev;
                if (isDev && !includeDev) {
                    continue;
                }
                depTree.dependencies[depName] = buildSubTreeFromPackagesConfig(dep, isDev);
            }
            return [2 /*return*/, depTree];
        });
    });
}
exports.getDependencyTreeFromPackagesConfig = getDependencyTreeFromPackagesConfig;
function buildSubTreeFromPackagesConfig(dep, isDev) {
    var depSubTree = {
        depType: isDev ? DepType.dev : DepType.prod,
        dependencies: {},
        name: dep.$.id,
        version: dep.$.version,
    };
    if (dep.$.targetFramework) {
        depSubTree.targetFrameworks = [dep.$.targetFramework];
    }
    return depSubTree;
}
function getDependencyTreeFromProjectFile(manifestFile, includeDev) {
    if (includeDev === void 0) { includeDev = false; }
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var nameProperty, name, packageReferenceDeps, referenceIncludeDeps, depTree;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    nameProperty = _.get(manifestFile, 'Project.PropertyGroup', [])
                        .find(function (propertyGroup) {
                        return _.has(propertyGroup, 'PackageId')
                            || _.has(propertyGroup, 'AssemblyName');
                    }) || {};
                    name = (nameProperty.PackageId && nameProperty.PackageId[0])
                        || (nameProperty.AssemblyName && nameProperty.AssemblyName[0])
                        || '';
                    return [4 /*yield*/, getDependenciesFromPackageReference(manifestFile, includeDev)];
                case 1:
                    packageReferenceDeps = _a.sent();
                    return [4 /*yield*/, getDependenciesFromReferenceInclude(manifestFile, includeDev)];
                case 2:
                    referenceIncludeDeps = _a.sent();
                    depTree = {
                        dependencies: tslib_1.__assign({}, referenceIncludeDeps.dependencies, packageReferenceDeps.dependencies),
                        hasDevDependencies: packageReferenceDeps.hasDevDependencies || referenceIncludeDeps.hasDevDependencies,
                        name: name,
                        version: '',
                    };
                    if (packageReferenceDeps.dependenciesWithUnknownVersions) {
                        depTree.dependenciesWithUnknownVersions = packageReferenceDeps.dependenciesWithUnknownVersions;
                    }
                    return [2 /*return*/, depTree];
            }
        });
    });
}
exports.getDependencyTreeFromProjectFile = getDependencyTreeFromProjectFile;
function getDependenciesFromPackageReference(manifestFile, includeDev) {
    if (includeDev === void 0) { includeDev = false; }
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var dependenciesResult, packageGroups, _i, packageGroups_1, packageList;
        return tslib_1.__generator(this, function (_a) {
            dependenciesResult = {
                dependencies: {},
                hasDevDependencies: false,
            };
            packageGroups = _.get(manifestFile, 'Project.ItemGroup', [])
                .filter(function (itemGroup) { return _.has(itemGroup, 'PackageReference'); });
            if (!packageGroups.length) {
                return [2 /*return*/, dependenciesResult];
            }
            for (_i = 0, packageGroups_1 = packageGroups; _i < packageGroups_1.length; _i++) {
                packageList = packageGroups_1[_i];
                dependenciesResult = processItemGroupForPackageReference(packageList, manifestFile, includeDev, dependenciesResult);
            }
            return [2 /*return*/, dependenciesResult];
        });
    });
}
function processItemGroupForPackageReference(packageList, manifestFile, includeDev, dependenciesResult) {
    var targetFrameworks = _.get(packageList, '$.Condition', false) ?
        getConditionalFrameworks(packageList.$.Condition) : [];
    for (var _i = 0, _a = packageList.PackageReference; _i < _a.length; _i++) {
        var dep = _a[_i];
        var depName = dep.$.Include;
        if (!depName) {
            // PackageReference Update is not yet supported
            continue;
        }
        var isDev = !!dep.$.developmentDependency;
        dependenciesResult.hasDevDependencies = dependenciesResult.hasDevDependencies || isDev;
        if (isDev && !includeDev) {
            continue;
        }
        var subDep = buildSubTreeFromPackageReference(dep, isDev, manifestFile, targetFrameworks);
        if (subDep.withoutVersion) {
            dependenciesResult.dependenciesWithUnknownVersions = dependenciesResult.dependenciesWithUnknownVersions || [];
            dependenciesResult.dependenciesWithUnknownVersions.push(subDep.name);
        }
        else {
            dependenciesResult.dependencies[depName] = subDep;
        }
    }
    return dependenciesResult;
}
function getDependenciesFromReferenceInclude(manifestFile, includeDev) {
    if (includeDev === void 0) { includeDev = false; }
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var referenceIncludeResult, referenceIncludeList, targetFrameworks, _i, _a, item, propertiesList, depName, depInfoArray, depInfo, _b, depInfoArray_1, itemValue, propertyValuePair, dependency;
        return tslib_1.__generator(this, function (_c) {
            referenceIncludeResult = {
                dependencies: {},
                hasDevDependencies: false,
            };
            referenceIncludeList = _.get(manifestFile, 'Project.ItemGroup', [])
                .find(function (itemGroup) { return _.has(itemGroup, 'Reference'); });
            if (!referenceIncludeList) {
                return [2 /*return*/, referenceIncludeResult];
            }
            targetFrameworks = _.get(referenceIncludeList, '$.Condition', false) ?
                getConditionalFrameworks(referenceIncludeList.$.Condition) : [];
            for (_i = 0, _a = referenceIncludeList.Reference; _i < _a.length; _i++) {
                item = _a[_i];
                propertiesList = item.$.Include.split(',').map(function (i) { return i.trim(); });
                depName = propertiesList[0], depInfoArray = propertiesList.slice(1);
                depInfo = {};
                for (_b = 0, depInfoArray_1 = depInfoArray; _b < depInfoArray_1.length; _b++) {
                    itemValue = depInfoArray_1[_b];
                    propertyValuePair = itemValue.split('=');
                    depInfo[propertyValuePair[0]] = propertyValuePair[1];
                }
                dependency = {
                    // TODO: correctly identify what makes the dep be dev only
                    depType: DepType.prod,
                    dependencies: {},
                    name: depName,
                    version: depInfo.Version || '',
                };
                if (targetFrameworks.length) {
                    dependency.targetFrameworks = targetFrameworks;
                }
                referenceIncludeResult.dependencies[depName] = dependency;
            }
            return [2 /*return*/, referenceIncludeResult];
        });
    });
}
function buildSubTreeFromPackageReference(dep, isDev, manifestFile, targetFrameworks) {
    var version = extractDependencyVersion(dep, manifestFile);
    if (version !== null) {
        var depSubTree = {
            depType: isDev ? DepType.dev : DepType.prod,
            dependencies: {},
            name: dep.$.Include,
            // Version could be in attributes or as child node.
            version: version,
        };
        if (targetFrameworks.length) {
            depSubTree.targetFrameworks = targetFrameworks;
        }
        return depSubTree;
    }
    else {
        return { name: dep.$.Include, withoutVersion: true };
    }
}
function extractDependencyVersion(dep, manifestFile) {
    var VARS_MATCHER = /^\$\((.*?)\)/;
    var version = dep.$.Version || _.get(dep, 'Version.0');
    var variableVersion = version && version.match(VARS_MATCHER);
    if (!variableVersion) {
        return version;
    }
    // version is a variable, extract it from manifest
    var propertyName = variableVersion[1];
    var versionProperty = _.get(manifestFile, 'Project.PropertyGroup', [])
        .find(function (propertyGroup) { return _.has(propertyGroup, propertyName); });
    return _.get(versionProperty, propertyName + ".0", null);
}
function getConditionalFrameworks(condition) {
    var regexp = /\(TargetFramework\)'\s?==\s? '((\w|\d|\.)*)'/g;
    var frameworks = [];
    var match = regexp.exec(condition);
    while (match !== null) {
        frameworks.push(match[1]);
        match = regexp.exec(condition);
    }
    return frameworks;
}
function parseManifestFile(manifestFileContents) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        return tslib_1.__generator(this, function (_a) {
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    parseXML
                        .parseString(manifestFileContents, function (err, result) {
                        if (err) {
                            var e = new errors_1.InvalidUserInputError('manifest parsing failed');
                            return reject(e);
                        }
                        return resolve(result);
                    });
                })];
        });
    });
}
exports.parseManifestFile = parseManifestFile;
function getTargetFrameworksFromProjectFile(manifestFile) {
    var targetFrameworksResult = [];
    var projectPropertyGroup = _.get(manifestFile, 'Project.PropertyGroup', []);
    if (!projectPropertyGroup) {
        return targetFrameworksResult;
    }
    var propertyList = projectPropertyGroup
        .find(function (propertyGroup) {
        return _.has(propertyGroup, 'TargetFramework')
            || _.has(propertyGroup, 'TargetFrameworks')
            || _.has(propertyGroup, 'TargetFrameworkVersion');
    }) || {};
    if (_.isEmpty(propertyList)) {
        return targetFrameworksResult;
    }
    // TargetFrameworks is expected to be a list ; separated
    if (propertyList.TargetFrameworks) {
        for (var _i = 0, _a = propertyList.TargetFrameworks; _i < _a.length; _i++) {
            var item = _a[_i];
            targetFrameworksResult = targetFrameworksResult.concat(item.split(';'));
        }
    }
    // TargetFrameworkVersion is expected to be a string containing only one item
    // TargetFrameworkVersion also implies .NETFramework, for convenience
    // return longer version
    if (propertyList.TargetFrameworkVersion) {
        targetFrameworksResult.push(".NETFramework,Version=" + propertyList.TargetFrameworkVersion[0]);
    }
    // TargetFrameworks is expected to be a string
    if (propertyList.TargetFramework) {
        targetFrameworksResult = targetFrameworksResult.concat(propertyList.TargetFramework);
    }
    return _.uniq(targetFrameworksResult);
}
exports.getTargetFrameworksFromProjectFile = getTargetFrameworksFromProjectFile;
function getTargetFrameworksFromProjectConfig(manifestFile) {
    var targetFrameworksResult = [];
    var packages = _.get(manifestFile, 'packages.package', []);
    for (var _i = 0, packages_1 = packages; _i < packages_1.length; _i++) {
        var item = packages_1[_i];
        var targetFramework = item.$.targetFramework;
        if (!targetFramework) {
            continue;
        }
        if (!_.includes(targetFrameworksResult, targetFramework)) {
            targetFrameworksResult.push(targetFramework);
        }
    }
    return targetFrameworksResult;
}
exports.getTargetFrameworksFromProjectConfig = getTargetFrameworksFromProjectConfig;
function getTargetFrameworksFromProjectJson(manifestFile) {
    return Object.keys(_.get(manifestFile, 'frameworks', {}));
}
exports.getTargetFrameworksFromProjectJson = getTargetFrameworksFromProjectJson;
function getTargetFrameworksFromProjectAssetsJson(manifestFile) {
    return Object.keys(_.get(manifestFile, 'targets', {}));
}
exports.getTargetFrameworksFromProjectAssetsJson = getTargetFrameworksFromProjectAssetsJson;
//# sourceMappingURL=index.js.map