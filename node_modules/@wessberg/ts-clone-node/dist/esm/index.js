import * as TSModule from 'typescript';
import { SyntaxKind } from 'typescript';

function cloneIdentifier(node, options) {
    return options.typescript.createIdentifier(options.hook("text", node.text, node.text));
}

function cloneTypeAliasDeclaration(node, options) {
    return options.typescript.createTypeAliasDeclaration(options.hook("decorators", options.nextNodes(node.decorators), node.decorators), options.hook("modifiers", options.nextNodes(node.modifiers), node.modifiers), options.hook("name", options.nextNode(node.name), node.name), options.hook("typeParameters", options.nextNodes(node.typeParameters), node.typeParameters), options.hook("type", options.nextNode(node.type), node.type));
}

function cloneToken(node, options) {
    return options.typescript.createToken(options.hook("kind", node.kind, node.kind));
}

function cloneDecorator(node, options) {
    return options.typescript.createDecorator(options.hook("expression", options.nextNode(node.expression), node.expression));
}

function cloneTypeParameterDeclaration(node, options) {
    return options.typescript.createTypeParameterDeclaration(options.hook("name", options.nextNode(node.name), node.name), options.hook("constraint", options.nextNode(node.constraint), node.constraint), options.hook("default", options.nextNode(node.default), node.default));
}

function cloneQualifiedName(node, options) {
    return options.typescript.createQualifiedName(options.hook("left", options.nextNode(node.left), node.left), options.hook("right", options.nextNode(node.right), node.right));
}

function cloneComputedPropertyName(node, options) {
    return options.typescript.createComputedPropertyName(options.hook("expression", options.nextNode(node.expression), node.expression));
}

function cloneCallSignatureDeclaration(node, options) {
    return options.typescript.createCallSignature(options.hook("typeParameters", options.nextNodes(node.typeParameters), node.typeParameters), options.hook("parameters", options.nextNodes(node.parameters), node.parameters), options.hook("type", options.nextNode(node.type), node.type));
}

function cloneConstructSignatureDeclaration(node, options) {
    return options.typescript.createConstructSignature(options.hook("typeParameters", options.nextNodes(node.typeParameters), node.typeParameters), options.hook("parameters", options.nextNodes(node.parameters), node.parameters), options.hook("type", options.nextNode(node.type), node.type));
}

function cloneVariableDeclaration(node, options) {
    return options.typescript.createVariableDeclaration(options.hook("name", options.nextNode(node.name), node.name), options.hook("type", options.nextNode(node.type), node.type), options.hook("initializer", options.nextNode(node.initializer), node.initializer));
}

function cloneVariableDeclarationList(node, options) {
    return options.typescript.createVariableDeclarationList(options.hook("declarations", options.nextNodes(node.declarations), node.declarations), options.hook("flags", node.flags, node.flags));
}

function cloneVariableStatement(node, options) {
    return options.typescript.createVariableStatement(options.hook("modifiers", options.nextNodes(node.modifiers), node.modifiers), options.hook("declarationList", options.nextNode(node.declarationList), node.declarationList));
}

function cloneParameterDeclaration(node, options) {
    return options.typescript.createParameter(options.hook("decorators", options.nextNodes(node.decorators), node.decorators), options.hook("modifiers", options.nextNodes(node.modifiers), node.modifiers), options.hook("dotDotDotToken", options.nextNode(node.dotDotDotToken), node.dotDotDotToken), options.hook("name", options.nextNode(node.name), node.name), options.hook("questionToken", options.nextNode(node.questionToken), node.questionToken), options.hook("type", options.nextNode(node.type), node.type), options.hook("initializer", options.nextNode(node.initializer), node.initializer));
}

function cloneBindingElement(node, options) {
    return options.typescript.createBindingElement(options.hook("dotDotDotToken", options.nextNode(node.dotDotDotToken), node.dotDotDotToken), options.hook("propertyName", options.nextNode(node.propertyName), node.propertyName), options.hook("name", options.nextNode(node.name), node.name), options.hook("initializer", options.nextNode(node.initializer), node.initializer));
}

function clonePropertySignature(node, options) {
    return options.typescript.createPropertySignature(options.hook("modifiers", options.nextNodes(node.modifiers), node.modifiers), options.hook("name", options.nextNode(node.name), node.name), options.hook("questionToken", options.nextNode(node.questionToken), node.questionToken), options.hook("type", options.nextNode(node.type), node.type), options.hook("initializer", options.nextNode(node.initializer), node.initializer));
}

function clonePropertyDeclaration(node, options) {
    return options.typescript.createProperty(options.hook("decorators", options.nextNodes(node.decorators), node.decorators), options.hook("modifiers", options.nextNodes(node.modifiers), node.modifiers), options.hook("name", options.nextNode(node.name), node.name), node.questionToken != null
        ? options.hook("questionToken", options.nextNode(node.questionToken), node.questionToken)
        : options.hook("exclamationToken", options.nextNode(node.exclamationToken), node.exclamationToken), options.hook("type", options.nextNode(node.type), node.type), options.hook("initializer", options.nextNode(node.initializer), node.initializer));
}

function clonePropertyAssignment(node, options) {
    return options.typescript.createPropertyAssignment(options.hook("name", options.nextNode(node.name), node.name), options.hook("initializer", options.nextNode(node.initializer), node.initializer));
}

function cloneShorthandPropertyAssignment(node, options) {
    return options.typescript.createShorthandPropertyAssignment(options.hook("name", options.nextNode(node.name), node.name), options.hook("objectAssignmentInitializer", options.nextNode(node.objectAssignmentInitializer), node.objectAssignmentInitializer));
}

function cloneSpreadAssignment(node, options) {
    return options.typescript.createSpreadAssignment(options.hook("expression", options.nextNode(node.expression), node.expression));
}

function cloneObjectBindingPattern(node, options) {
    return options.typescript.createObjectBindingPattern(options.hook("elements", options.nextNodes(node.elements), node.elements));
}

function cloneArrayBindingPattern(node, options) {
    return options.typescript.createArrayBindingPattern(options.hook("elements", options.nextNodes(node.elements), node.elements));
}

function cloneFunctionDeclaration(node, options) {
    return options.typescript.createFunctionDeclaration(options.hook("decorators", options.nextNodes(node.decorators), node.decorators), options.hook("modifiers", options.nextNodes(node.modifiers), node.modifiers), options.hook("asteriskToken", options.nextNode(node.asteriskToken), node.asteriskToken), options.hook("name", options.nextNode(node.name), node.name), options.hook("typeParameters", options.nextNodes(node.typeParameters), node.typeParameters), options.hook("parameters", options.nextNodes(node.parameters), node.parameters), options.hook("type", options.nextNode(node.type), node.type), options.hook("body", options.nextNode(node.body), node.body));
}

function isNodeArray(item) {
    // tslint:disable-next-line
    return item != null && Array.isArray(item) && "pos" in item;
}

function ensureNodeArray(item, typescript) {
    if (item == null || isNodeArray(item))
        return item;
    return typescript.createNodeArray(item);
}

function cloneMethodSignature(node, options) {
    const updatedMethodSignature = options.typescript.createMethodSignature(options.hook("typeParameters", options.nextNodes(node.typeParameters), node.typeParameters), options.hook("parameters", options.nextNodes(node.parameters), node.parameters), options.hook("type", options.nextNode(node.type), node.type), options.hook("name", options.nextNode(node.name), node.name), options.hook("questionToken", options.nextNode(node.questionToken), node.questionToken));
    // Make sure to also update the modifiers
    // Workaround for: https://github.com/microsoft/TypeScript/issues/35959
    updatedMethodSignature.modifiers = ensureNodeArray(options.hook("modifiers", options.nextNodes(node.modifiers), node.modifiers), options.typescript);
    return updatedMethodSignature;
}

function cloneMethodDeclaration(node, options) {
    return options.typescript.createMethod(options.hook("decorators", options.nextNodes(node.decorators), node.decorators), options.hook("modifiers", options.nextNodes(node.modifiers), node.modifiers), options.hook("asteriskToken", options.nextNode(node.asteriskToken), node.asteriskToken), options.hook("name", options.nextNode(node.name), node.name), options.hook("questionToken", options.nextNode(node.questionToken), node.questionToken), options.hook("typeParameters", options.nextNodes(node.typeParameters), node.typeParameters), options.hook("parameters", options.nextNodes(node.parameters), node.parameters), options.hook("type", options.nextNode(node.type), node.type), options.hook("body", options.nextNode(node.body), node.body));
}

function cloneConstructorDeclaration(node, options) {
    return options.typescript.createConstructor(options.hook("decorators", options.nextNodes(node.decorators), node.decorators), options.hook("modifiers", options.nextNodes(node.modifiers), node.modifiers), options.hook("parameters", options.nextNodes(node.parameters), node.parameters), options.hook("body", options.nextNode(node.body), node.body));
}

function cloneSemicolonClassElement(_node, options) {
    return options.typescript.createSemicolonClassElement();
}

function cloneGetAccessorDeclaration(node, options) {
    return options.typescript.createGetAccessor(options.hook("decorators", options.nextNodes(node.decorators), node.decorators), options.hook("modifiers", options.nextNodes(node.modifiers), node.modifiers), options.hook("name", options.nextNode(node.name), node.name), options.hook("parameters", options.nextNodes(node.parameters), node.parameters), options.hook("type", options.nextNode(node.type), node.type), options.hook("body", options.nextNode(node.body), node.body));
}

function cloneSetAccessorDeclaration(node, options) {
    return options.typescript.createSetAccessor(options.hook("decorators", options.nextNodes(node.decorators), node.decorators), options.hook("modifiers", options.nextNodes(node.modifiers), node.modifiers), options.hook("name", options.nextNode(node.name), node.name), options.hook("parameters", options.nextNodes(node.parameters), node.parameters), options.hook("body", options.nextNode(node.body), node.body));
}

function cloneIndexSignatureDeclaration(node, options) {
    return options.typescript.createIndexSignature(options.hook("decorators", options.nextNodes(node.decorators), node.decorators), options.hook("modifiers", options.nextNodes(node.modifiers), node.modifiers), options.hook("parameters", options.nextNodes(node.parameters), node.parameters), options.hook("type", options.nextNode(node.type), node.type));
}

/**
 * Returns true if the given Node is a KeywordTypeNode
 */
function isKeywordTypeNode(node, typescript) {
    switch (node.kind) {
        case typescript.SyntaxKind.AnyKeyword:
        case typescript.SyntaxKind.UnknownKeyword:
        case typescript.SyntaxKind.BigIntKeyword:
        case typescript.SyntaxKind.ObjectKeyword:
        case typescript.SyntaxKind.BooleanKeyword:
        case typescript.SyntaxKind.StringKeyword:
        case typescript.SyntaxKind.SymbolKeyword:
        case typescript.SyntaxKind.VoidKeyword:
        case typescript.SyntaxKind.UndefinedKeyword:
        case typescript.SyntaxKind.NullKeyword:
        case typescript.SyntaxKind.NeverKeyword:
            return true;
    }
    return false;
}

function cloneKeywordTypeNode(node, options) {
    return options.typescript.createKeywordTypeNode(options.hook("kind", node.kind, node.kind));
}

function cloneImportTypeNode(node, options) {
    return options.typescript.createImportTypeNode(options.hook("argument", options.nextNode(node.argument), node.argument), options.hook("qualifier", options.nextNode(node.qualifier), node.qualifier), options.hook("typeArguments", options.nextNodes(node.typeArguments), node.typeArguments), options.hook("isTypeOf", node.isTypeOf, node.isTypeOf));
}

function cloneThisTypeNode(_node, options) {
    return options.typescript.createThisTypeNode();
}

function cloneFunctionTypeNode(node, options) {
    return options.typescript.createFunctionTypeNode(options.hook("typeParameters", options.nextNodes(node.typeParameters), node.typeParameters), options.hook("parameters", options.nextNodes(node.parameters), node.parameters), options.hook("type", options.nextNode(node.type), node.type));
}

function cloneConstructorTypeNode(node, options) {
    return options.typescript.createConstructorTypeNode(options.hook("typeParameters", options.nextNodes(node.typeParameters), node.typeParameters), options.hook("parameters", options.nextNodes(node.parameters), node.parameters), options.hook("type", options.nextNode(node.type), node.type));
}

function cloneTypeReferenceNode(node, options) {
    return options.typescript.createTypeReferenceNode(options.hook("typeName", options.nextNode(node.typeName), node.typeName), options.hook("typeArguments", options.nextNodes(node.typeArguments), node.typeArguments));
}

function cloneTypePredicateNode(node, options) {
    return options.typescript.createTypePredicateNode(options.hook("parameterName", options.nextNode(node.parameterName), node.parameterName), options.hook("type", options.nextNode(node.type), node.type));
}

function cloneSourceFile(node, options) {
    const updatedSourceFile = options.typescript.updateSourceFileNode(node, options.hook("statements", options.nextNodes(node.statements), node.statements), node.isDeclarationFile, node.referencedFiles, node.typeReferenceDirectives, node.hasNoDefaultLib, node.libReferenceDirectives);
    updatedSourceFile.pos = -1;
    updatedSourceFile.end = -1;
    return updatedSourceFile;
}

function cloneTypeQueryNode(node, options) {
    return options.typescript.createTypeQueryNode(options.hook("exprName", options.nextNode(node.exprName), node.exprName));
}

function cloneTypeLiteralNode(node, options) {
    return options.typescript.createTypeLiteralNode(options.hook("members", options.nextNodes(node.members), node.members));
}

function cloneArrayTypeNode(node, options) {
    return options.typescript.createArrayTypeNode(options.hook("elementType", node.elementType, node.elementType)
    // options.hook("elementType", options.nextNode(node.elementType), node.elementType)
    );
}

function cloneTupleTypeNode(node, options) {
    return options.typescript.createTupleTypeNode(options.hook("elementTypes", options.nextNodes(node.elementTypes), node.elementTypes));
}

function cloneOptionalTypeNode(node, options) {
    return options.typescript.createOptionalTypeNode(options.hook("type", options.nextNode(node.type), node.type));
}

/**
 * Returns true if the given Node is an OptionalTypeNode
 */
function isOptionalTypeNode(node, typescript) {
    return node.kind === typescript.SyntaxKind.OptionalType;
}

function cloneRestTypeNode(node, options) {
    return options.typescript.createRestTypeNode(options.hook("type", options.nextNode(node.type), node.type));
}

/**
 * Returns true if the given Node is a RestTypeNode
 */
function isRestTypeNode(node, typescript) {
    return node.kind === typescript.SyntaxKind.RestType;
}

function cloneUnionTypeNode(node, options) {
    return options.typescript.createUnionTypeNode(options.hook("types", options.nextNodes(node.types), node.types));
}

function cloneIntersectionTypeNode(node, options) {
    return options.typescript.createIntersectionTypeNode(options.hook("types", options.nextNodes(node.types), node.types));
}

function cloneLiteralTypeNode(node, options) {
    return options.typescript.createLiteralTypeNode(options.hook("literal", options.nextNode(node.literal), node.literal));
}

function cloneStringLiteral(node, options) {
    return options.typescript.createStringLiteral(options.hook("text", node.text, node.text));
}

/**
 * Returns true if the given Node is either the boolean Literal 'true' or 'false'
 */
function isBooleanLiteral(node, typescript) {
    switch (node.kind) {
        case typescript.SyntaxKind.TrueKeyword:
        case typescript.SyntaxKind.FalseKeyword:
            return true;
        default:
            return false;
    }
}

function cloneBooleanLiteral(node, options) {
    if (node.kind === options.typescript.SyntaxKind.TrueKeyword) {
        return options.typescript.createTrue();
    }
    return options.typescript.createFalse();
}

function clonePrefixUnaryExpression(node, options) {
    return options.typescript.createPrefix(options.hook("operator", node.operator, node.operator), options.hook("operand", options.nextNode(node.operand), node.operand));
}

function cloneRegularExpressionLiteral(node, options) {
    return options.typescript.createRegularExpressionLiteral(options.hook("text", node.text, node.text));
}

function cloneNoSubstitutionTemplateLiteral(node, options) {
    return options.typescript.createNoSubstitutionTemplateLiteral(options.hook("text", node.text, node.text), options.hook("rawText", node.rawText, node.text));
}

function cloneNumericLiteral(node, options) {
    return options.typescript.createNumericLiteral(options.hook("text", node.text, node.text));
}

function cloneBigIntLiteral(node, options) {
    return options.typescript.createBigIntLiteral(options.hook("text", node.text, node.text));
}

function cloneConditionalTypeNode(node, options) {
    return options.typescript.createConditionalTypeNode(options.hook("checkType", options.nextNode(node.checkType), node.checkType), options.hook("extendsType", options.nextNode(node.extendsType), node.extendsType), options.hook("trueType", options.nextNode(node.trueType), node.trueType), options.hook("falseType", options.nextNode(node.falseType), node.falseType));
}

function cloneInferTypeNode(node, options) {
    return options.typescript.createInferTypeNode(options.hook("typeParameter", options.nextNode(node.typeParameter), node.typeParameter));
}

function cloneBlock(node, options) {
    return options.typescript.createBlock(options.hook("statements", options.nextNodes(node.statements), node.statements));
}

function cloneThrowStatement(node, options) {
    return options.typescript.createThrow(options.hook("expression", options.nextNode(node.expression), node.expression));
}

function cloneNewExpression(node, options) {
    return options.typescript.createNew(options.hook("expression", options.nextNode(node.expression), node.expression), options.hook("typeArguments", options.nextNodes(node.typeArguments), node.typeArguments), options.hook("arguments", options.nextNodes(node.arguments), node.arguments));
}

function cloneCallExpression(node, options) {
    return options.typescript.createCall(options.hook("expression", options.nextNode(node.expression), node.expression), options.hook("typeArguments", options.nextNodes(node.typeArguments), node.typeArguments), options.hook("arguments", options.nextNodes(node.arguments), node.arguments));
}

function cloneExpressionStatement(node, options) {
    return options.typescript.createExpressionStatement(options.hook("expression", options.nextNode(node.expression), node.expression));
}

function cloneExpressionWithTypeArguments(node, options) {
    return options.typescript.createExpressionWithTypeArguments(options.hook("typeArguments", options.nextNodes(node.typeArguments), node.typeArguments), options.hook("expression", options.nextNode(node.expression), node.expression));
}

function clonePropertyAccessExpression(node, options) {
    return options.typescript.createPropertyAccess(options.hook("expression", options.nextNode(node.expression), node.expression), options.hook("name", options.nextNode(node.name), node.name));
}

function cloneElementAccessExpression(node, options) {
    return options.typescript.createElementAccess(options.hook("expression", options.nextNode(node.expression), node.expression), options.hook("argumentExpression", options.nextNode(node.argumentExpression), node.argumentExpression));
}

function cloneArrayLiteralExpression(node, options) {
    return options.typescript.createArrayLiteral(options.hook("elements", options.nextNodes(node.elements), node.elements));
}

function cloneObjectLiteralExpression(node, options) {
    return options.typescript.createObjectLiteral(options.hook("properties", options.nextNodes(node.properties), node.properties));
}

function cloneTemplateExpression(node, options) {
    return options.typescript.createTemplateExpression(options.hook("head", options.nextNode(node.head), node.head), options.hook("templateSpans", options.nextNodes(node.templateSpans), node.templateSpans));
}

function cloneTemplateSpan(node, options) {
    return options.typescript.createTemplateSpan(options.hook("expression", options.nextNode(node.expression), node.expression), options.hook("literal", options.nextNode(node.literal), node.literal));
}

function cloneTemplateHead(node, options) {
    return options.typescript.createTemplateHead(options.hook("text", node.text, node.text), options.hook("rawText", node.rawText, node.rawText));
}

function cloneTemplateMiddle(node, options) {
    return options.typescript.createTemplateMiddle(options.hook("text", node.text, node.text), options.hook("rawText", node.rawText, node.rawText));
}

function cloneTemplateTail(node, options) {
    return options.typescript.createTemplateTail(options.hook("text", node.text, node.text), options.hook("rawText", node.rawText, node.rawText));
}

function cloneConditionalExpression(node, options) {
    return options.typescript.createConditional(options.hook("condition", options.nextNode(node.condition), node.condition), options.hook("questionToken", options.nextNode(node.questionToken), node.questionToken), options.hook("whenTrue", options.nextNode(node.whenTrue), node.whenTrue), options.hook("colonToken", options.nextNode(node.colonToken), node.colonToken), options.hook("whenFalse", options.nextNode(node.whenFalse), node.whenFalse));
}

function cloneBinaryExpression(node, options) {
    return options.typescript.createBinary(options.hook("left", options.nextNode(node.left), node.left), options.hook("operatorToken", options.nextNode(node.operatorToken), node.operatorToken), options.hook("right", options.nextNode(node.right), node.right));
}

function cloneParenthesizedExpression(node, options) {
    return options.typescript.createParen(options.hook("expression", options.nextNode(node.expression), node.expression));
}

function cloneParenthesizedTypeNode(node, options) {
    return options.typescript.createParenthesizedType(options.hook("type", options.nextNode(node.type), node.type));
}

function cloneArrowFunction(node, options) {
    return options.typescript.createArrowFunction(options.hook("modifiers", options.nextNodes(node.modifiers), node.modifiers), options.hook("typeParameters", options.nextNodes(node.typeParameters), node.typeParameters), options.hook("parameters", options.nextNodes(node.parameters), node.parameters), options.hook("type", options.nextNode(node.type), node.type), options.hook("equalsGreaterThanToken", options.nextNode(node.equalsGreaterThanToken), node.equalsGreaterThanToken), options.hook("body", options.nextNode(node.body), node.body));
}

function cloneClassDeclaration(node, options) {
    return options.typescript.createClassDeclaration(options.hook("decorators", options.nextNodes(node.decorators), node.decorators), options.hook("modifiers", options.nextNodes(node.modifiers), node.modifiers), options.hook("name", options.nextNode(node.name), node.name), options.hook("typeParameters", options.nextNodes(node.typeParameters), node.typeParameters), options.hook("heritageClauses", options.nextNodes(node.heritageClauses), node.heritageClauses), options.hook("members", options.nextNodes(node.members), node.members));
}

function cloneClassExpression(node, options) {
    return options.typescript.createClassExpression(options.hook("modifiers", options.nextNodes(node.modifiers), node.modifiers), options.hook("name", options.nextNode(node.name), node.name), options.hook("typeParameters", options.nextNodes(node.typeParameters), node.typeParameters), options.hook("heritageClauses", options.nextNodes(node.heritageClauses), node.heritageClauses), options.hook("members", options.nextNodes(node.members), node.members));
}

function cloneEnumDeclaration(node, options) {
    return options.typescript.createEnumDeclaration(options.hook("decorators", options.nextNodes(node.decorators), node.decorators), options.hook("modifiers", options.nextNodes(node.modifiers), node.modifiers), options.hook("name", options.nextNode(node.name), node.name), options.hook("members", options.nextNodes(node.members), node.members));
}

function cloneInterfaceDeclaration(node, options) {
    return options.typescript.createInterfaceDeclaration(options.hook("decorators", options.nextNodes(node.decorators), node.decorators), options.hook("modifiers", options.nextNodes(node.modifiers), node.modifiers), options.hook("name", options.nextNode(node.name), node.name), options.hook("typeParameters", options.nextNodes(node.typeParameters), node.typeParameters), options.hook("heritageClauses", options.nextNodes(node.heritageClauses), node.heritageClauses), options.hook("members", options.nextNodes(node.members), node.members));
}

function cloneEnumMember(node, options) {
    return options.typescript.createEnumMember(options.hook("name", options.nextNode(node.name), node.name), options.hook("initializer", options.nextNode(node.initializer), node.initializer));
}

function cloneHeritageClause(node, options) {
    return options.typescript.createHeritageClause(options.hook("token", node.token, node.token), options.hook("types", options.nextNodes(node.types), node.types));
}

function cloneEmptyStatement(_node, options) {
    return options.typescript.createEmptyStatement();
}

function cloneTypeOperatorNode(node, options) {
    return options.typescript.createTypeOperatorNode(options.hook("operator", node.operator, node.operator), options.hook("type", options.nextNode(node.type), node.type));
}

function cloneIndexedAccessTypeNode(node, options) {
    return options.typescript.createIndexedAccessTypeNode(options.hook("objectType", options.nextNode(node.objectType), node.objectType), options.hook("indexType", options.nextNode(node.indexType), node.indexType));
}

function cloneMappedTypeNode(node, options) {
    return options.typescript.createMappedTypeNode(options.hook("readonlyToken", options.nextNode(node.readonlyToken), node.readonlyToken), options.hook("typeParameter", options.nextNode(node.typeParameter), node.typeParameter), options.hook("questionToken", options.nextNode(node.questionToken), node.questionToken), options.hook("type", options.nextNode(node.type), node.type));
}

function cloneOmittedExpression(_node, options) {
    return options.typescript.createOmittedExpression();
}

function clonePartiallyEmittedExpression(node, options) {
    return options.typescript.createPartiallyEmittedExpression(options.hook("expression", options.nextNode(node.expression), node.expression));
}

/**
 * Returns true if the given Node is a PartiallyEmittedExpression
 */
function isPartiallyEmittedExpression(node, typescript) {
    return node.kind === typescript.SyntaxKind.PartiallyEmittedExpression;
}

function clonePostfixUnaryExpression(node, options) {
    return options.typescript.createPostfix(options.hook("operand", options.nextNode(node.operand), node.operand), options.hook("operator", node.operator, node.operator));
}

/**
 * Returns true if the given Node is the literal 'null'
 */
function isNullLiteral(node, typescript) {
    return node.kind === typescript.SyntaxKind.NullKeyword;
}

function cloneNullLiteral(_node, options) {
    return options.typescript.createNull();
}

/**
 * Returns true if the given Node is a ThisExpression
 */
function isThisExpression(node, typescript) {
    return node.kind === typescript.SyntaxKind.ThisKeyword;
}

function cloneThisExpression(_node, options) {
    return options.typescript.createThis();
}

function cloneReturnStatement(node, options) {
    return options.typescript.createReturn(options.hook("expression", options.nextNode(node.expression), node.expression));
}

function isSuperExpression(node, typescript) {
    return node.kind === typescript.SyntaxKind.SuperKeyword;
}

function cloneSuperExpression(_node, options) {
    return options.typescript.createSuper();
}

function cloneDeleteExpression(node, options) {
    return options.typescript.createDelete(options.hook("expression", options.nextNode(node.expression), node.expression));
}

function cloneAsExpression(node, options) {
    return options.typescript.createAsExpression(options.hook("expression", options.nextNode(node.expression), node.expression), options.hook("type", options.nextNode(node.type), node.type));
}

function cloneTypeAssertion(node, options) {
    return options.typescript.createTypeAssertion(options.hook("type", options.nextNode(node.type), node.type), options.hook("expression", options.nextNode(node.expression), node.expression));
}

function cloneAwaitExpression(node, options) {
    return options.typescript.createAwait(options.hook("expression", options.nextNode(node.expression), node.expression));
}

function cloneYieldExpression(node, options) {
    return options.typescript.createYield(options.hook("asteriskToken", options.nextNode(node.asteriskToken), node.asteriskToken), options.hook("expression", options.nextNode(node.expression), node.expression));
}

function cloneForOfStatement(node, options) {
    return options.typescript.createForOf(options.hook("awaitModifier", options.nextNode(node.awaitModifier), node.awaitModifier), options.hook("initializer", options.nextNode(node.initializer), node.initializer), options.hook("expression", options.nextNode(node.expression), node.expression), options.hook("statement", options.nextNode(node.statement), node.statement));
}

function cloneForInStatement(node, options) {
    return options.typescript.createForIn(options.hook("initializer", options.nextNode(node.initializer), node.initializer), options.hook("expression", options.nextNode(node.expression), node.expression), options.hook("statement", options.nextNode(node.statement), node.statement));
}

function cloneForStatement(node, options) {
    return options.typescript.createFor(options.hook("initializer", options.nextNode(node.initializer), node.initializer), options.hook("condition", options.nextNode(node.condition), node.condition), options.hook("incrementor", options.nextNode(node.incrementor), node.incrementor), options.hook("statement", options.nextNode(node.statement), node.statement));
}

function cloneWhileStatement(node, options) {
    return options.typescript.createWhile(options.hook("expression", options.nextNode(node.expression), node.expression), options.hook("statement", options.nextNode(node.statement), node.statement));
}

function cloneLabeledStatement(node, options) {
    return options.typescript.createLabel(options.hook("label", options.nextNode(node.label), node.label), options.hook("statement", options.nextNode(node.statement), node.statement));
}

function cloneBreakStatement(node, options) {
    return options.typescript.createBreak(options.hook("label", options.nextNode(node.label), node.label));
}

function cloneContinueStatement(node, options) {
    return options.typescript.createContinue(options.hook("label", options.nextNode(node.label), node.label));
}

function cloneIfStatement(node, options) {
    return options.typescript.createIf(options.hook("expression", options.nextNode(node.expression), node.expression), options.hook("thenStatement", options.nextNode(node.thenStatement), node.thenStatement), options.hook("elseStatement", options.nextNode(node.elseStatement), node.elseStatement));
}

function cloneDoStatement(node, options) {
    return options.typescript.createDo(options.hook("statement", options.nextNode(node.statement), node.statement), options.hook("expression", options.nextNode(node.expression), node.expression));
}

function cloneNonNullExpression(node, options) {
    return options.typescript.createNonNullExpression(options.hook("expression", options.nextNode(node.expression), node.expression));
}

function cloneTypeOfExpression(node, options) {
    return options.typescript.createTypeOf(options.hook("expression", options.nextNode(node.expression), node.expression));
}

function cloneVoidExpression(node, options) {
    return options.typescript.createVoid(options.hook("expression", options.nextNode(node.expression), node.expression));
}

function cloneFunctionExpression(node, options) {
    return options.typescript.createFunctionExpression(options.hook("modifiers", options.nextNodes(node.modifiers), node.modifiers), options.hook("asteriskToken", options.nextNode(node.asteriskToken), node.asteriskToken), options.hook("name", options.nextNode(node.name), node.name), options.hook("typeParameters", options.nextNodes(node.typeParameters), node.typeParameters), options.hook("parameters", options.nextNodes(node.parameters), node.parameters), options.hook("type", options.nextNode(node.type), node.type), options.hook("body", options.nextNode(node.body), node.body));
}

function cloneSpreadElement(node, options) {
    return options.typescript.createSpread(options.hook("expression", options.nextNode(node.expression), node.expression));
}

function cloneTaggedTemplateExpression(node, options) {
    return options.typescript.createTaggedTemplate(options.hook("tag", options.nextNode(node.tag), node.tag), options.hook("typeArguments", options.nextNodes(node.typeArguments), node.typeArguments), options.hook("template", options.nextNode(node.template), node.template));
}

function cloneMetaProperty(node, options) {
    return options.typescript.createMetaProperty(options.hook("keywordToken", node.keywordToken, node.keywordToken), options.hook("name", options.nextNode(node.name), node.name));
}

function cloneJsxElement(node, options) {
    return options.typescript.createJsxElement(options.hook("openingElement", options.nextNode(node.openingElement), node.openingElement), options.hook("children", options.nextNodes(node.children), node.children), options.hook("closingElement", options.nextNode(node.closingElement), node.closingElement));
}

function cloneJsxAttributes(node, options) {
    return options.typescript.createJsxAttributes(options.hook("properties", options.nextNodes(node.properties), node.properties));
}

function cloneJsxOpeningElement(node, options) {
    return options.typescript.createJsxOpeningElement(options.hook("tagName", options.nextNode(node.tagName), node.tagName), options.hook("typeArguments", options.nextNodes(node.typeArguments), node.typeArguments), options.hook("attributes", options.nextNode(node.attributes), node.attributes));
}

function cloneJsxSelfClosingElement(node, options) {
    return options.typescript.createJsxSelfClosingElement(options.hook("tagName", options.nextNode(node.tagName), node.tagName), options.hook("typeArguments", options.nextNodes(node.typeArguments), node.typeArguments), options.hook("attributes", options.nextNode(node.attributes), node.attributes));
}

function cloneJsxFragment(node, options) {
    return options.typescript.createJsxFragment(options.hook("openingFragment", options.nextNode(node.openingFragment), node.openingFragment), options.hook("children", options.nextNodes(node.children), node.children), options.hook("closingFragment", options.nextNode(node.closingFragment), node.closingFragment));
}

function cloneJsxOpeningFragment(_node, options) {
    return options.typescript.createJsxOpeningFragment();
}

function cloneJsxClosingFragment(_node, options) {
    return options.typescript.createJsxJsxClosingFragment();
}

function cloneJsxAttribute(node, options) {
    return options.typescript.createJsxAttribute(options.hook("name", options.nextNode(node.name), node.name), options.hook("initializer", options.nextNode(node.initializer), node.initializer));
}

function cloneJsxSpreadAttribute(node, options) {
    return options.typescript.createJsxSpreadAttribute(options.hook("expression", options.nextNode(node.expression), node.expression));
}

function cloneJsxClosingElement(node, options) {
    return options.typescript.createJsxClosingElement(options.hook("tagName", options.nextNode(node.tagName), node.tagName));
}

function cloneJsxExpression(node, options) {
    return options.typescript.createJsxExpression(options.hook("dotDotDotToken", options.nextNode(node.dotDotDotToken), node.dotDotDotToken), options.hook("expression", options.nextNode(node.expression), node.expression));
}

function cloneJsxText(node, options) {
    return options.typescript.createJsxText(options.hook("text", node.text, node.text), options.hook("containsOnlyTriviaWhiteSpaces", node.containsOnlyTriviaWhiteSpaces, node.containsOnlyTriviaWhiteSpaces));
}

/**
 * Returns true if the given Node is a NotEmittedStatement
 */
function isNotEmittedStatement(node, typescript) {
    return node.kind === typescript.SyntaxKind.NotEmittedStatement;
}

function cloneNotEmittedStatement(node, options) {
    return options.typescript.createNotEmittedStatement(node);
}

/**
 * Returns true if the given Node is a CommaListExpression
 */
function isCommaListExpression(node, typescript) {
    return node.kind === typescript.SyntaxKind.CommaListExpression;
}

function cloneCommaListExpression(node, options) {
    return options.typescript.createCommaList(options.hook("elements", options.nextNodes(node.elements), node.elements));
}

function cloneDebuggerStatement(_node, options) {
    return options.typescript.createDebuggerStatement();
}

function cloneWithStatement(node, options) {
    return options.typescript.createWith(options.hook("expression", options.nextNode(node.expression), node.expression), options.hook("statement", options.nextNode(node.statement), node.statement));
}

function cloneSwitchStatement(node, options) {
    return options.typescript.createSwitch(options.hook("expression", options.nextNode(node.expression), node.expression), options.hook("caseBlock", options.nextNode(node.caseBlock), node.caseBlock));
}

function cloneCaseBlock(node, options) {
    return options.typescript.createCaseBlock(options.hook("clauses", options.nextNodes(node.clauses), node.clauses));
}

function cloneCaseClause(node, options) {
    return options.typescript.createCaseClause(options.hook("expression", options.nextNode(node.expression), node.expression), options.hook("statements", options.nextNodes(node.statements), node.statements));
}

function cloneDefaultClause(node, options) {
    return options.typescript.createDefaultClause(options.hook("statements", options.nextNodes(node.statements), node.statements));
}

function cloneTryStatement(node, options) {
    return options.typescript.createTry(options.hook("tryBlock", options.nextNode(node.tryBlock), node.tryBlock), options.hook("catchClause", options.nextNode(node.catchClause), node.catchClause), options.hook("finallyBlock", options.nextNode(node.finallyBlock), node.finallyBlock));
}

function cloneCatchClause(node, options) {
    return options.typescript.createCatchClause(options.hook("variableDeclaration", options.nextNode(node.variableDeclaration), node.variableDeclaration), options.hook("block", options.nextNode(node.block), node.block));
}

function cloneModuleDeclaration(node, options) {
    return options.typescript.createModuleDeclaration(options.hook("decorators", options.nextNodes(node.decorators), node.decorators), options.hook("modifiers", options.nextNodes(node.modifiers), node.modifiers), options.hook("name", options.nextNode(node.name), node.name), options.hook("body", options.nextNode(node.body), node.body), options.hook("flags", node.flags, node.flags));
}

function cloneModuleBlock(node, options) {
    return options.typescript.createModuleBlock(options.hook("statements", options.nextNodes(node.statements), node.statements));
}

function cloneImportDeclaration(node, options) {
    return options.typescript.createImportDeclaration(options.hook("decorators", options.nextNodes(node.decorators), node.decorators), options.hook("modifiers", options.nextNodes(node.modifiers), node.modifiers), options.hook("importClause", options.nextNode(node.importClause), node.importClause), options.hook("moduleSpecifier", options.nextNode(node.moduleSpecifier), node.moduleSpecifier));
}

function cloneImportEqualsDeclaration(node, options) {
    return options.typescript.createImportEqualsDeclaration(options.hook("decorators", options.nextNodes(node.decorators), node.decorators), options.hook("modifiers", options.nextNodes(node.modifiers), node.modifiers), options.hook("name", options.nextNode(node.name), node.name), options.hook("moduleReference", options.nextNode(node.moduleReference), node.moduleReference));
}

function cloneImportClause(node, options) {
    return options.typescript.createImportClause(options.hook("name", options.nextNode(node.name), node.name), options.hook("namedBindings", options.nextNode(node.namedBindings), node.namedBindings), options.hook("isTypeOnly", node.isTypeOnly, node.isTypeOnly));
}

function cloneNamedImports(node, options) {
    return options.typescript.createNamedImports(options.hook("elements", options.nextNodes(node.elements), node.elements));
}

function cloneNamespaceImport(node, options) {
    return options.typescript.createNamespaceImport(options.hook("name", options.nextNode(node.name), node.name));
}

function cloneImportSpecifier(node, options) {
    return options.typescript.createImportSpecifier(options.hook("propertyName", options.nextNode(node.propertyName), node.propertyName), options.hook("name", options.nextNode(node.name), node.name));
}

function cloneExternalModuleReference(node, options) {
    return options.typescript.createExternalModuleReference(options.hook("expression", options.nextNode(node.expression), node.expression));
}

function cloneNamespaceExportDeclaration(node, options) {
    return options.typescript.createNamespaceExportDeclaration(options.hook("name", options.nextNode(node.name), node.name));
}

function cloneExportDeclaration(node, options) {
    return options.typescript.createExportDeclaration(options.hook("decorators", options.nextNodes(node.decorators), node.decorators), options.hook("modifiers", options.nextNodes(node.modifiers), node.modifiers), options.hook("exportClause", options.nextNode(node.exportClause), node.exportClause), options.hook("moduleSpecifier", options.nextNode(node.moduleSpecifier), node.moduleSpecifier));
}

function cloneNamedExports(node, options) {
    return options.typescript.createNamedExports(options.hook("elements", options.nextNodes(node.elements), node.elements));
}

function cloneExportSpecifier(node, options) {
    return options.typescript.createExportSpecifier(options.hook("propertyName", options.nextNode(node.propertyName), node.propertyName), options.hook("name", options.nextNode(node.name), node.name));
}

function cloneExportAssignment(node, options) {
    return options.typescript.createExportAssignment(options.hook("decorators", options.nextNodes(node.decorators), node.decorators), options.hook("modifiers", options.nextNodes(node.modifiers), node.modifiers), options.hook("isExportEquals", node.isExportEquals, node.isExportEquals), options.hook("expression", options.nextNode(node.expression), node.expression));
}

/* eslint-disable @typescript-eslint/no-unused-vars */
function toInternalOptions(options) {
    var _a, _b, _c, _d, _e, _f, _g;
    return Object.assign(Object.assign({}, options), { typescript: (_a = options.typescript) !== null && _a !== void 0 ? _a : TSModule, setParents: (_b = options.setParents) !== null && _b !== void 0 ? _b : false, setOriginalNodes: (_c = options.setOriginalNodes) !== null && _c !== void 0 ? _c : false, preserveSymbols: (_d = options.preserveSymbols) !== null && _d !== void 0 ? _d : false, preserveComments: (_e = options.preserveComments) !== null && _e !== void 0 ? _e : true, commentRanges: new Set(), depth: 0, hook: (_f = options.hook) !== null && _f !== void 0 ? _f : (_ => ({})), finalize: (_g = options.finalize) !== null && _g !== void 0 ? _g : (_ => {
            // Noop
        }) });
}

/**
 * Returns true if the given Node is a JSDocComment
 */
function isJsDocComment(node, typescript) {
    return node.kind === typescript.SyntaxKind.JSDocComment;
}

function cloneJsDoc(node, options) {
    const baseNode = options.typescript.createNode(options.typescript.SyntaxKind.JSDocComment, -1, -1);
    baseNode.flags = options.hook("flags", (node.flags |= 8), (node.flags |= 8));
    baseNode.comment = options.hook("comment", node.comment, node.comment);
    baseNode.tags = ensureNodeArray(options.hook("tags", options.nextNodes(node.tags), node.tags), options.typescript);
    return baseNode;
}

/**
 * Returns true if the given Node is a JSDocUnknownTag
 */
function isJsDocUnknownTag(node, typescript) {
    return node.kind === typescript.SyntaxKind.JSDocTag;
}

/**
 * Returns true if the given Node is a JSDocParameterTag
 */
function isJsDocParameterTag(node, typescript) {
    return node.kind === typescript.SyntaxKind.JSDocParameterTag;
}

function cloneJsDocParameterTag(node, options) {
    const baseNode = options.typescript.createNode(options.typescript.SyntaxKind.JSDocParameterTag, -1, -1);
    baseNode.flags = options.hook("flags", (node.flags |= 8), (node.flags |= 8));
    baseNode.comment = options.hook("comment", node.comment, node.comment);
    baseNode.tagName = options.hook("tagName", options.nextNode(node.tagName), node.tagName);
    baseNode.name = options.hook("name", options.nextNode(node.name), node.name);
    baseNode.typeExpression = options.hook("typeExpression", options.nextNode(node.typeExpression), node.typeExpression);
    baseNode.isNameFirst = options.hook("isNameFirst", node.isNameFirst, node.isNameFirst);
    baseNode.isBracketed = options.hook("isBracketed", node.isBracketed, node.isBracketed);
    return baseNode;
}

/**
 * Returns true if the given Node is a JSDocReturnTag
 */
function isJsDocReturnTag(node, typescript) {
    return node.kind === typescript.SyntaxKind.JSDocReturnTag;
}

function cloneJsDocReturnTag(node, options) {
    const baseNode = options.typescript.createNode(options.typescript.SyntaxKind.JSDocReturnTag, -1, -1);
    baseNode.flags = options.hook("flags", (node.flags |= 8), (node.flags |= 8));
    baseNode.comment = options.hook("comment", node.comment, node.comment);
    baseNode.tagName = options.hook("tagName", options.nextNode(node.tagName), node.tagName);
    baseNode.typeExpression = options.hook("typeExpression", options.nextNode(node.typeExpression), node.typeExpression);
    return baseNode;
}

/**
 * Returns true if the given Node is a JSDocTypeExpression
 */
function isJsDocTypeExpression(node, typescript) {
    return node.kind === typescript.SyntaxKind.JSDocTypeExpression;
}

function cloneJsDocTypeExpression(node, options) {
    const baseNode = options.typescript.createNode(options.typescript.SyntaxKind.JSDocTypeExpression, -1, -1);
    baseNode.flags = options.hook("flags", (node.flags |= 8), (node.flags |= 8));
    baseNode.type = options.hook("type", options.nextNode(node.type), node.type);
    return baseNode;
}

/**
 * Returns true if the given Node is a JSDocEnumTag
 */
function isJsDocEnumTag(node, typescript) {
    return node.kind === typescript.SyntaxKind.JSDocEnumTag;
}

function cloneJsDocEnumTag(node, options) {
    const baseNode = options.typescript.createNode(options.typescript.SyntaxKind.JSDocEnumTag, -1, -1);
    baseNode.flags = options.hook("flags", (node.flags |= 8), (node.flags |= 8));
    baseNode.comment = options.hook("comment", node.comment, node.comment);
    baseNode.tagName = options.hook("tagName", options.nextNode(node.tagName), node.tagName);
    baseNode.typeExpression = options.hook("typeExpression", options.nextNode(node.typeExpression), node.typeExpression);
    return baseNode;
}

/**
 * Returns true if the given Node is a JSDocTypeTag
 */
function isJsDocTypeTag(node, typescript) {
    return node.kind === typescript.SyntaxKind.JSDocTypeTag;
}

function cloneJsDocTypeTag(node, options) {
    const baseNode = options.typescript.createNode(options.typescript.SyntaxKind.JSDocTypeTag, -1, -1);
    baseNode.flags = options.hook("flags", (node.flags |= 8), (node.flags |= 8));
    baseNode.comment = options.hook("comment", node.comment, node.comment);
    baseNode.tagName = options.hook("tagName", options.nextNode(node.tagName), node.tagName);
    baseNode.typeExpression = options.hook("typeExpression", options.nextNode(node.typeExpression), node.typeExpression);
    return baseNode;
}

/**
 * Returns true if the given Node is a JSDocAllType
 */
function isJsDocAllType(node, typescript) {
    return node.kind === typescript.SyntaxKind.JSDocAllType;
}

function cloneJSDocAllType(node, options) {
    const baseNode = options.typescript.createNode(options.typescript.SyntaxKind.JSDocAllType, -1, -1);
    baseNode.flags = options.hook("flags", (node.flags |= 8), (node.flags |= 8));
    return baseNode;
}

/**
 * Returns true if the given Node is a JSDocUnknownType
 */
function isJsDocUnknownType(node, typescript) {
    return node.kind === typescript.SyntaxKind.JSDocUnknownType;
}

function cloneJSDocUnknownType(node, options) {
    const baseNode = options.typescript.createNode(options.typescript.SyntaxKind.JSDocUnknownType, -1, -1);
    baseNode.flags = options.hook("flags", (node.flags |= 8), (node.flags |= 8));
    return baseNode;
}

/**
 * Returns true if the given Node is a JSDocNonNullableType
 */
function isJsDocNonNullableType(node, typescript) {
    return node.kind === typescript.SyntaxKind.JSDocNonNullableType;
}

function cloneJSDocNonNullableType(node, options) {
    const baseNode = options.typescript.createNode(options.typescript.SyntaxKind.JSDocNonNullableType, -1, -1);
    baseNode.flags = options.hook("flags", (node.flags |= 8), (node.flags |= 8));
    baseNode.type = options.hook("type", options.nextNode(node.type), node.type);
    return baseNode;
}

/**
 * Returns true if the given Node is a JSDocNullableType
 */
function isJsDocNullableType(node, typescript) {
    return node.kind === typescript.SyntaxKind.JSDocNullableType;
}

function cloneJSDocNullableType(node, options) {
    const baseNode = options.typescript.createNode(options.typescript.SyntaxKind.JSDocNullableType, -1, -1);
    baseNode.flags = options.hook("flags", (node.flags |= 8), (node.flags |= 8));
    baseNode.type = options.hook("type", options.nextNode(node.type), node.type);
    return baseNode;
}

/**
 * Returns true if the given Node is a JSDocOptionalType
 */
function isJSDocOptionalType(node, typescript) {
    return node.kind === typescript.SyntaxKind.JSDocOptionalType;
}

function cloneJSDocOptionalType(node, options) {
    const baseNode = options.typescript.createNode(options.typescript.SyntaxKind.JSDocOptionalType, -1, -1);
    baseNode.flags = options.hook("flags", (node.flags |= 8), (node.flags |= 8));
    baseNode.type = options.hook("type", options.nextNode(node.type), node.type);
    return baseNode;
}

/**
 * Returns true if the given Node is a JSDocFunctionType
 */
function isJSDocFunctionType(node, typescript) {
    return node.kind === typescript.SyntaxKind.JSDocFunctionType;
}

function cloneJSDocFunctionType(node, options) {
    const baseNode = options.typescript.createNode(options.typescript.SyntaxKind.JSDocFunctionType, -1, -1);
    baseNode.flags = options.hook("flags", (node.flags |= 8), (node.flags |= 8));
    return baseNode;
}

/**
 * Returns true if the given Node is a JSDocVariadicType
 */
function isJSDocVariadicType(node, typescript) {
    return node.kind === typescript.SyntaxKind.JSDocVariadicType;
}

function cloneJSDocVariadicType(node, options) {
    const baseNode = options.typescript.createNode(options.typescript.SyntaxKind.JSDocVariadicType, -1, -1);
    baseNode.flags = options.hook("flags", (node.flags |= 8), (node.flags |= 8));
    baseNode.type = options.hook("type", options.nextNode(node.type), node.type);
    return baseNode;
}

/**
 * Returns true if the given Node is a JSDocNamepathType
 */
function isJSDocNamepathType(node, typescript) {
    return node.kind === typescript.SyntaxKind.JSDocNamepathType;
}

function cloneJSDocNamepathType(node, options) {
    const baseNode = options.typescript.createNode(options.typescript.SyntaxKind.JSDocNamepathType, -1, -1);
    baseNode.flags = options.hook("flags", (node.flags |= 8), (node.flags |= 8));
    baseNode.type = options.hook("type", options.nextNode(node.type), node.type);
    return baseNode;
}

function cloneJsDocUnknownTag(node, options) {
    const baseNode = options.typescript.createNode(options.typescript.SyntaxKind.JSDocTag, -1, -1);
    baseNode.flags = options.hook("flags", (node.flags |= 8), (node.flags |= 8));
    baseNode.comment = options.hook("comment", node.comment, node.comment);
    baseNode.tagName = options.hook("tagName", options.nextNode(node.tagName), node.tagName);
    return baseNode;
}

/**
 * Returns true if the given Node is a JSDocAugmentsTag
 */
function isJSDocAugmentsTag(node, typescript) {
    return node.kind === typescript.SyntaxKind.JSDocAugmentsTag;
}

function cloneJSDocAugmentsTag(node, options) {
    const baseNode = options.typescript.createNode(options.typescript.SyntaxKind.JSDocAugmentsTag, -1, -1);
    baseNode.flags = options.hook("flags", (node.flags |= 8), (node.flags |= 8));
    baseNode.comment = options.hook("comment", node.comment, node.comment);
    baseNode.tagName = options.hook("tagName", options.nextNode(node.tagName), node.tagName);
    baseNode.class = options.hook("class", options.nextNode(node.class), node.class);
    return baseNode;
}

/**
 * Returns true if the given Node is a JSDocAuthorTag
 */
function isJSDocAuthorTag(node, typescript) {
    return node.kind === typescript.SyntaxKind.JSDocAuthorTag;
}

function cloneJsDocAuthorTag(node, options) {
    const baseNode = options.typescript.createNode(options.typescript.SyntaxKind.JSDocAuthorTag, -1, -1);
    baseNode.flags = options.hook("flags", (node.flags |= 8), (node.flags |= 8));
    baseNode.comment = options.hook("comment", node.comment, node.comment);
    baseNode.tagName = options.hook("tagName", options.nextNode(node.tagName), node.tagName);
    return baseNode;
}

/**
 * Returns true if the given Node is a JSDocClassTag
 */
function isJSDocClassTag(node, typescript) {
    return node.kind === typescript.SyntaxKind.JSDocClassTag;
}

function cloneJsDocClassTag(node, options) {
    const baseNode = options.typescript.createNode(options.typescript.SyntaxKind.JSDocClassTag, -1, -1);
    baseNode.flags = options.hook("flags", (node.flags |= 8), (node.flags |= 8));
    baseNode.comment = options.hook("comment", node.comment, node.comment);
    baseNode.tagName = options.hook("tagName", options.nextNode(node.tagName), node.tagName);
    return baseNode;
}

/**
 * Returns true if the given Node is a JSDocThisTag
 */
function isJSDocThisTag(node, typescript) {
    return node.kind === typescript.SyntaxKind.JSDocThisTag;
}

function cloneJSDocThisTag(node, options) {
    const baseNode = options.typescript.createNode(options.typescript.SyntaxKind.JSDocThisTag, -1, -1);
    baseNode.flags = options.hook("flags", (node.flags |= 8), (node.flags |= 8));
    baseNode.comment = options.hook("comment", node.comment, node.comment);
    baseNode.tagName = options.hook("tagName", options.nextNode(node.tagName), node.tagName);
    baseNode.typeExpression = options.hook("typeExpression", options.nextNode(node.typeExpression), node.typeExpression);
    return baseNode;
}

/**
 * Returns true if the given Node is a JSDocTemplateTag
 */
function isJSDocTemplateTag(node, typescript) {
    return node.kind === typescript.SyntaxKind.JSDocTemplateTag;
}

function cloneJSDocTemplateTag(node, options) {
    const baseNode = options.typescript.createNode(options.typescript.SyntaxKind.JSDocTemplateTag, -1, -1);
    baseNode.flags = options.hook("flags", (node.flags |= 8), (node.flags |= 8));
    baseNode.comment = options.hook("comment", node.comment, node.comment);
    baseNode.tagName = options.hook("tagName", options.nextNode(node.tagName), node.tagName);
    baseNode.constraint = options.hook("constraint", options.nextNode(node.constraint), node.constraint);
    baseNode.typeParameters = ensureNodeArray(options.hook("typeParameters", options.nextNodes(node.typeParameters), node.typeParameters), options.typescript);
    return baseNode;
}

/**
 * Returns true if the given Node is a JSDocTypedefTag
 */
function isJSDocTypedefTag(node, typescript) {
    return node.kind === typescript.SyntaxKind.JSDocTypedefTag;
}

function cloneJSDocTypedefTag(node, options) {
    const baseNode = options.typescript.createNode(options.typescript.SyntaxKind.JSDocTypedefTag, -1, -1);
    baseNode.flags = options.hook("flags", (node.flags |= 8), (node.flags |= 8));
    baseNode.comment = options.hook("comment", node.comment, node.comment);
    baseNode.tagName = options.hook("tagName", options.nextNode(node.tagName), node.tagName);
    baseNode.fullName = options.hook("fullName", options.nextNode(node.fullName), node.fullName);
    baseNode.name = options.hook("name", options.nextNode(node.name), node.name);
    baseNode.typeExpression = options.hook("typeExpression", options.nextNode(node.typeExpression), node.typeExpression);
    return baseNode;
}

/**
 * Returns true if the given Node is a JSDocCallbackTag
 */
function isJSDocCallbackTag(node, typescript) {
    return node.kind === typescript.SyntaxKind.JSDocCallbackTag;
}

function cloneJSDocCallbackTag(node, options) {
    const baseNode = options.typescript.createNode(options.typescript.SyntaxKind.JSDocCallbackTag, -1, -1);
    baseNode.flags = options.hook("flags", (node.flags |= 8), (node.flags |= 8));
    baseNode.comment = options.hook("comment", node.comment, node.comment);
    baseNode.tagName = options.hook("tagName", options.nextNode(node.tagName), node.tagName);
    baseNode.fullName = options.hook("fullName", options.nextNode(node.fullName), node.fullName);
    baseNode.name = options.hook("name", options.nextNode(node.name), node.name);
    baseNode.typeExpression = options.hook("typeExpression", options.nextNode(node.typeExpression), node.typeExpression);
    return baseNode;
}

/**
 * Returns true if the given Node is a JSDocSignature
 */
function isJSDocSignature(node, typescript) {
    return node.kind === typescript.SyntaxKind.JSDocSignature;
}

function cloneJSDocSignature(node, options) {
    const baseNode = options.typescript.createNode(options.typescript.SyntaxKind.JSDocSignature, -1, -1);
    baseNode.flags = options.hook("flags", (node.flags |= 8), (node.flags |= 8));
    baseNode.type = options.hook("type", options.nextNode(node.type), node.type);
    baseNode.typeParameters = options.hook("typeParameters", options.nextNodes(node.typeParameters), node.typeParameters);
    baseNode.parameters = options.hook("parameters", options.nextNodes(node.parameters), node.parameters);
    return baseNode;
}

/**
 * Returns true if the given Node is a JSDocPropertyTag
 */
function isJsDocPropertyTag(node, typescript) {
    return node.kind === typescript.SyntaxKind.JSDocPropertyTag;
}

function cloneJSDocPropertyTag(node, options) {
    const baseNode = options.typescript.createNode(options.typescript.SyntaxKind.JSDocPropertyTag, -1, -1);
    baseNode.flags = options.hook("flags", (node.flags |= 8), (node.flags |= 8));
    baseNode.comment = options.hook("comment", node.comment, node.comment);
    baseNode.tagName = options.hook("tagName", options.nextNode(node.tagName), node.tagName);
    baseNode.name = options.hook("name", options.nextNode(node.name), node.name);
    baseNode.typeExpression = options.hook("typeExpression", options.nextNode(node.typeExpression), node.typeExpression);
    baseNode.isNameFirst = options.hook("isNameFirst", node.isNameFirst, node.isNameFirst);
    baseNode.isBracketed = options.hook("isBracketed", node.isBracketed, node.isBracketed);
    return baseNode;
}

/**
 * Returns true if the given Node is a JSDocTypeLiteral
 */
function isJsDocTypeLiteral(node, typescript) {
    return node.kind === typescript.SyntaxKind.JSDocTypeLiteral;
}

function cloneJSDocTypeLiteral(node, options) {
    const baseNode = options.typescript.createNode(options.typescript.SyntaxKind.JSDocTypeLiteral, -1, -1);
    baseNode.jsDocPropertyTags = options.hook("jsDocPropertyTags", options.nextNodes(node.jsDocPropertyTags), node.jsDocPropertyTags);
    baseNode.isArrayType = options.hook("isArrayType", node.isArrayType, node.isArrayType);
    return baseNode;
}

function fixupParentReferences(rootNode, { deep, propertyName, typescript }) {
    let parent = rootNode;
    typescript.forEachChild(rootNode, visitNode);
    function visitNode(n) {
        if (n[propertyName] !== parent) {
            n[propertyName] = parent;
            const saveParent = parent;
            parent = n;
            if (deep) {
                typescript.forEachChild(n, visitNode);
            }
            if (n.jsDoc != null) {
                for (const jsDocComment of n.jsDoc) {
                    jsDocComment[propertyName] = n;
                    parent = jsDocComment;
                    typescript.forEachChild(jsDocComment, visitNode);
                }
            }
            parent = saveParent;
        }
    }
}
function setParents(node, options) {
    fixupParentReferences(node, options);
    return node;
}

function getOriginalNode(node, options) {
    var _a;
    if (node._original != null) {
        return getOriginalNode(node._original, options);
    }
    return (_a = options.typescript.getOriginalNode(node)) !== null && _a !== void 0 ? _a : node;
}

function formatCommentRange({ pos, end }) {
    return `${pos}:${end}`;
}
function getCommentRanges(node, options) {
    var _a, _b, _c, _d;
    const comments = [];
    const originalNode = getOriginalNode(node, options);
    const sourceFile = originalNode.getSourceFile();
    if (sourceFile == null || originalNode.pos === -1 || originalNode.end === -1)
        return [];
    const commentRanges = (options.leading
        ? [
            ...((_a = options.typescript.getLeadingCommentRanges(sourceFile.text, originalNode.pos)) !== null && _a !== void 0 ? _a : []),
            ...((_b = options.typescript.getTrailingCommentRanges(sourceFile.text, originalNode.pos)) !== null && _b !== void 0 ? _b : [])
        ]
        : [
            ...((_c = options.typescript.getLeadingCommentRanges(sourceFile.text, originalNode.end)) !== null && _c !== void 0 ? _c : []),
            ...((_d = options.typescript.getTrailingCommentRanges(sourceFile.text, originalNode.end)) !== null && _d !== void 0 ? _d : [])
        ]).map(range => (Object.assign(Object.assign({}, range), { hasTrailingNewLine: Boolean(range.hasTrailingNewLine), isLeading: options.leading })));
    for (const commentRange of commentRanges) {
        if (options.commentRanges.has(formatCommentRange(commentRange)))
            continue;
        options.commentRanges.add(formatCommentRange(commentRange));
        const text = sourceFile.text.substring(commentRange.pos, commentRange.end);
        if (!text.startsWith("//") && !text.startsWith("/*"))
            continue;
        const isUsingLineCarriages = text.includes("\r\n");
        const isJsDoc = text.startsWith("/**");
        comments.push(Object.assign(Object.assign({}, commentRange), { text: text
                .split(/\r?\n/)
                .map(line => line.trim())
                .map(line => (!isJsDoc || line.startsWith("/**") ? line : ` ${line}`))
                .join(isUsingLineCarriages ? `\r\n` : `\n`) }));
    }
    return comments;
}
function preserveAllComments(node, options) {
    if (!options.preserveComments)
        return;
    preserveCommentsForOriginalNode(node, options);
    options.typescript.forEachChild(node, child => {
        preserveAllComments(child, options);
    });
}
function preserveCommentsForOriginalNode(node, options) {
    if (options.typescript.isSourceFile(node))
        return;
    const originalNode = getOriginalNode(node, options);
    if (node !== originalNode)
        preserveComments(node, originalNode, options);
}
function preserveComments(node, oldNode, options) {
    if (!options.preserveComments)
        return node;
    if (node.pos > -1 && node.end >= -1) {
        return node;
    }
    if (node.jsDoc == null && oldNode.jsDoc != null) {
        node.jsDoc = oldNode.jsDoc;
    }
    const comments = getCommentRanges(oldNode, options);
    if (comments.length > 0) {
        options.typescript.setSyntheticLeadingComments(node, undefined);
    }
    for (const { isLeading, text, hasTrailingNewLine, kind } of comments) {
        let slicedComment;
        if (text.startsWith("/**")) {
            // 'addSyntheticLeadingComment' will place the leading '/*' and the trailing '*/', so these two parts must be stripped
            // from the text before passing it to TypeScript
            slicedComment = text.slice(2, text.length - 2);
        }
        else if (text.startsWith("/*")) {
            // 'addSyntheticLeadingComment' will place the leading '/*' and the trailing '*/', so these two parts must be stripped
            // from the text before passing it to TypeScript
            slicedComment = text.slice(2, text.length - 2);
        }
        else {
            // 'addSyntheticLeadingComment' will place the leading '//', so this part must be stripped
            // from the text before passing it to TypeScript
            slicedComment = text.slice(2);
        }
        if (isLeading) {
            options.typescript.addSyntheticLeadingComment(node, kind, slicedComment, hasTrailingNewLine);
        }
        else {
            options.typescript.addSyntheticTrailingComment(node, kind, slicedComment, hasTrailingNewLine);
        }
    }
    return node;
}

function nextOptions(options) {
    return Object.assign(Object.assign({}, options), { depth: options.depth + 1 });
}

function payload({ depth }) {
    return { depth };
}

function cloneNamespaceExport(node, options) {
    return options.typescript.createNamespaceExport(options.hook("name", options.nextNode(node.name), node.name));
}

/**
 * Returns true if the given Node is a JSDocReadonlyTag
 */
function isJSDocReadonlyTag(node, typescript) {
    return node.kind === typescript.SyntaxKind.JSDocReadonlyTag;
}

function cloneJSDocReadonlyTag(node, options) {
    const baseNode = options.typescript.createNode(options.typescript.SyntaxKind.JSDocReadonlyTag, -1, -1);
    baseNode.flags = options.hook("flags", (node.flags |= 8), (node.flags |= 8));
    baseNode.comment = options.hook("comment", node.comment, node.comment);
    baseNode.tagName = options.hook("tagName", options.nextNode(node.tagName), node.tagName);
    return baseNode;
}

/**
 * Returns true if the given Node is a JSDocPrivateTag
 */
function isJSDocPrivateTag(node, typescript) {
    return node.kind === typescript.SyntaxKind.JSDocPrivateTag;
}

function cloneJSDocPrivateTag(node, options) {
    const baseNode = options.typescript.createNode(options.typescript.SyntaxKind.JSDocPrivateTag, -1, -1);
    baseNode.flags = options.hook("flags", (node.flags |= 8), (node.flags |= 8));
    baseNode.comment = options.hook("comment", node.comment, node.comment);
    baseNode.tagName = options.hook("tagName", options.nextNode(node.tagName), node.tagName);
    return baseNode;
}

/**
 * Returns true if the given Node is a JSDocProtectedTag
 */
function isJSDocProtectedTag(node, typescript) {
    return node.kind === typescript.SyntaxKind.JSDocProtectedTag;
}

function cloneJSDocProtectedTag(node, options) {
    const baseNode = options.typescript.createNode(options.typescript.SyntaxKind.JSDocProtectedTag, -1, -1);
    baseNode.flags = options.hook("flags", (node.flags |= 8), (node.flags |= 8));
    baseNode.comment = options.hook("comment", node.comment, node.comment);
    baseNode.tagName = options.hook("tagName", options.nextNode(node.tagName), node.tagName);
    return baseNode;
}

/**
 * Returns true if the given Node is a JSDocPublicTag
 */
function isJSDocPublicTag(node, typescript) {
    return node.kind === typescript.SyntaxKind.JSDocPublicTag;
}

function cloneJSDocPublicTag(node, options) {
    const baseNode = options.typescript.createNode(options.typescript.SyntaxKind.JSDocPublicTag, -1, -1);
    baseNode.flags = options.hook("flags", (node.flags |= 8), (node.flags |= 8));
    baseNode.comment = options.hook("comment", node.comment, node.comment);
    baseNode.tagName = options.hook("tagName", options.nextNode(node.tagName), node.tagName);
    return baseNode;
}

function clonePrivateIdentifier(node, options) {
    return options.typescript.createPrivateIdentifier(options.hook("text", node.text, node.text));
}

function toSetParentNodesOptions(options) {
    var _a, _b, _c;
    return {
        typescript: (_a = options.typescript) !== null && _a !== void 0 ? _a : TSModule,
        propertyName: (_b = options.propertyName) !== null && _b !== void 0 ? _b : "parent",
        deep: (_c = options.deep) !== null && _c !== void 0 ? _c : true
    };
}

function setParentNodes(node, options) {
    return setParents(node, toSetParentNodesOptions(options));
}
function preserveNode(node, oldNode, options = {}) {
    var _a, _b, _c;
    const internalOptions = toInternalOptions(options);
    executePreserveNode(node, oldNode, internalOptions);
    if (node != null) {
        const parentValue = (_c = (_b = (_a = node._parent) !== null && _a !== void 0 ? _a : node.parent) !== null && _b !== void 0 ? _b : oldNode === null || oldNode === void 0 ? void 0 : oldNode._parent) !== null && _c !== void 0 ? _c : oldNode === null || oldNode === void 0 ? void 0 : oldNode.parent;
        if (internalOptions.setParents) {
            node.parent = parentValue;
        }
        else {
            node._parent = parentValue;
        }
    }
    return node;
}
function cloneNode(node, options = {}) {
    var _a, _b, _c;
    if (node === undefined)
        return undefined;
    const internalOptions = toInternalOptions(options);
    const clone = nextNode(node, internalOptions);
    executePreserveNode(clone, node, internalOptions);
    if (clone != null) {
        const parentValue = (_c = (_b = (_a = node._parent) !== null && _a !== void 0 ? _a : node.parent) !== null && _b !== void 0 ? _b : clone._parent) !== null && _c !== void 0 ? _c : clone.parent;
        if (internalOptions.setParents) {
            clone.parent = parentValue;
        }
        else {
            clone._parent = parentValue;
        }
    }
    return clone;
}
function nextNode(node, options) {
    var _a, _b;
    if (node === undefined)
        return undefined;
    const hook = ((_a = options.hook(node, payload(options))) !== null && _a !== void 0 ? _a : {});
    const visitorOptions = Object.assign(Object.assign({}, options), { nextNode: (actualNode) => nextNode(actualNode, nextOptions(options)), nextNodes: ((actualNodes) => nextNodes(actualNodes, nextOptions(options))), hook: (key, newValue, oldValue) => {
            const callback = hook[key];
            if (callback != null) {
                return callback(newValue, oldValue);
            }
            else {
                return newValue;
            }
        } });
    const clone = executeCloneNode(node, visitorOptions);
    if (clone === undefined)
        return undefined;
    if (node.jsDoc != null) {
        clone.jsDoc = visitorOptions.hook("jsDoc", visitorOptions.nextNodes(node.jsDoc), node.jsDoc);
    }
    setOriginalNodes(clone, node, options);
    preserveSymbols(clone, node, options);
    return options.finalize == null ? clone : (_b = options.finalize(clone, node, payload(options))) !== null && _b !== void 0 ? _b : clone;
}
function executePreserveNode(node, oldNode, options) {
    if (node == null || oldNode == null || node === oldNode)
        return undefined;
    setParents(node, toSetParentNodesOptions(Object.assign(Object.assign({}, options), { propertyName: options.setParents ? "parent" : "_parent" })));
    // Prioritize leading over trailing comments
    preserveAllComments(node, Object.assign(Object.assign({}, options), { leading: true }));
    preserveAllComments(node, Object.assign(Object.assign({}, options), { leading: false }));
    preserveComments(node, oldNode, Object.assign(Object.assign({}, options), { leading: true }));
    preserveComments(node, oldNode, Object.assign(Object.assign({}, options), { leading: false }));
    setOriginalNodes(node, oldNode, options);
    preserveSymbols(node, oldNode, options);
}
function setOriginalNodes(newNode, oldNode, options) {
    if (newNode === oldNode)
        return;
    if (options.setOriginalNodes) {
        options.typescript.setOriginalNode(newNode, oldNode);
        newNode._original = newNode.original;
    }
    else {
        newNode._original = oldNode;
    }
}
function preserveSymbols(node, otherNode, options) {
    var _a;
    if (node === otherNode)
        return node;
    const otherSymbol = (_a = otherNode._symbol) !== null && _a !== void 0 ? _a : otherNode.symbol;
    if (otherSymbol != null) {
        node._symbol = otherSymbol;
    }
    if (options.preserveSymbols) {
        node.symbol = node._symbol;
    }
    return node;
}
function nextNodes(nodes, options) {
    if (nodes === undefined)
        return undefined;
    return nodes.map(node => nextNode(node, options));
}
function executeCloneNode(node, options) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (node == null)
        return undefined;
    // Handle the Node
    if (options.typescript.isSourceFile(node)) {
        return cloneSourceFile(node, options);
    }
    // Handle the Node
    else if (options.typescript.isIdentifier(node)) {
        return cloneIdentifier(node, options);
    }
    // Handle the Node
    // Note: isPrivateIdentifier may not be supported by the provided TypeScript version, so the invocation is optional.
    else if ((_b = (_a = options.typescript).isPrivateIdentifier) === null || _b === void 0 ? void 0 : _b.call(_a, node)) {
        return clonePrivateIdentifier(node, options);
    }
    // Handle the Node
    else if (options.typescript.isTypeAliasDeclaration(node)) {
        return cloneTypeAliasDeclaration(node, options);
    }
    // Handle the Node
    else if (options.typescript.isTypeParameterDeclaration(node)) {
        return cloneTypeParameterDeclaration(node, options);
    }
    // Handle the Node
    else if (options.typescript.isDecorator(node)) {
        return cloneDecorator(node, options);
    }
    // Handle the Node
    else if (options.typescript.isQualifiedName(node)) {
        return cloneQualifiedName(node, options);
    }
    // Handle the Node
    else if (options.typescript.isComputedPropertyName(node)) {
        return cloneComputedPropertyName(node, options);
    }
    // Handle the Node
    else if (options.typescript.isCallSignatureDeclaration(node)) {
        return cloneCallSignatureDeclaration(node, options);
    }
    // Handle the Node
    else if (options.typescript.isConstructSignatureDeclaration(node)) {
        return cloneConstructSignatureDeclaration(node, options);
    }
    // Handle the Node
    else if (options.typescript.isVariableDeclaration(node)) {
        return cloneVariableDeclaration(node, options);
    }
    // Handle the Node
    else if (options.typescript.isVariableDeclarationList(node)) {
        return cloneVariableDeclarationList(node, options);
    }
    // Handle the Node
    else if (options.typescript.isVariableStatement(node)) {
        return cloneVariableStatement(node, options);
    }
    // Handle the Node
    else if (options.typescript.isParameter(node)) {
        return cloneParameterDeclaration(node, options);
    }
    // Handle the Node
    else if (options.typescript.isBindingElement(node)) {
        return cloneBindingElement(node, options);
    }
    // Handle the Node
    else if (options.typescript.isPropertySignature(node)) {
        return clonePropertySignature(node, options);
    }
    // Handle the Node
    else if (options.typescript.isPropertyDeclaration(node)) {
        return clonePropertyDeclaration(node, options);
    }
    // Handle the Node
    else if (options.typescript.isPropertyAssignment(node)) {
        return clonePropertyAssignment(node, options);
    }
    // Handle the Node
    else if (options.typescript.isShorthandPropertyAssignment(node)) {
        return cloneShorthandPropertyAssignment(node, options);
    }
    // Handle the Node
    else if (options.typescript.isSpreadAssignment(node)) {
        return cloneSpreadAssignment(node, options);
    }
    // Handle the Node
    else if (options.typescript.isObjectBindingPattern(node)) {
        return cloneObjectBindingPattern(node, options);
    }
    // Handle the Node
    else if (options.typescript.isArrayBindingPattern(node)) {
        return cloneArrayBindingPattern(node, options);
    }
    // Handle the Node
    else if (options.typescript.isFunctionDeclaration(node)) {
        return cloneFunctionDeclaration(node, options);
    }
    // Handle the Node
    else if (options.typescript.isMethodSignature(node)) {
        return cloneMethodSignature(node, options);
    }
    // Handle the Node
    else if (options.typescript.isMethodDeclaration(node)) {
        return cloneMethodDeclaration(node, options);
    }
    // Handle the Node
    else if (options.typescript.isConstructorDeclaration(node)) {
        return cloneConstructorDeclaration(node, options);
    }
    // Handle the Node
    else if (options.typescript.isSemicolonClassElement(node)) {
        return cloneSemicolonClassElement(node, options);
    }
    // Handle the Node
    else if (options.typescript.isGetAccessorDeclaration(node)) {
        return cloneGetAccessorDeclaration(node, options);
    }
    // Handle the Node
    else if (options.typescript.isSetAccessorDeclaration(node)) {
        return cloneSetAccessorDeclaration(node, options);
    }
    // Handle the Node
    else if (options.typescript.isIndexSignatureDeclaration(node)) {
        return cloneIndexSignatureDeclaration(node, options);
    }
    // Handle the Node
    else if (isKeywordTypeNode(node, options.typescript)) {
        return cloneKeywordTypeNode(node, options);
    }
    // Handle the Node
    else if (options.typescript.isImportTypeNode(node)) {
        return cloneImportTypeNode(node, options);
    }
    // Handle the Node
    else if (options.typescript.isThisTypeNode(node)) {
        return cloneThisTypeNode(node, options);
    }
    // Handle the Node
    else if (options.typescript.isFunctionTypeNode(node)) {
        return cloneFunctionTypeNode(node, options);
    }
    // Handle the Node
    else if (options.typescript.isConstructorTypeNode(node)) {
        return cloneConstructorTypeNode(node, options);
    }
    // Handle the Node
    else if (options.typescript.isTypeReferenceNode(node)) {
        return cloneTypeReferenceNode(node, options);
    }
    // Handle the Node
    else if (options.typescript.isTypePredicateNode(node)) {
        return cloneTypePredicateNode(node, options);
    }
    // Handle the Node
    else if (options.typescript.isTypeQueryNode(node)) {
        return cloneTypeQueryNode(node, options);
    }
    // Handle the Node
    else if (options.typescript.isTypeLiteralNode(node)) {
        return cloneTypeLiteralNode(node, options);
    }
    // Handle the Node
    else if (options.typescript.isArrayTypeNode(node)) {
        return cloneArrayTypeNode(node, options);
    }
    // Handle the Node
    else if (options.typescript.isTupleTypeNode(node)) {
        return cloneTupleTypeNode(node, options);
    }
    // Handle the Node
    else if (isOptionalTypeNode(node, options.typescript)) {
        return cloneOptionalTypeNode(node, options);
    }
    // Handle the Node
    else if (isRestTypeNode(node, options.typescript)) {
        return cloneRestTypeNode(node, options);
    }
    // Handle the Node
    else if (options.typescript.isUnionTypeNode(node)) {
        return cloneUnionTypeNode(node, options);
    }
    // Handle the Node
    else if (options.typescript.isIntersectionTypeNode(node)) {
        return cloneIntersectionTypeNode(node, options);
    }
    // Handle the Node
    else if (options.typescript.isConditionalTypeNode(node)) {
        return cloneConditionalTypeNode(node, options);
    }
    // Handle the Node
    else if (options.typescript.isInferTypeNode(node)) {
        return cloneInferTypeNode(node, options);
    }
    // Handle the Node
    else if (options.typescript.isLiteralTypeNode(node)) {
        return cloneLiteralTypeNode(node, options);
    }
    // Handle the Node
    else if (options.typescript.isStringLiteral(node)) {
        return cloneStringLiteral(node, options);
    }
    // Handle the Node
    else if (isBooleanLiteral(node, options.typescript)) {
        return cloneBooleanLiteral(node, options);
    }
    // Handle the Node
    else if (options.typescript.isRegularExpressionLiteral(node)) {
        return cloneRegularExpressionLiteral(node, options);
    }
    // Handle the Node
    else if (options.typescript.isNoSubstitutionTemplateLiteral(node)) {
        return cloneNoSubstitutionTemplateLiteral(node, options);
    }
    // Handle the Node
    else if (options.typescript.isNumericLiteral(node)) {
        return cloneNumericLiteral(node, options);
    }
    // Handle the Node.
    // Note: isBigIntLiteral may not be supported by the provided TypeScript version, so the invocation is optional.
    else if ((_d = (_c = options.typescript).isBigIntLiteral) === null || _d === void 0 ? void 0 : _d.call(_c, node)) {
        return cloneBigIntLiteral(node, options);
    }
    // Handle the Node
    else if (options.typescript.isArrayLiteralExpression(node)) {
        return cloneArrayLiteralExpression(node, options);
    }
    // Handle the Node
    else if (options.typescript.isObjectLiteralExpression(node)) {
        return cloneObjectLiteralExpression(node, options);
    }
    // Handle the Node
    else if (options.typescript.isPrefixUnaryExpression(node)) {
        return clonePrefixUnaryExpression(node, options);
    }
    // Handle the Node
    else if (options.typescript.isBlock(node)) {
        return cloneBlock(node, options);
    }
    // Handle the Node
    else if (options.typescript.isThrowStatement(node)) {
        return cloneThrowStatement(node, options);
    }
    // Handle the Node
    else if (options.typescript.isReturnStatement(node)) {
        return cloneReturnStatement(node, options);
    }
    // Handle the Node
    else if (options.typescript.isNewExpression(node)) {
        return cloneNewExpression(node, options);
    }
    // Handle the Node
    else if (options.typescript.isCallExpression(node)) {
        return cloneCallExpression(node, options);
    }
    // Handle the Node
    else if (options.typescript.isExpressionStatement(node)) {
        return cloneExpressionStatement(node, options);
    }
    // Handle the Node
    else if (options.typescript.isExpressionWithTypeArguments(node)) {
        return cloneExpressionWithTypeArguments(node, options);
    }
    // Handle the Node
    else if (options.typescript.isPropertyAccessExpression(node)) {
        return clonePropertyAccessExpression(node, options);
    }
    // Handle the Node
    else if (options.typescript.isElementAccessExpression(node)) {
        return cloneElementAccessExpression(node, options);
    }
    // Handle the Node
    else if (options.typescript.isTemplateExpression(node)) {
        return cloneTemplateExpression(node, options);
    }
    // Handle the Node
    else if (options.typescript.isTemplateSpan(node)) {
        return cloneTemplateSpan(node, options);
    }
    // Handle the Node
    else if (options.typescript.isTemplateHead(node)) {
        return cloneTemplateHead(node, options);
    }
    // Handle the Node
    else if (options.typescript.isTemplateMiddle(node)) {
        return cloneTemplateMiddle(node, options);
    }
    // Handle the Node
    else if (options.typescript.isTemplateTail(node)) {
        return cloneTemplateTail(node, options);
    }
    // Handle the Node
    else if (options.typescript.isConditionalExpression(node)) {
        return cloneConditionalExpression(node, options);
    }
    // Handle the Node
    else if (options.typescript.isBinaryExpression(node)) {
        return cloneBinaryExpression(node, options);
    }
    // Handle the Node
    else if (options.typescript.isParenthesizedExpression(node)) {
        return cloneParenthesizedExpression(node, options);
    }
    // Handle the Node
    else if (options.typescript.isParenthesizedTypeNode(node)) {
        return cloneParenthesizedTypeNode(node, options);
    }
    // Handle the Node
    else if (options.typescript.isArrowFunction(node)) {
        return cloneArrowFunction(node, options);
    }
    // Handle the Node
    else if (options.typescript.isClassDeclaration(node)) {
        return cloneClassDeclaration(node, options);
    }
    // Handle the Node
    else if (options.typescript.isClassExpression(node)) {
        return cloneClassExpression(node, options);
    }
    // Handle the Node
    else if (options.typescript.isEnumDeclaration(node)) {
        return cloneEnumDeclaration(node, options);
    }
    // Handle the Node
    else if (options.typescript.isEnumMember(node)) {
        return cloneEnumMember(node, options);
    }
    // Handle the Node
    else if (options.typescript.isInterfaceDeclaration(node)) {
        return cloneInterfaceDeclaration(node, options);
    }
    // Handle the Node
    else if (options.typescript.isHeritageClause(node)) {
        return cloneHeritageClause(node, options);
    }
    // Handle the Node
    else if (options.typescript.isEmptyStatement(node)) {
        return cloneEmptyStatement(node, options);
    }
    // Handle the Node
    else if (options.typescript.isAsExpression(node)) {
        return cloneAsExpression(node, options);
    }
    // Handle the Node
    else if (options.typescript.isTypeAssertion(node)) {
        return cloneTypeAssertion(node, options);
    }
    // Handle the Node
    else if (options.typescript.isAwaitExpression(node)) {
        return cloneAwaitExpression(node, options);
    }
    // Handle the Node
    else if (options.typescript.isYieldExpression(node)) {
        return cloneYieldExpression(node, options);
    }
    // Handle the Node
    else if (options.typescript.isForOfStatement(node)) {
        return cloneForOfStatement(node, options);
    }
    // Handle the Node
    else if (options.typescript.isForInStatement(node)) {
        return cloneForInStatement(node, options);
    }
    // Handle the Node
    else if (options.typescript.isForStatement(node)) {
        return cloneForStatement(node, options);
    }
    // Handle the Node
    else if (options.typescript.isWhileStatement(node)) {
        return cloneWhileStatement(node, options);
    }
    // Handle the Node
    else if (options.typescript.isLabeledStatement(node)) {
        return cloneLabeledStatement(node, options);
    }
    // Handle the Node
    else if (options.typescript.isBreakStatement(node)) {
        return cloneBreakStatement(node, options);
    }
    // Handle the Node
    else if (options.typescript.isContinueStatement(node)) {
        return cloneContinueStatement(node, options);
    }
    // Handle the Node
    else if (options.typescript.isIfStatement(node)) {
        return cloneIfStatement(node, options);
    }
    // Handle the Node
    else if (options.typescript.isDoStatement(node)) {
        return cloneDoStatement(node, options);
    }
    // Handle the Node
    else if (options.typescript.isNonNullExpression(node)) {
        return cloneNonNullExpression(node, options);
    }
    // Handle the Node
    else if (options.typescript.isTypeOperatorNode(node)) {
        return cloneTypeOperatorNode(node, options);
    }
    // Handle the Node
    else if (options.typescript.isIndexedAccessTypeNode(node)) {
        return cloneIndexedAccessTypeNode(node, options);
    }
    // Handle the Node
    // Note: isMappedTypeNode may not be supported by the provided TypeScript version, so the invocation is optional.
    else if ((_f = (_e = options.typescript).isMappedTypeNode) === null || _f === void 0 ? void 0 : _f.call(_e, node)) {
        return cloneMappedTypeNode(node, options);
    }
    // Handle the Node
    else if (options.typescript.isOmittedExpression(node)) {
        return cloneOmittedExpression(node, options);
    }
    // Handle the Node
    else if (isPartiallyEmittedExpression(node, options.typescript)) {
        return clonePartiallyEmittedExpression(node, options);
    }
    // Handle the Node
    else if (options.typescript.isPostfixUnaryExpression(node)) {
        return clonePostfixUnaryExpression(node, options);
    }
    // Handle the Node
    else if (isNullLiteral(node, options.typescript)) {
        return cloneNullLiteral(node, options);
    }
    // Handle the Node
    else if (isThisExpression(node, options.typescript)) {
        return cloneThisExpression(node, options);
    }
    // Handle the Node
    else if (isSuperExpression(node, options.typescript)) {
        return cloneSuperExpression(node, options);
    }
    // Handle the Node
    else if (options.typescript.isDeleteExpression(node)) {
        return cloneDeleteExpression(node, options);
    }
    // Handle the Node
    else if (options.typescript.isTypeOfExpression(node)) {
        return cloneTypeOfExpression(node, options);
    }
    // Handle the Node
    else if (options.typescript.isVoidExpression(node)) {
        return cloneVoidExpression(node, options);
    }
    // Handle the Node
    else if (options.typescript.isFunctionExpression(node)) {
        return cloneFunctionExpression(node, options);
    }
    // Handle the Node
    else if (options.typescript.isSpreadElement(node)) {
        return cloneSpreadElement(node, options);
    }
    // Handle the Node
    else if (options.typescript.isTaggedTemplateExpression(node)) {
        return cloneTaggedTemplateExpression(node, options);
    }
    // Handle the Node
    else if (options.typescript.isMetaProperty(node)) {
        return cloneMetaProperty(node, options);
    }
    // Handle the Node
    else if (options.typescript.isJsxElement(node)) {
        return cloneJsxElement(node, options);
    }
    // Handle the Node
    else if (options.typescript.isJsxAttributes(node)) {
        return cloneJsxAttributes(node, options);
    }
    // Handle the Node
    else if (options.typescript.isJsxOpeningElement(node)) {
        return cloneJsxOpeningElement(node, options);
    }
    // Handle the Node
    else if (options.typescript.isJsxSelfClosingElement(node)) {
        return cloneJsxSelfClosingElement(node, options);
    }
    // Handle the Node
    else if (options.typescript.isJsxFragment(node)) {
        return cloneJsxFragment(node, options);
    }
    // Handle the Node
    else if (options.typescript.isJsxOpeningFragment(node)) {
        return cloneJsxOpeningFragment(node, options);
    }
    // Handle the Node
    else if (options.typescript.isJsxClosingFragment(node)) {
        return cloneJsxClosingFragment(node, options);
    }
    // Handle the Node
    else if (options.typescript.isJsxAttribute(node)) {
        return cloneJsxAttribute(node, options);
    }
    // Handle the Node
    else if (options.typescript.isJsxSpreadAttribute(node)) {
        return cloneJsxSpreadAttribute(node, options);
    }
    // Handle the Node
    else if (options.typescript.isJsxClosingElement(node)) {
        return cloneJsxClosingElement(node, options);
    }
    // Handle the Node
    else if (options.typescript.isJsxExpression(node)) {
        return cloneJsxExpression(node, options);
    }
    // Handle the Node
    else if (options.typescript.isJsxText(node)) {
        return cloneJsxText(node, options);
    }
    // Handle the Node
    else if (isNotEmittedStatement(node, options.typescript)) {
        return cloneNotEmittedStatement(node, options);
    }
    // Handle the Node
    else if (isCommaListExpression(node, options.typescript)) {
        return cloneCommaListExpression(node, options);
    }
    // Handle the Node
    else if (options.typescript.isDebuggerStatement(node)) {
        return cloneDebuggerStatement(node, options);
    }
    // Handle the Node
    else if (options.typescript.isWithStatement(node)) {
        return cloneWithStatement(node, options);
    }
    // Handle the Node
    else if (options.typescript.isSwitchStatement(node)) {
        return cloneSwitchStatement(node, options);
    }
    // Handle the Node
    else if (options.typescript.isCaseBlock(node)) {
        return cloneCaseBlock(node, options);
    }
    // Handle the Node
    else if (options.typescript.isCaseClause(node)) {
        return cloneCaseClause(node, options);
    }
    // Handle the Node
    else if (options.typescript.isDefaultClause(node)) {
        return cloneDefaultClause(node, options);
    }
    // Handle the Node
    else if (options.typescript.isTryStatement(node)) {
        return cloneTryStatement(node, options);
    }
    // Handle the Node
    else if (options.typescript.isCatchClause(node)) {
        return cloneCatchClause(node, options);
    }
    // Handle the Node
    else if (options.typescript.isModuleDeclaration(node)) {
        return cloneModuleDeclaration(node, options);
    }
    // Handle the Node
    else if (options.typescript.isModuleBlock(node)) {
        return cloneModuleBlock(node, options);
    }
    // Handle the Node
    else if (options.typescript.isImportEqualsDeclaration(node)) {
        return cloneImportEqualsDeclaration(node, options);
    }
    // Handle the Node
    else if (options.typescript.isExternalModuleReference(node)) {
        return cloneExternalModuleReference(node, options);
    }
    // Handle the Node
    else if (options.typescript.isImportDeclaration(node)) {
        return cloneImportDeclaration(node, options);
    }
    // Handle the Node
    else if (options.typescript.isImportClause(node)) {
        return cloneImportClause(node, options);
    }
    // Handle the Node
    else if (options.typescript.isNamedImports(node)) {
        return cloneNamedImports(node, options);
    }
    // Handle the Node
    else if (options.typescript.isNamespaceImport(node)) {
        return cloneNamespaceImport(node, options);
    }
    // Handle the Node
    else if (options.typescript.isImportSpecifier(node)) {
        return cloneImportSpecifier(node, options);
    }
    // Handle the Node
    else if (options.typescript.isNamespaceExportDeclaration(node)) {
        return cloneNamespaceExportDeclaration(node, options);
    }
    // Handle the Node
    else if (options.typescript.isExportDeclaration(node)) {
        return cloneExportDeclaration(node, options);
    }
    // Handle the Node
    else if (options.typescript.isNamedExports(node)) {
        return cloneNamedExports(node, options);
    }
    // Handle the Node
    // Note: isNamespaceExport may not be supported by the provided TypeScript version, so the invocation is optional.
    else if ((_h = (_g = options.typescript).isNamespaceExport) === null || _h === void 0 ? void 0 : _h.call(_g, node)) {
        return cloneNamespaceExport(node, options);
    }
    // Handle the Node
    else if (options.typescript.isExportSpecifier(node)) {
        return cloneExportSpecifier(node, options);
    }
    // Handle the Node
    else if (options.typescript.isExportAssignment(node)) {
        return cloneExportAssignment(node, options);
    }
    // Handle the Node
    else if (isJsDocComment(node, options.typescript)) {
        return cloneJsDoc(node, options);
    }
    // Handle the Node
    else if (isJsDocParameterTag(node, options.typescript)) {
        return cloneJsDocParameterTag(node, options);
    }
    // Handle the Node
    else if (isJsDocReturnTag(node, options.typescript)) {
        return cloneJsDocReturnTag(node, options);
    }
    // Handle the Node
    else if (isJsDocTypeExpression(node, options.typescript)) {
        return cloneJsDocTypeExpression(node, options);
    }
    // Handle the Node
    else if (isJsDocEnumTag(node, options.typescript)) {
        return cloneJsDocEnumTag(node, options);
    }
    // Handle the Node
    else if (isJsDocTypeTag(node, options.typescript)) {
        return cloneJsDocTypeTag(node, options);
    }
    // Handle the Node
    else if (isJsDocAllType(node, options.typescript)) {
        return cloneJSDocAllType(node, options);
    }
    // Handle the Node
    else if (isJsDocUnknownType(node, options.typescript)) {
        return cloneJSDocUnknownType(node, options);
    }
    // Handle the Node
    else if (isJsDocNonNullableType(node, options.typescript)) {
        return cloneJSDocNonNullableType(node, options);
    }
    // Handle the Node
    else if (isJsDocNullableType(node, options.typescript)) {
        return cloneJSDocNullableType(node, options);
    }
    // Handle the Node
    else if (isJSDocOptionalType(node, options.typescript)) {
        return cloneJSDocOptionalType(node, options);
    }
    // Handle the Node
    else if (isJSDocFunctionType(node, options.typescript)) {
        return cloneJSDocFunctionType(node, options);
    }
    // Handle the Node
    else if (isJSDocVariadicType(node, options.typescript)) {
        return cloneJSDocVariadicType(node, options);
    }
    // Handle the Node
    else if (isJSDocNamepathType(node, options.typescript)) {
        return cloneJSDocNamepathType(node, options);
    }
    // Handle the Node
    else if (isJsDocUnknownTag(node, options.typescript)) {
        return cloneJsDocUnknownTag(node, options);
    }
    // Handle the Node
    else if (isJSDocAugmentsTag(node, options.typescript)) {
        return cloneJSDocAugmentsTag(node, options);
    }
    // Handle the Node
    else if (isJSDocAuthorTag(node, options.typescript)) {
        return cloneJsDocAuthorTag(node, options);
    }
    // Handle the Node
    else if (isJSDocClassTag(node, options.typescript)) {
        return cloneJsDocClassTag(node, options);
    }
    // Handle the Node
    else if (isJSDocThisTag(node, options.typescript)) {
        return cloneJSDocThisTag(node, options);
    }
    // Handle the Node
    else if (isJSDocTemplateTag(node, options.typescript)) {
        return cloneJSDocTemplateTag(node, options);
    }
    // Handle the Node
    else if (isJSDocTypedefTag(node, options.typescript)) {
        return cloneJSDocTypedefTag(node, options);
    }
    // Handle the Node
    else if (isJSDocCallbackTag(node, options.typescript)) {
        return cloneJSDocCallbackTag(node, options);
    }
    // Handle the Node
    else if (isJSDocSignature(node, options.typescript)) {
        return cloneJSDocSignature(node, options);
    }
    // Handle the Node
    else if (isJsDocPropertyTag(node, options.typescript)) {
        return cloneJSDocPropertyTag(node, options);
    }
    // Handle the Node
    else if (isJsDocTypeLiteral(node, options.typescript)) {
        return cloneJSDocTypeLiteral(node, options);
    }
    // Handle the Node
    else if (isJSDocReadonlyTag(node, options.typescript)) {
        return cloneJSDocReadonlyTag(node, options);
    }
    // Handle the Node
    else if (isJSDocPrivateTag(node, options.typescript)) {
        return cloneJSDocPrivateTag(node, options);
    }
    // Handle the Node
    else if (isJSDocProtectedTag(node, options.typescript)) {
        return cloneJSDocProtectedTag(node, options);
    }
    // Handle the Node
    else if (isJSDocPublicTag(node, options.typescript)) {
        return cloneJSDocPublicTag(node, options);
    }
    // Handle the Node
    else if (options.typescript.isToken(node)) {
        return cloneToken(node, options);
    }
    throw new TypeError(`Could not handle Node of kind: '${SyntaxKind[node.kind]}'`);
}

export { cloneNode, preserveNode, setParentNodes };
//# sourceMappingURL=index.js.map
